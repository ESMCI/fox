<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>FoX_wcml</title>
  <link rel="stylesheet" type="text/css" href="DoX.css"/>
</head>
<body>
  <div class="DoX">
<h1>WCML</h1>

<h3>General naming conventions for functions.</h3>

<p>Functions are named in the following way:</p>

<ul>
<li><p>All functions begin 
<code>cml</code></p></li>
<li><p>To begin and end a section of the CML file,
a pair of functions will exist:</p>

<ul>
<li><code>cmlStart</code>something</li>
<li><code>cmlEnd</code>something</li>
</ul></li>
<li><p>To output a given quantity/property/concept etc. a function will exist
<code>cmlAdd</code>something</p></li>
</ul>

<h3>General mapping of concepts.</h3>

<p>The available functions and their intended use are listed below. Quite deliberately, no reference is made to the actual CML output by each function. </p>

<p>Wcml is <em>not</em> intended to be a generalized Fortran CML output layer. rather it is intended to be a library which allows the output of a limited set of well-defined syntactical fragments.</p>

<p>Further information on these fragments, and on the style of CML generated here, is available at <a href="http://www.uszla.me.uk/CML/eminerals.html">http://www.uszla.me.uk/CML/eminerals.html</a></p>

<h3>Listing of functions.</h3>

<h4>Conventions used below.</h4>

<ul>
<li>Function names are in <code>monospace</code></li>
<li>argument names are in <strong>bold</strong></li>
<li>optional argument names are in (<strong>parenthesized bold</strong>)</li>
<li>argument types are in /italic/ and may consist of:</li>
<li>/string/: string of arbitrary (unless otherwise specified) length</li>
<li>/integer/: default integer</li>
<li>/real(sp)/: single precision real number</li>
<li>/real(dp)/: double precision real number</li>
<li>/logical/: default logical </li>
<li>/real/: either of /real(sp)/ or /real(dp)/</li>
<li>/anytype/: any of /logical/, /integer/, /real(sp)/, /real(dp)/, /string/</li>
</ul>

<p>Note that where /strings/ are passed in, they will be passed through entirely unchanged to the output file - no truncation of whitespace will occur.</p>

<ul>
<li>/scalar/: single item</li>
<li>/array/: one-dimensional array of items</li>
<li>/matrix/: two-dimensional array of items</li>
<li>/anydim/: any of /scalar/, /array/, /matrix/</li>
</ul>

<p>Where an /array/ is passed in, it may be passed either as an assumed-shape array; that is, as an F90-style array with no necessity for specifying bounds; thusly:</p>

<pre><code>integer :: array(50)
call cmlAddProperty(xf, 'coords', array)
</code></pre>

<p>or as an assumed-size array; that is, an F77-style array, in which case the length must be passed as an additional parameter:</p>

<pre><code>integer :: array(*)
call cmlAddProperty(xf, 'coords', array, nitems=50)
</code></pre>

<p>Similarly, when a /matrix/ is passed in, it may be passed in both fashions:</p>

<pre><code>integer :: matrix(50, 50)
call cmlAddProperty(xf, 'coords', matrix)
</code></pre>

<p>or </p>

<pre><code>integer :: array(3, *)
call cmlAddProperty(xf, 'coords', matrix, nrows=3, ncols=50)
</code></pre>

<p>All functions take as their first argument an XML file object, whose keyword is always <code>xf</code>. This file object is initialized by a cmlBegin function.</p>

<p>It is <em>highly</em> recommended that subroutines be called with keywords specified rather than relying on the implicit ordering of arguments. This is robust against changes in the library calling convention; and also stepsides a significant cause of errors when using subroutines with large numbers of arguments.</p>

<h4>Boiler plate functions.</h4>

<ul>
<li><code>cmlBegin</code>FIXME</li>
</ul>

<p>This is a boiler plate function which takes care of all calls to open a CML output file.</p>

<ul>
<li><code>cmlFinish</code> FIXME</li>
</ul>

<p>This is a boiler plate function which takes care of all call to close an open CML output file.</p>

<ul>
<li><p><code>cmlStartCml</code> </p></li>
<li><p><code>cmlEndCml</code></p></li>
</ul>

<p>This pair of functions begin and end the CML output to an existing CML file. It takes care of default headers &amp; namespaces.</p>

<ul>
<li><code>cmlAddNamespace</code>FIXME</li>
</ul>

<p>This adds a namespace to a CML file. <br />
NB This may only ever be called immediately after a <code>cmlStartCml</code> call; or after another <code>cmlAddNamespace</code> call.
Attempts to do otherwise will result in a runtime error.</p>

<p>This is a boiler plate function which takes care of ending CML output.</p>

<h5>Start/End sections</h5>

<ul>
<li><p><code>cmlStartMetadataList</code></p></li>
<li><p><code>cmlEndMetadataList</code></p></li>
</ul>

<p>This pair of functions open &amp; close a metadataList, which is a wrapper for metadata items.</p>

<ul>
<li><p><code>cmlStartParameterList</code></p></li>
<li><p><code>cmlEndParameterList</code></p></li>
</ul>

<p>This pair of functions open &amp; close a parameterList, which is a wrapper for input parameters.</p>

<ul>
<li><p><code>cmlStartPropertyList</code></p></li>
<li><p><code>cmlEndPropertyLIst</code></p></li>
</ul>

<p>This pair of functions open &amp; close a propertyList, which is a wrapper for output properties.</p>

<ul>
<li><p><code>cmlStartModule</code></p></li>
<li><p><code>cmlEndModule</code></p></li>
</ul>

<p>This pair of functions open &amp; close a module of a computation which is unordered, or loosely-ordered. For example, METADISE uses one module for each surface examined.</p>

<ul>
<li><p><code>cmlStartStep</code></p></li>
<li><p><code>cmlEndStep</code></p></li>
</ul>

<p>This pair of functions open and close a module of a computation which is strongly ordered. For example, DLPOLY uses steps for each step of the simulation.</p>

<h5>Adding items.</h5>

<ul>
<li><code>cmlAddMetadata</code></li>
</ul>

<p>This adds a single item of metadata. It takes the following arguments:</p>

<p><strong>name</strong>: /string/ /scalar/: Identifying string for metadata <br />
<strong>content</strong>: /anytype/ /scalar/: Content of metadata  </p>

<ul>
<li><code>cmlAddParameter</code></li>
</ul>

<p>This function adds a tag representing an input parameter</p>

<p><strong>title</strong>: /string/ /scalar/: Identifying title for parameter <br />
<strong>value</strong>:/anytype/ /anydim/: value of parameter <br />
<strong>units</strong>: /string/ /scalar/: units of parameter value <br />
<strong>cons</strong> FIXME</p>

<ul>
<li><code>cmlAddProperty</code></li>
</ul>

<p>This function adds a tag representing an output property</p>

<p><strong>name</strong>: /string/ /scalar/ <br />
<strong>property</strong>: /any/ /anydim/ <br />
<strong>units</strong>: /string/ /scalar/ units of property value  </p>

<ul>
<li><code>cmlAddMolecule</code></li>
</ul>

<p>Outputs an atomic configuration.</p>

<p><strong>coords</strong>: /real/: a 3xn matrix of real numbers representing atomic coordinates (either fractional or Cartesian) <br />
<strong>elems</strong>: /string/ /array/: a length-n array of length-2 strings containing IUPAC chemical symbols for the atoms <br />
(<strong>refs</strong>): /string/ /array/: a length-n array of strings containing references which may point to IDs elsewhere of, for example, pseudopotentials or basis sets defining the element's behaviour. <br />
(<strong>style</strong>): /string/ /scalar/: 'xyz3' - the coordinates are Cartesian, or <code>xyzFract</code> - the coordinates are fractional. The default is Cartesian.  </p>

<ul>
<li><code>cmlAddLattice</code> </li>
</ul>

<p>Outputs information about a unit cell, in lattice-vector form</p>

<p><strong>cell</strong>: /real/ /matrix/ a 3x3 matrix of the unit cell <br />
<strong>spaceType</strong>: given in 'real' or 'reciprocal' space. <br />
<strong>lattType</strong>: FIXME? <br />
<strong>units</strong>: units of (reciprocal) distance that cell vectors is given in</p>

<ul>
<li><code>cmlAddCrystal</code></li>
</ul>

<p>Outputs information about a unit cell, in crystallographic form</p>

<p><strong>a</strong>: /real/ /scalar/ the 'a' parameter (must be in Angstrom) <br />
<strong>b</strong>: /real/ /scalar/ the 'b' parameter <br />
<strong>c</strong>: /real/ /scalar/ the 'c' parameter <br />
<strong>alpha</strong>: /real/ /scalar/ the 'alpha' parameter <br />
<strong>beta</strong>: /real/ /scalar/ the 'beta' parameter <br />
<strong>gamma</strong>: /real/ /scalar/ the 'gamma' parameter <br />
<strong>lenunits</strong>: FIXME <br />
<strong>angunits</strong>: FIXME  </p>

<h5>general arguments</h5>

<p>All <code>cmlAdd</code> and <code>cmlStart</code> routines take the following set of optional arguments;</p>

<ul>
<li><code>id</code>: Unique identifying string for element. (Uniqueness is not enforce, though duplicated ids on output are usually an error and may cause later problems)  </li>
<li><code>ref</code>: Reference to the id of another element (Use is generally deprecated)  </li>
<li><code>title</code>: Human-readable title of element for display purposes  </li>
<li><code>dictRef</code>: reference to disambiguate element. Should be a QName; a namespaced string. An actual dictionary entry may or may not exist. It is not an error for it not to.  </li>
<li><code>conv</code>: convention by which the element is to be read.  </li>
<li><code>role</code>: role which the element plays  </li>
</ul>

<p>(The wording of the definitions for <code>conv</code> and <code>role</code> are deliberately loose.)</p>
</div>
</body>
</html>
