<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>FoX_wcml</title>
  <link rel="stylesheet" type="text/css" href="DoX.css"/>
</head>
<body>
  <div class="DoX">
<h1>WCML</h1>

<h2>General naming conventions for functions.</h2>

<p>Functions are named in the following way:</p>

<ul>
<li><p>All functions begin 
<code>cml</code></p></li>
<li><p>To begin and end a section of the CML file,
a pair of functions will exist:</p>

<ul>
<li><code>cmlStart</code>something</li>
<li><code>cmlEnd</code>something</li>
</ul></li>
<li><p>To output a given quantity/property/concept etc. a function will exist
<code>cmlAdd</code>something</p></li>
</ul>

<h2>General mapping of concepts.</h2>

<p>The available functions and their intended use are listed below. Quite deliberately, no reference is made to the actual CML output by each function. </p>

<p>Wcml is <em>not</em> intended to be a generalized Fortran CML output layer. rather it is intended to be a library which allows the output of a limited set of well-defined syntactical fragments.</p>

<p>Further information on these fragments, and on the style of CML generated here, is available at <a href="http://www.uszla.me.uk/CML/eminerals.html">http://www.uszla.me.uk/CML/eminerals.html</a>.</p>

<h2>Use of WCML</h2>

<p>wcml subroutines can be accessed from within a module or subroutine by inserting</p>

<pre><code> use FoX_wcml
</code></pre>

<p>at the start. This will import all of the subroutines described below, plus the derived type <code>xmlf_t</code> needed to manipulate a CML file.</p>

<p><em>No</em> other entities will be imported; public/private Fortran namespaces are very carefully  controlled within the library.</p>

<h2>Listing of functions.</h2>

<h4>Conventions used below.</h4>

<ul>
<li>Function names are in <code>monospace</code></li>
<li>argument names are in <strong>bold</strong></li>
<li>optional argument names are in (<strong>parenthesized bold</strong>)</li>
<li>argument types are in <em>italic</em> and may consist of:</li>
<li><em>string</em>: string of arbitrary (unless otherwise specified) length</li>
<li><em>integer</em>: default integer</li>
<li><em>real(sp)</em>: single precision real number</li>
<li><em>real(dp)</em>: double precision real number</li>
<li><em>logical</em>: default logical </li>
<li><em>real</em>: either of <em>real(sp)</em> or <em>real(dp)</em></li>
<li><em>anytype</em>: any of <em>logical</em>, <em>integer</em>, <em>real(sp)</em>, <em>real(dp)</em>, <em>string</em></li>
</ul>

<p>Note that where <em>strings</em> are passed in, they will be passed through entirely unchanged to the output file - no truncation of whitespace will occur.</p>

<p>Also note that wherever a <em>real</em> number can be passed in (including through <em>anytype</em>) then the formatting can be specified using the conventions described in <a href="StringFormatting.html">StringFormatting</a></p>

<ul>
<li><em>scalar</em>: single item</li>
<li><em>array</em>: one-dimensional array of items</li>
<li><em>matrix</em>: two-dimensional array of items</li>
<li><em>anydim</em>: any of <em>scalar</em>, <em>array</em>, <em>matrix</em></li>
</ul>

<p>Where an <em>array</em> is passed in, it may be passed either as an assumed-shape array; that is, as an F90-style array with no necessity for specifying bounds; thusly:</p>

<pre><code>integer :: array(50)
call cmlAddProperty(xf, 'coords', array)
</code></pre>

<p>or as an assumed-size array; that is, an F77-style array, in which case the length must be passed as an additional parameter:</p>

<pre><code>integer :: array(*)
call cmlAddProperty(xf, 'coords', array, nitems=50)
</code></pre>

<p>Similarly, when a <em>matrix</em> is passed in, it may be passed in both fashions:</p>

<pre><code>integer :: matrix(50, 50)
call cmlAddProperty(xf, 'coords', matrix)
</code></pre>

<p>or </p>

<pre><code>integer :: array(3, *)
call cmlAddProperty(xf, 'coords', matrix, nrows=3, ncols=50)
</code></pre>

<p>All functions take as their first argument an XML file object, whose keyword is always <code>xf</code>. This file object is initialized by a cmlBegin function.</p>

<p>It is <em>highly</em> recommended that subroutines be called with keywords specified rather than relying on the implicit ordering of arguments. This is robust against changes in the library calling convention; and also stepsides a significant cause of errors when using subroutines with large numbers of arguments.</p>

<h2>Functions for manipulating the CML file:</h2>

<ul>
<li><code>cmlBeginFile</code> <br />
<strong>filename</strong>: <em>string</em> <em>scalar</em>: Filename to be opened.</li>
</ul>

<p>This takes care of all calls to open a CML output file.</p>

<ul>
<li><code>cmlFinishFile</code></li>
</ul>

<p>This takes care of all calls to close an open CML output file, once you have finished with it. It is compulsory to call this - if your program finished without calling this, then your CML file will be invalid.</p>

<ul>
<li><code>cmlAddNamespace</code> <br />
<strong>prefix</strong> <em>string</em> <em>scalar</em>: prefix to be used
<strong>nsURI</strong> <em>string</em> <em>scalar</em>: namespace URI to be used</li>
</ul>

<p>This adds a namespace to a CML file. <br />
NB This may only ever be called immediately after a <code>cmlBeginCml</code> call, before any
output has been performed.
Attempts to do otherwise will result in a runtime error.</p>

<p>This will be needed if you are adding dictionary references to your output. Thus for siesta, we do:</p>

<pre><code>call cmlAddNamespace(xf, 'siesta', 'http://www.uam.es/siesta')
</code></pre>

<p>and then output all our properties and parameters with <code>dictRef="siesta:something"</code>.</p>

<ul>
<li><p><code>cmlStartCml</code> <br />
(<strong>fileId</strong>) <em>string</em> <em>scalar</em>: name of originating file. <br />
(<strong>version</strong>) <em>string</em> <em>scalar</em>: version of CML in use.  </p></li>
<li><p><code>cmlEndCml</code></p></li>
</ul>

<p>This pair of functions begin and end the CML output to an existing CML file. It takes care of namespaces.</p>

<p>Note that unless specified otherwise, there will be a <code>convention</code> attribute added to the <code>cml</code> tag specifying <code>FoX_wcml-2.0</code> as the convention. (see <a href="http://www.uszla.me.uk/FoX">http://www.uszla.me.uk/FoX</a> for details)</p>

<h5>Start/End sections</h5>

<ul>
<li><p><code>cmlStartMetadataList</code> <br />
(<strong>name</strong>) <em>string</em> <em>scalar</em>: name for the metadata list <br />
(<strong>role</strong>) <em>string</em> <em>scalar</em> role which the element plays </p></li>
<li><p><code>cmlEndMetadataList</code></p></li>
</ul>

<p>This pair of functions open &amp; close a metadataList, which is a wrapper for metadata items.</p>

<ul>
<li><p><code>cmlStartParameterList</code> <br />
(<strong>ref</strong>) <em>string</em> <em>scalar</em>: Reference an <code>id</code> attribute of another element (generally deprecated) <br />
(<strong>role</strong>) <em>string</em> <em>scalar</em> role which the element plays </p></li>
<li><p><code>cmlEndParameterList</code></p></li>
</ul>

<p>This pair of functions open &amp; close a parameterList, which is a wrapper for input parameters.</p>

<ul>
<li><p><code>cmlStartPropertyList</code> <br />
(<strong>ref</strong>) <em>string</em> <em>scalar</em>: Reference an <code>id</code> attribute of another element (generally deprecated) <br />
(<strong>role</strong>) <em>string</em> <em>scalar</em> role which the element plays </p></li>
<li><p><code>cmlEndPropertyList</code></p></li>
</ul>

<p>This pair of functions open &amp; close a propertyList, which is a wrapper for output properties.</p>

<ul>
<li><code>cmlStartModule</code> <br />
(<strong>serial</strong>) <em>string</em> <em>scalar</em>: serial id for the module <br />
(<strong>role</strong>) <em>string</em> <em>scalar</em> role which the element plays </li>
</ul>

<p>Note that in most cases where you might want to use a serial number, you should probably be using the <code>cmlStartStep</code> subroutine below.</p>

<ul>
<li><code>cmlEndModule</code></li>
</ul>

<p>This pair of functions open &amp; close a module of a computation which is unordered, or loosely-ordered. For example, METADISE uses one module for each surface examined.</p>

<ul>
<li><p><code>cmlStartStep</code> <br />
(<strong>index</strong>) <em>integer</em> <em>scalar</em>: index number for the step. In the absence of an index, steps will be assumed to be consecutively numbered. Specifying this is useful if you wish to output <em>eg</em> every hundredth step. <br />
(<strong>type</strong>) <em>string</em> <em>scalar</em>: what sort of step is this? This should be a namespaced string, for example: <code>siesta:CG</code> is a Conjugate Gradient step in siesta.</p></li>
<li><p><code>cmlEndStep</code></p></li>
</ul>

<p>This pair of functions open and close a module of a computation which is strongly ordered. For example, DLPOLY uses steps for each step of the simulation.</p>

<h5>Adding items.</h5>

<ul>
<li><code>cmlAddMetadata</code></li>
</ul>

<p>This adds a single item of metadata. It takes the following arguments:</p>

<p><strong>name</strong>: <em>string</em> <em>scalar</em>: Identifying string for metadata <br />
<strong>content</strong>: <em>anytype</em> <em>scalar</em>: Content of metadata  </p>

<ul>
<li><code>cmlAddParameter</code></li>
</ul>

<p>This function adds a tag representing an input parameter</p>

<p><strong>title</strong>: <em>string</em> <em>scalar</em>: Identifying title for parameter <br />
<strong>value</strong>:<em>anytype</em> <em>anydim</em>: value of parameter <br />
<strong>units</strong>: <em>string</em> <em>scalar</em>: units of parameter value <br />
<strong>cons</strong> FIXME</p>

<ul>
<li><code>cmlAddProperty</code></li>
</ul>

<p>This function adds a tag representing an output property</p>

<p><strong>name</strong>: <em>string</em> <em>scalar</em> <br />
<strong>property</strong>: <em>any</em> <em>anydim</em> <br />
<strong>units</strong>: <em>string</em> <em>scalar</em> units of property value  </p>

<ul>
<li><code>cmlAddMolecule</code></li>
</ul>

<p>Outputs an atomic configuration.</p>

<p><strong>coords</strong>: <em>real</em>: a 3xn matrix of real numbers representing atomic coordinates (either fractional or Cartesian) <br />
<strong>elems</strong>: <em>string</em> <em>array</em>: a length-n array of length-2 strings containing IUPAC chemical symbols for the atoms <br />
(<strong>refs</strong>): <em>string</em> <em>array</em>: a length-n array of strings containing references which may point to IDs elsewhere of, for example, pseudopotentials or basis sets defining the element's behaviour. <br />
(<strong>style</strong>): <em>string</em> <em>scalar</em>: 'xyz3' - the coordinates are Cartesian, or <code>xyzFract</code> - the coordinates are fractional. The default is Cartesian.  </p>

<ul>
<li><code>cmlAddLattice</code> </li>
</ul>

<p>Outputs information about a unit cell, in lattice-vector form</p>

<p><strong>cell</strong>: <em>real</em> <em>matrix</em> a 3x3 matrix of the unit cell <br />
<strong>spaceType</strong>: 'real' or 'reciprocal' space. <br />
(<strong>latticeType)</strong>: Space group of the lattice; 
default - none <br />
(<strong>units</strong>): units of (reciprocal) distance that cell vectors is given in; 
default - none</p>

<ul>
<li><code>cmlAddCrystal</code></li>
</ul>

<p>Outputs information about a unit cell, in crystallographic form</p>

<p><strong>a</strong>: <em>real</em> <em>scalar</em> the 'a' parameter (must be in Angstrom) <br />
<strong>b</strong>: <em>real</em> <em>scalar</em> the 'b' parameter <br />
<strong>c</strong>: <em>real</em> <em>scalar</em> the 'c' parameter <br />
<strong>alpha</strong>: <em>real</em> <em>scalar</em> the 'alpha' parameter <br />
<strong>beta</strong>: <em>real</em> <em>scalar</em> the 'beta' parameter <br />
<strong>gamma</strong>: <em>real</em> <em>scalar</em> the 'gamma' parameter <br />
(<strong>lenunits</strong>): Units of length: default is <code>cmlUnits:angstrom</code>
(<strong>angunits</strong>): Units of angle: default is <code>cmlUnits:degrees</code></p>

<h4>Common arguments</h4>

<p>All <code>cmlAdd</code> and <code>cmlStart</code> routines take the following set of optional arguments:</p>

<ul>
<li><code>id</code>: Unique identifying string for element. (Uniqueness is not enforce, though duplicated ids on output are usually an error and may cause later problems)  </li>
<li><code>title</code>: Human-readable title of element for display purposes  </li>
<li><code>dictRef</code>: reference to disambiguate element. Should be a QName; a namespaced string. An actual dictionary entry may or may not exist. It is not an error for it not to.  </li>
<li><code>convention</code>: convention by which the element is to be read.  </li>
</ul>

<p>(The wording of the definitions for <code>convention</code> is deliberately loose.)</p>
</div>
</body>
</html>
