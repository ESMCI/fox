<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>FoX_dom</title>
  <link rel="stylesheet" type="text/css" href="DoX.css"/>
</head>
<body>
  <div class="DoX">
<h1>DOM</h1>

<h2>Overview</h2>

<p>The FoX DOM interface exposes an API as specified by the W3C DOM Working group.</p>

<p>FoX implements essentially all of DOM Core Levels 1 and 2. (There are a number of minor exceptions which are listed below) and a substantial portion of DOM Core Level 3.</p>

<ul>
<li><a href="#DomQuickOverview">Quick overview of how to map the DOM interface to Fortran</a></li>
<li><a href="#DomDetailedInterface">More detailed explanation of Fortran interface:</a></li>
<li><a href="#DomUtilityFunctions">Additional (non-DOM) utility functions</a></li>
<li><a href="#DomString">String handling</a></li>
<li><a href="#DomException">Exception handling</a></li>
<li><a href="#DomLiveNodelists">Live nodelists</a></li>
<li><a href="#DomConfiguration">DOM Configuration</a></li>
<li><a href="#DomMiscellanea">Miscellanea</a></li>
</ul>

<h2>Interface Mapping</h2>

<p><a name="DomQuickOverview"/></p>

<p>FoX implements all objects and methods mandated in DOM Core Level 1 and 2. (A listing of supported DOM Core Level 3 interfaces is given below.)</p>

<p>In all cases, the mapping from DOM interface to Fortran implementation is as follows:</p>

<ol>
<li><p>All DOM objects are available as Fortran types, and should be referenced only as pointers (though see 7 and 8 below). Thus, to use a Node, it must be declared first as: <br />
<code>type(Node), pointer :: aNode</code></p></li>
<li><p>A flat (non-inheriting) object hierarchy is used. All DOM objects which inherit from Node are represented as Node types.</p></li>
<li><p>All object method calls are modelled as functions or subroutines with the same name, whose first argument is the object. Thus: <br />
<code>aNodelist = aNode.getElementsByTagName(tagName)</code> <br />
should be converted to Fortran as: <br />
<code>aNodelist =&gt; getElementsByTagName(aNode, tagName)</code></p></li>
<li><p>All object method calls whose return type is void are modelled as subroutines. Thus: <br />
<code>aNode.normalize()</code> <br />
becomes <br />
<code>call normalize(aNode)</code></p></li>
<li><p>All object attributes are modelled as a pair of get/set calls (or only get where the attribute is readonly), with the naming convention being merely to prepend get or set to the attribute name. Thus: <br />
<code>name = node.nodeName</code> <br />
<code>node.nodeValue = string</code> <br />
should be converted to Fortran as <br />
<code>name = getnodeName(node)</code> <br />
<code>call setnodeValue(string)</code></p></li>
<li><p>Where an object method or attribute getter returns a DOM object, the relevant Fortran function must always be used as a pointer function. Thus: <br />
<code>aNodelist =&gt; getElementsByTagName(aNode, tagName)</code></p></li>
<li><p>No special DOMString object is used - all string operations are done on the standard Fortran character strings, and all functions that return DOMStrings return Fortran character strings</p></li>
<li><p>Exceptions are modelled by every DOM subroutine/function allowing an optional additional argument, of type DOMException. For further information see <a href="DomExceptions.html">DOM Exceptions</a> below.</p></li>
</ol>

<h3>String handling</h3>

<p><a name="DomString"/></p>

<p>The W3C DOM requires that a <code>DOMString</code> object exist, capable of holding Unicode strings; and that all DOM functions accept and emit DOMString objects when string data is to be transferred.</p>

<p>FoX does not follow this model. Since (as mentioned elsewhere) it is impossible to perform Unicode I/O in standard Fortran, it would be obtuse to require users to manipulate additional objects merely to transfer strings. Therefore, wherever the DOM mandates use of a <code>DOMString</code>, FoX merely uses standard Fortran character strings.</p>

<p>All functions or subroutines which expect DOMString input arguments should be used with normal character strings. <br />
All functions which should return DOMString objects will return Fortran character strings.</p>

<h3>Using the FoX DOM library.</h3>

<p>All functions are exposed through the module <code>FoX_DOM</code>. <code>USE</code> this in your program:</p>

<pre><code>program dom_example

   use FoX_DOM
   type(Node) :: myDoc

   myDoc =&gt; parseFile("fileIn.xml")
   call serialize(myDoc, "fileOut.xml")
 end program dom_example
</code></pre>

<h2>Documenting DOM functions</h2>

<p><a name="DomDetailedInterface"/></p>

<p>This manual will not exhaustively document the functions available through the <code>Fox_DOM</code> interface. Primary documentation may be found in the W3C DOM specifications:</p>

<ul>
<li><a href="http://www.w3.org/TR/REC-DOM-Level-1/">DOM Core Level 1</a>  </li>
<li><a href="http://www.w3.org/TR/DOM-Level-2-Core/">DOM Core Level 2</a></li>
<li><a href="http://www.w3.org/TR/DOM-Level-3-Core/">DOM Core Level 3</a></li>
</ul>

<p>The systematic rules for translating the DOM interfaces to Fortran are given in the previous section. For completeness, though, there is a list here. The W3C specifications should be consulted for the use of each.</p>

<p>DOMImplementation: <br />
<code>type(DOMImplementation), pointer</code>  </p>

<ul>
<li><code>hasFeature(impl, feature, version)</code></li>
<li><code>createDocumentType(impl, qualifiedName, publicId, systemId)</code></li>
<li><code>createDocument(impl, qualifiedName, publicId, systemId)</code></li>
</ul>

<p>Document: <br />
<code>type(Node), pointer</code></p>

<ul>
<li><code>getDocType(doc)</code>  </li>
<li><code>getImplementation(doc)</code>  </li>
<li><code>getDocumentElement(doc)</code>  </li>
<li><code>createElement(doc, tagname)</code>  </li>
<li><code>createDocumentFragment(doc)</code>  </li>
<li><code>createTextNode(doc, data)</code>  </li>
<li><code>createComment(doc, data)</code>  </li>
<li><code>createCDataSection(doc, data)</code>  </li>
<li><code>createProcessingInstruction(doc, target, data)</code>  </li>
<li><code>createAttribute(doc, name)</code>  </li>
<li><code>createEntityReference(doc, name)</code>  </li>
<li><code>getElementsByTagName(doc, tagname)</code>  </li>
<li><code>importNode(doc, importedNode, deep)</code>  </li>
<li><code>createElementNS(doc, namespaceURI, qualifiedName)</code>  </li>
<li><code>createAttributeNS(doc, namespaceURI, qualifiedName)</code>  </li>
<li><code>getElementsByTagNameNS(doc, namespaceURI, qualifiedName)</code>  </li>
<li><code>getElementById(doc, elementId)</code></li>
</ul>

<p>Node: <br />
<code>type(Node), pointer</code></p>

<ul>
<li><code>getNodeName(arg)</code>  </li>
<li><code>getNodeValue(arg)</code>  </li>
<li><code>setNodeValue(arg, value)</code>  </li>
<li><code>getNodeType(arg)</code>  </li>
<li><code>getParentNode(arg)</code>  </li>
<li><code>getChildNodes(arg)</code>  </li>
<li><code>getFirstChild(arg)</code>  </li>
<li><code>getLastChild(arg)</code>  </li>
<li><code>getPreviousSibling(arg)</code>  </li>
<li><code>getNextSibling(arg)</code>  </li>
<li><code>getAttributes(arg)</code>  </li>
<li><code>getOwnerDocument(arg)</code>  </li>
<li><code>insertBefore(arg, newChild, refChild)</code>  </li>
<li><code>replaceChild(arg, newChild, refChild)</code>  </li>
<li><code>removeChild(arg, oldChild)</code>  </li>
<li><code>appendChild(arg, newChild)</code>  </li>
<li><code>hasChildNodes(arg)</code></li>
<li><code>cloneNode(arg, deep)</code></li>
<li><code>normalize</code>  </li>
<li><code>isSupported(arg, feature, version)</code>  </li>
<li><code>getNamespaceURI(arg)</code>  </li>
<li><code>getPrefix(arg)</code>  </li>
<li><code>setPrefix(arg, prefix)</code></li>
<li><code>getLocalName(arg)</code>  </li>
<li><code>hasAttributes(arg)</code>  </li>
</ul>

<p>NodeList: <br />
<code>type(NodeList), pointer</code></p>

<ul>
<li><code>item(arg, index)</code>  </li>
<li><code>getLength(arg)</code>  </li>
</ul>

<p>NamedNodeMap: <br />
<code>type(NamedNodeMap), pointer</code>  </p>

<ul>
<li><code>getNamedItem(map, name)</code>  </li>
<li><code>setNamedItem(map, arg)</code>  </li>
<li><code>removeNamedItem(map, name)</code>  </li>
<li><code>item(map, index)</code>  </li>
<li><code>getLength(map)</code>  </li>
<li><code>getNamedItemNS(map, namespaceURI, qualifiedName)</code>  </li>
<li><code>setNamedItemNS(map, arg)</code>  </li>
<li><code>removeNamedItemNS(map, namespaceURI, qualifiedName)</code>  </li>
</ul>

<p>CharacterData: <br />
<code>type(Node), pointer</code> </p>

<ul>
<li><code>getData(np)</code>  </li>
<li><code>setData(np, data)</code>  </li>
<li><code>getLength(np)</code>  </li>
<li><code>substringData(np, offset, count)</code>  </li>
<li><code>appendData(np, arg)</code>  </li>
<li><code>deleteData(np, offset, count)</code>  </li>
<li><code>replaceData(np, offset, count, arg)</code></li>
</ul>

<p>Attr: <br />
<code>type(Node), pointer</code></p>

<ul>
<li><code>getName(np)</code>  </li>
<li><code>getSpecified(np)</code>  </li>
<li><code>getValue(np)</code>  </li>
<li><code>setValue(np, value)</code>  </li>
<li><code>getOwnerElement(np)</code> </li>
</ul>

<p>Element: <br />
<code>type(Node), pointer</code></p>

<ul>
<li><code>getTagName(np)</code>  </li>
<li><code>getAttribute(np, name)</code>  </li>
<li><code>setAttribute(np, name, value)</code>  </li>
<li><code>removeAttribute(np, name)</code>  </li>
<li><code>getAttributeNode(np, name)</code>  </li>
<li><code>setAttributeNode(np, newAttr)</code>  </li>
<li><code>removeAttributeNode(np, oldAttr)</code>  </li>
<li><code>getElementsByTagName(np, name)</code></li>
<li><code>getAttributeNS(np, namespaceURI, qualifiedName)</code>  </li>
<li><code>setAttributeNS(np, namespaceURI, qualifiedName, value)</code>  </li>
<li><code>removeAttributeNS(np, namespaceURI, qualifiedName)</code>  </li>
<li><code>getAttributeNode(np, namespaceURI, qualifiedName)</code>  </li>
<li><code>setAttributeNode(np, newAttr)</code>  </li>
<li><code>removeAttributeNode(np, oldAttr)</code>  </li>
<li><code>getElementsByTagNameNS(np, namespaceURI, qualifiedName)</code>  </li>
<li><code>hasAttribute(np, name)</code>  </li>
<li><code>hasAttributeNS(np, namespaceURI, qualifiedName)</code></li>
</ul>

<p>Text: <br />
<code>type(Node), pointer</code></p>

<ul>
<li><code>splitText(np, offset)</code>  </li>
</ul>

<p>DocumentType: <br />
<code>type(Node), pointer</code></p>

<ul>
<li><code>getName(np)</code>  </li>
<li><code>getEntites(np)</code>  </li>
<li><code>getNotations(np)</code>  </li>
<li><code>getPublicId(np)</code>  </li>
<li><code>getSystemId(np)</code>  </li>
<li><code>getInternalSubset(np)</code>  </li>
</ul>

<p>Notation: <br />
<code>type(Node), pointer</code></p>

<ul>
<li><code>getPublicId(np)</code>  </li>
<li><code>getSystemId(np)</code>  </li>
</ul>

<p>Entity: <br />
<code>type(Node), pointer</code></p>

<ul>
<li><code>getPublicId(np)</code>  </li>
<li><code>getSystemId(np)</code>   </li>
<li><code>getNotationName(np)</code>  </li>
</ul>

<p>ProcessingInstruction: <br />
<code>type(Node), pointer</code></p>

<ul>
<li><code>getTarget(np)</code>  </li>
<li><code>getData(np)</code>  </li>
<li><code>setData(np, data)</code>  </li>
</ul>

<p>In addition, the following DOM Core Level 3 functions are available:</p>

<p>Document: <br />
* <code>getInputEncoding(np)</code> <br />
* <code>getXmlEncoding(np)</code> <br />
* <code>getXmlStandalone(np)</code> <br />
* <code>setXmlStandalone(np, xmlStandalone)</code> <br />
* <code>getXmlVersion(np)</code> <br />
* <code>setXmlVersion(np, xmlVersion)</code> <br />
* <code>getStrictErrorChecking(np)</code> <br />
* <code>setStrictErrorChecking(np, strictErrorChecking)</code> <br />
* <code>adoptNode(np, source)</code> <br />
* <code>renameNode(np, n, namespaceURI, qualifiedName)</code>  </p>

<p>Attr: <br />
* <code>getIsId(np)</code>  </p>

<p>Element: <br />
* <code>setIdAttribute(np, name, isId)</code> <br />
* <code>setIdAttributeNS(np, namespaceURI, qualifiedName, isId)</code> <br />
* <code>setIdAttributeNode(np, idAttr, isId)</code>  </p>

<p>Text: <br />
* <code>getIsElementContentWhitespace(np)</code> <br />
* <code>getWholeText(np)</code> <br />
* <code>replaceWholeText(np)</code>  </p>

<p>Entity: <br />
* <code>getInputEncoding(np)</code> <br />
* <code>getXmlEncoding(np)</code> <br />
* <code>getXmlVersion(np)</code>  </p>

<h3>Object model</h3>

<p>The DOM is written in terms of an object model involving inheritance, but also permits a flattened model. FoX implements this flattened model - all objects descending from the Node are of the opaque type <code>Node</code>. Nodes carry their own type, and attempts to call functions defined on the wrong nodetype (for example, getting the <code>target</code> of a node which is not a PI) will result in a <code>FoX_INVALID_NODE</code> exception.</p>

<p>The other types available through the FoX DOM are:</p>

<ul>
<li><code>DOMException</code>  </li>
<li><code>DOMImplementation</code>  </li>
<li><code>NodeList</code>  </li>
<li><code>NamedNodeMap</code>  </li>
</ul>

<h3>FoX DOM and pointers</h3>

<p>All DOM objects exposed to the user may only be manipulated through pointers. Attempts to access them directly will reulst in either compile-time or run-time failures according to your environment.</p>

<p>This should have little effect on your programs, except that you must always remember, when calling a DOM function, to perform pointer assignment, not direct assignment, thus:</p>

<pre><code>child =&gt; getFirstChild(parent)
</code></pre>

<p>and <em>not</em></p>

<pre><code>child = getFirstChild(parent)
</code></pre>

<h3>Memory handling</h3>

<p>Fortran offers no garbage collection facility, so unfortunately a small degree of memory
handling is necessarily exposed to the user.</p>

<p>However, this has been kept to a minimum. FoX keeps track of all memory allocated and used when calling DOM routines, and keeps references to all DOM objects created.</p>

<p>The only memory handling that the user needs to take care of is destroying any
DOM Documents (whether created manually, or by the parse() routine. All other nodes or node structures created will be destroyed automatically by the relevant destroyDocument() call.</p>

<p>As a consequence of this, all DOM objects which are part of a given document will become inaccessible after the document object is destroyed.</p>

<h2>Additional functions.</h2>

<p><a name="DomUtilityFunctions"/></p>

<p>Several additional utility functions are provided by FoX.</p>

<p>Firstly, to construct a DOM tree, from either a file or a string containing XML data.</p>

<ul>
<li><code>parseFile</code> <br />
<strong>filename</strong>: <em>string</em> <br />
(<strong>configuration</strong>): <em>string</em> <br />
(<strong>ex</strong>): <em>DOMException</em>  </li>
</ul>

<p><strong>filename</strong> should be an XML document. It will be opened and parsed into a DOM tree. The parsing is performed by the FoX SAX parser; if the XML document is not well-formed, a <code>PARSE_ERR</code> exception will be raised. <strong>configuration</strong> is an optional argument - see (DomConfiguration.html for its meaning.</p>

<ul>
<li><code>parseString</code>
<strong>XMLstring</strong>: <em>string</em> <br />
(<strong>configuration</strong>): <em>string</em> <br />
(<strong>ex</strong>): <em>DOMException</em>  </li>
</ul>

<p><strong>XMLstring</strong> should be a string containing XML data. It will be parsed into a DOM tree. The parsing is performed by the FoX SAX parser; if the XML document is not well-formed, a <code>PARSE_ERR</code> exception will be raised. <strong>configuration</strong> is an optional argument - see (DomConfiguration.html for its meaning.</p>

<p>Both <code>parseFile</code> and <code>parseString</code> return a pointer to a <code>Node</code> object containing the Document Node.</p>

<p>Secondly, to output an XML document:</p>

<ul>
<li><code>serialize</code>
<strong>arg</strong>: <em>Node, pointer</em>
<strong>fileName</strong>: <em>string</em></li>
</ul>

<p>This will open <code>fileName</code> and serialize the DOM tree by writing into the file. If <code>fileName</code> already exists, it will be overwritten. If an problem arises in serializing the document, then a fatal error will result. (Future versions of FoX will allow trapping this as an exception)</p>

<p>Finally, to clean up all memory associated with the DOM, it is necessary to call:</p>

<ul>
<li><code>destroyDocument</code>
<strong>np</strong>: <em>Node, pointer</em></li>
</ul>

<p>This will clear up all memory usage associated with the document node passed in.</p>

<h3>Exception handling</h3>

<p><a name="DomException"/></p>

<p>Exception handilng is important to the DOM. The W3C DOM standards provide not only interfaces to the DOM, but also specify the error handling that should take place when invalid calls are made.</p>

<p>The DOM specifies these in terms of a <code>DOMException</code> object, which carries a numeric code whose value reports the kind of error generated. Depending upon the features available in a particular computer language, this DOMException object should be generated and thrown, to be caught by the end-user application.</p>

<p>Fortran of course has no mechanism for throwing and catching exceptions. However, the behaviour of an exception can be modelled using Fortran features.</p>

<p>FoX defines an opaque <code>DOMException</code> object.
Every DOM subroutine and function implemented by FoX will take an optional argument, 'ex', of type <code>DOMException</code>. </p>

<p>If the optional argument is not supplied, any errors within the DOM will cause an immediate abort, with a suitable error message. However, if the optional argument <em>is</em> supplied, then the error will be captured within the <code>DOMException</code> object, and returned to the caller for inspection. It is then up to the application to decide how to proceed.</p>

<p>Functions for inspecting and manipulating the <code>DOMException</code> object are described below:</p>

<ul>
<li><code>inException</code>: <br />
<strong>ex</strong>: <em>DOMException</em></li>
</ul>

<p>A function returning a logical value, according to whether <code>ex</code> is in exception - that is, whether the last DOM function or subroutine, from which <code>ex</code> returned, caused an error. Note that this will not change the status of the exception.</p>

<ul>
<li><code>getExceptionCode</code> <br />
<em>* ex</em><em>: *DOMException</em></li>
</ul>

<p>A function returning an integer value, describing the nature of the exception reported in <code>ex</code>. If the integer is 0, then <code>ex</code> does not hold an exception. If the integer is less than 200, then the error encountered was of a type specified by the DOM standard; for a full list, see below, and for explanations, see the various DOM standards. If the integer is 200 or greater, then the code represents a FoX-specific error. See the list below.</p>

<p>Note that calling <code>getExceptionCode</code> will clean up all memory associated with the DOMException object, and reset the object such that it is no longer in exception.</p>

<h4>Exception handling and memory usage.</h4>

<p>Note that when an Exception is thrown, memory is allocated within the DOMException object. Calling <code>getExceptionCode</code> on a DOMEXception will clean up this memory. If you use the exception-handling interfaces of FoX, then you must check every exception, and ensure you check its code, otherwise your program will leak memory.</p>

<h4>FoX exceptions.</h4>

<p>The W3C DOM interface allows the creation of unserializable XML document in various ways. For example, it permits characters to be added to a text node which would be invalid XML. FoX performs multiple additional checks on all DOM calls to prevent the creation of unserializable trees. These are reported hthrough the DOMException mechanisms noted above. However, if for some reason, you want to create such trees, then it is possible to switch off all FoX-only checks. (DOM-mandated checks may not be disabled.) To do this, use the <code>setFoXChecks</code> function described in (DomUtilityFunctions.html)</p>

<p>FoX does not currently check for all ways that a tree may be made non-serializable. In particular, it is possible to create non-serializable DOM trees in the following ways.</p>

<ul>
<li><code>setXMLVersion</code> (DOM 3 only) <br />
When changing the XML version, no checking is made that on the charset of all the document nodes, nor of any XML names, to ensure that they are compliant with the standard. Since FoX does not support Unicode, the only relevant incompatibilities between XML 1.0 and 1.1 are in having characters BLAH in text sections, which is permitted in XML 1.0 but not 1.1.</li>
</ul>

<h4>DOM Error codes</h4>

<pre><code>INDEX_SIZE_ERR                 = 1;
DOMSTRING_SIZE_ERR             = 2;
HIERARCHY_REQUEST_ERR          = 3;
WRONG_DOCUMENT_ERR             = 4;
INVALID_CHARACTER_ERR          = 5;
NO_DATA_ALLOWED_ERR            = 6;
NO_MODIFICATION_ALLOWED_ERR    = 7;
NOT_FOUND_ERR                  = 8;
NOT_SUPPORTED_ERR              = 9;
INUSE_ATTRIBUTE_ERR            = 10;
INVALID_STATE_ERR              = 11; // Introduced in DOM Level 2;
SYNTAX_ERR                     = 12; // Introduced in DOM Level 2;
INVALID_MODIFICATION_ERR       = 13; // Introduced in DOM Level 2;
NAMESPACE_ERR                  = 14; // Introduced in DOM Level 2;
INVALID_ACCESS_ERR             = 15; // Introduced in DOM Level 2;
VALIDATION_ERR                 = 16; // Introduced in DOM Level 3;
TYPE_MISMATCH_ERR              = 17; // Introduced in DOM Level 3;
INVALID_EXPRESSION_ERR         = 51; // Introduced in DOM Level 3 XPath;
TYPE_ERR                       = 52; // Introduced in DOM Level 3 XPath;
PARSE_ERR                      = 81; // Introduced in DOM Level 3 Load and Save;
SERIALIZE_ERR                  = 82; // Introduced in DOM Level 3 Load and Save;
</code></pre>

<h4>FoX Error codes</h4>

<pre><code> FoX_INVALID_CHARACTER       = 200   // attempt to insert characters invalid under the current XML version
 FoX_INVALID_NODE            = 201   // attempt to use a node not according to its nodetype
 FoX_INVALID_XML_NAME        = 202   // attempt to create a name which is not a valid XML name according to current XML version
 FoX_INVALID_PI_TARGET       = 203   // attempt to create an invalid PI target
 FoX_INVALID_PI_DATA         = 204   // attempt to create invalid PI data
 FoX_INVALID_CDATA_SECTION   = 205   // attempt to create an invalid CData section
 FoX_INVALID_TEXT            = 206   // attempt to create invalid text
 FoX_INVALID_PUBLIC_ID       = 207   // attempt to create an invalid PUBLIC id
 FoX_INVALID_SYSTEM_ID       = 208   // attempt to create an invalid SYSTEM ID
 FoX_INVALID_COMMENT         = 209   // attempt to create an invalid comment
 FoX_NODE_IS_NULL            = 210   // attempt to manipulate a Node pointer which is null
 FoX_INVALID_ENTITY          = 211   // attempt to reference an Entity whose contents is not well-formed
 FoX_NO_DOCTYPE              = 212   // attempt to reference a doctype in a document without one.
 FoX_IMPL_IS_NULL            = 213   // attempt to manipulate a DOMImplementation pointer which is null
 FoX_MAP_IS_NULL             = 214   // attempt to manipulate a NamedNodeMap which is null
</code></pre>

<h3>Live nodelists</h3>

<p><a name="DomLiveNodelists"/></p>

<p>The DOM specification requires that all NodeList objects are <em>live</em> - that is, that any change in the document structure is immediately reflected in the contents of any nodelists.</p>

<p>For example, any nodelists returned by getElementsByTagName or getElementsByTagNameNS must be updated whenever nodes are added to or removed from the document; and the order of nodes in the nodelists must be changed if the document structure changes.</p>

<p>Though FoX does keep all nodelists live, this can impose a significant performance penalty when manipulating large documents. Therefore, FoX can be instructed to inly use 'dead' nodelists - that is, nodelists which reflect a snapshot of the document structure at the point they were created. To do this, call <code>setLiveNodeLists</code> (see API documentation).</p>

<p>However, note that the nodes within the nodelist remain live - any changes made to the nodes will be reflected in accessing them through the nodelist.</p>

<p>Furthermore, since the nodelists are still associated with the document, they and their contents will be rendered inaccessible when the document is destroyed.</p>

<h2>DOM Configuration</h2>

<p><a name="DomConfiguration"/></p>

<p>Multiple valid DOM trees may be produced from a single document. When parsing input, some of these choices are made availablae to the user.</p>

<p>By default, the DOM tree presented to the user will be canonical (according to BLAH). That is: <br />
* there will be no adjacent text nodes <br />
* no Cdata nodes will appear in the DOM tree (they will be represented as Text nodes, and subsumed into neighbouring text nodes) <br />
* no EntityReference nodes will appear in the DOM tree (they will be fully expanded and their contents appear in the tree), except where the contents of the entity reference are unknown to the parser.</p>

<p>However, if a non-canonical tree is desired, the user may change this. The mechanism for doing this is the optional <code>configuration</code> argument to <code>parseFile</code> and <code>parseString</code>. <code>configuration</code> should be a space-separated list of options which affect the DOM tree. Currently, the following options are available:</p>

<ul>
<li><code>cdata</code>: If this is specified, the parse tree will preserve any CData sections from the original document.</li>
<li><code>entities</code>: If this is specified, the parse tree will preserve entity reference nodes (their contents are made available as children of the entity reference node.)</li>
</ul>

<h3>External entities</h3>

<p>The FoX SAX processor does not read external entities,  therefore these will not be made available through the DOM interface, nor will the document represented be affected by any declarations made in referenced external entities (thus, for example, any externally-declared default attributes will not be made available.)</p>

<h2>DOM Miscellanea</h2>

<p><a name="DomMiscellanea"/></p>

<p>Other issues</p>

<ul>
<li><p>As mentioned in the documentation for WXML, it is impossible within Fortran to reliably output lines longer than 1024 characters. While text nodes containing such lines may be created in the DOM, on serialization newlines will be inserted as described in the documentation for WXML.</p></li>
<li><p>All caveats with regard to the FoX SAX processor apply to reading documents through the DOM interface. In particular, note that documents containing characters beyond the US-ASCII set will not be readable.</p></li>
</ul>

<p>It was decided to implement W3C DOM interfaces primarily because they are specified in a language-agnostic fashion, and thus made Fortran implementation possible. A number of criticisms have been levelled at the W3C DOM (...), but may apply only from the perspective of Java developers. However, also, the W3c DOM suffers from a lack of sufficient rror checking so it is very easy to create a DOM tree, or manipulate an existing DOM treeinto a state, that cannot be serialized into a legal XML document.</p>

<p>Therefore, FoX will by default produce errors about any attempts to manipulate the DOM in such a way as would result in invalid XML. These errors can be switched off if standards-compliant behaviour is wanted. Although extensive, there are a some areas where the nature of the DOM API makes complete checking impractical. These are noted below.</p>

<p>Due to the nature of Fortran, there are a few other areas where the FoX implementation differs from the W3C DOM. These are largely unimportant, but are noted in ...</p>
</div>
</body>
</html>
