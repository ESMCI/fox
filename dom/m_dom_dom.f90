
 
 
 ! ATTENTION
! THIS FILE IS AUTOGENERATED
! DO NOT EDIT DIRECTLY
! EDIT FILES dom/m_dom_***.m4
!
module m_dom_dom


  use m_common_array_str, only: vs_str_alloc
  use m_common_struct, only: xml_doc_state, destroy_xml_doc_state



  use m_common_array_str, only: str_vs, vs_str_alloc
  use m_dom_error, only: DOMException, throw_exception, is_in_error, &
    NO_MODIFICATION_ALLOWED_ERR, NOT_FOUND_ERR, HIERARCHY_REQUEST_ERR, &
    WRONG_DOCUMENT_ERR, FoX_INTERNAL_ERROR, FoX_NODE_IS_NULL



  use m_common_array_str, only: str_vs
  use m_dom_error, only: INUSE_ATTRIBUTE_ERR



  use m_common_array_str, only: str_vs, vs_str_alloc
  use m_common_charset, only: checkChars, XML1_0

  use m_dom_error, only: DOMException, throw_exception, is_in_error, &
    INVALID_CHARACTER_ERR, NAMESPACE_ERR, FoX_INVALID_PUBLIC_ID, FoX_INVALID_SYSTEM_ID
  use m_common_namecheck, only: checkName, checkPublicId, checkSystemId
  use m_common_string, only: toLower
  use m_common_struct, only: init_xml_doc_state, destroy_xml_doc_state



  use m_common_array_str, only: str_vs, vs_str_alloc
  use m_common_charset, only: XML1_0, XML1_1
  use m_common_namecheck, only: checkQName, prefixOfQName, localPartOfQName
  use m_dom_error, only : NOT_FOUND_ERR, INVALID_CHARACTER_ERR, FoX_INVALID_NODE, &
    FoX_INVALID_XML_NAME, WRONG_DOCUMENT_ERR, FoX_INVALID_TEXT, & 
    FoX_INVALID_CHARACTER, FoX_INVALID_COMMENT, FoX_INVALID_CDATA_SECTION, &
    FoX_INVALID_PI_DATA, NOT_SUPPORTED_ERR, FoX_INVALID_ENTITY



  use m_common_array_str, only: str_vs



  use m_common_array_str, only: str_vs, vs_str_alloc
  use m_common_namecheck, only: prefixOfQName, localpartOfQName



  use m_common_array_str, only: str_vs, vs_str_alloc



  use m_common_array_str, only: str_vs, vs_str_alloc
  use m_dom_error, only: INDEX_SIZE_ERR



  use m_common_array_str, only: str_vs



  use m_common_array_str, only: str_vs



  use m_common_array_str, only: str_vs, vs_str_alloc



  use m_common_array_str, only: str_vs, vs_str_alloc


  implicit none
  private

  integer, parameter ::     ELEMENT_NODE                   = 1
  integer, parameter ::     ATTRIBUTE_NODE                 = 2
  integer, parameter ::     TEXT_NODE                      = 3
  integer, parameter ::     CDATA_SECTION_NODE             = 4
  integer, parameter ::     ENTITY_REFERENCE_NODE          = 5
  integer, parameter ::     ENTITY_NODE                    = 6
  integer, parameter ::     PROCESSING_INSTRUCTION_NODE    = 7
  integer, parameter ::     COMMENT_NODE                   = 8
  integer, parameter ::     DOCUMENT_NODE                  = 9
  integer, parameter ::     DOCUMENT_TYPE_NODE             = 10
  integer, parameter ::     DOCUMENT_FRAGMENT_NODE         = 11
  integer, parameter ::     NOTATION_NODE                  = 12


  type DOMImplementation
    private
    character(len=7) :: id = "FoX_DOM"
  end type DOMImplementation

  type ListNode
    private
    type(Node), pointer :: this => null()
  end type ListNode 

  type NodeList
    private
    character, pointer :: nodeName(:) => null() ! What was getByTagName run on?
    character, pointer :: localName(:) => null() ! What was getByTagNameNS run on?
    character, pointer :: namespaceURI(:) => null() ! What was getByTagNameNS run on?
    type(Node), pointer :: element => null() ! which element or document was the getByTagName run from?
    type(ListNode), pointer :: nodes(:) => null()
    integer :: length = 0
  end type NodeList

  type NodeListptr
    private
    type(NodeList), pointer :: this
  end type NodeListptr

  type NamedNodeMap
    private
    logical :: readonly = .false.
    type(Node), pointer :: ownerElement => null()
    type(ListNode), pointer :: nodes(:) => null()
    integer :: length = 0
  end type NamedNodeMap

  type documentExtras
    type(DOMImplementation), pointer :: implementation => null() ! only for doctype
    type(Node), pointer :: docType => null()
    type(Node), pointer :: documentElement => null()
    character, pointer :: inputEncoding => null()
    character, pointer :: xmlEncoding => null()
    type(NodeListPtr), pointer :: nodelists(:) => null() ! document
    ! In order to keep track of all nodes not connected to the document
    logical :: liveNodeLists ! For the document, are nodelists live?
    type(NodeList) :: hangingNodes ! For the document. list of nodes not associated with doc
    type(xml_doc_state), pointer :: xds => null()
  end type documentExtras

  type ElementOrAttributeExtras
    type(NamedNodeMap) :: attributes
    character, pointer, dimension(:) :: namespaceURI => null() ! \
    character, pointer, dimension(:) :: prefix => null()       !  - only useful for element & attribute
    character, pointer, dimension(:) :: localName => null()    ! /
    logical :: specified
    type(Node), pointer :: ownerElement => null()
    logical :: isId
    type(NodeList) :: namespaceNodes
  end type ElementOrAttributeExtras

  type DTDExtras
    type(namedNodeMap) :: entities ! only for doctype
    type(namedNodeMap) :: notations ! only for doctype
    character, pointer :: publicId(:) => null() ! doctype, entity, notation 
    character, pointer :: systemId(:) => null() ! doctype, entity, notation
    character, pointer :: internalSubset(:) => null() ! doctype
    character, pointer :: notationName(:) => null() ! entity
  end type DTDExtras

  type Node
    private
    logical :: readonly = .false. ! FIXME must check this everywhere
    character, pointer, dimension(:)         :: nodeName => null()
    character, pointer, dimension(:)         :: nodeValue => null()
    integer             :: nodeType        = 0
    type(Node), pointer :: parentNode      => null()
    type(Node), pointer :: firstChild      => null()
    type(Node), pointer :: lastChild       => null()
    type(Node), pointer :: previousSibling => null()
    type(Node), pointer :: nextSibling     => null()
    type(Node), pointer :: ownerDocument   => null()
    type(NamedNodeMap) :: attributes ! only for elements
    type(NodeList) :: childNodes ! not for text, cdata, PI, comment, notation,  docType, XPath
    ! Introduced in DOM Level 2:
    character, pointer, dimension(:) :: namespaceURI => null() ! \
    character, pointer, dimension(:) :: prefix => null()       !  - only useful for element & attribute
    character, pointer, dimension(:) :: localName => null()    ! /

    logical :: specified = .true. ! only for attribute
    ! Introduced in DOM Level 2
    type(Node), pointer :: ownerElement => null() ! only for attribute
    type(namedNodeMap) :: entities ! only for doctype
    type(namedNodeMap) :: notations ! only for doctype
    ! FIXME The two above should be held in xds below
    character, pointer :: publicId(:) => null() ! doctype, entity, notation 
    character, pointer :: systemId(:) => null() ! doctype, entity, notation
    character, pointer :: internalSubset(:) => null() ! doctype
    character, pointer :: notationName(:) => null() ! entity
    ! Introduced in DOM Level 3
    character, pointer :: inputEncoding(:) => null() ! document/doctype?
    character, pointer :: xmlEncoding(:) => null()   ! document/doctype?
    ! logical :: xmlStandalone = .false.
    ! character, pointer :: xmlVersion(:) => null() 
    ! The two above are held in xds below
    logical :: strictErrorChecking = .false. ! document/doctype
    character, pointer :: documentURI(:) => null() ! document/doctype
    ! DOMCONFIGURATION

    !TYPEINFO schemaTypeInfo
    logical :: isId = .false. ! attribute
    ! In order to keep all node lists live ..

    logical :: illFormed = .false. ! entity

    logical :: inDocument = .false.! For a node, is this node associated to the doc?
!!
!!
    type(documentExtras), pointer :: docExtras
  end type Node

  type(DOMImplementation), save, target :: FoX_DOM

  interface destroy
    module procedure destroyNode, destroyNodeList, destroyNamedNodeMap
  end interface destroy

  public :: ELEMENT_NODE
  public :: ATTRIBUTE_NODE
  public :: TEXT_NODE
  public :: CDATA_SECTION_NODE
  public :: ENTITY_REFERENCE_NODE
  public :: ENTITY_NODE
  public :: PROCESSING_INSTRUCTION_NODE
  public :: COMMENT_NODE
  public :: DOCUMENT_NODE
  public :: DOCUMENT_TYPE_NODE
  public :: DOCUMENT_FRAGMENT_NODE
  public :: NOTATION_NODE

  public :: DOMImplementation
  public :: Node

  public :: ListNode
  public :: NodeList
  public :: NamedNodeMap

  public :: destroyAllNodesRecursively
  public :: setIllFormed


  
  public :: getNodeName
  public :: getNodeValue	
  public :: setNodeValue
  public :: getNodeType
  public :: getParentNode
  public :: getChildNodes
  public :: getFirstChild
  public :: getLastChild
  public :: getNextSibling
  public :: getPreviousSibling
  public :: getAttributes
  public :: getOwnerDocument
  public :: insertBefore
  public :: replaceChild
  public :: removeChild
  public :: appendChild
  public :: hasChildNodes
  public :: cloneNode  
  public :: normalize
  public :: isSupported
  public :: getNamespaceURI
  public :: getPrefix
  public :: setPrefix
  public :: getLocalName
  public :: hasAttributes
  public :: isSameNode

  public :: setStringValue
  public :: getStringValue
  public :: setReadonlyNode



  public :: item
  public :: append
  public :: pop_nl
  public :: remove_nl
  public :: destroyNodeList
  
  interface append
    module procedure append_nl
  end interface
  
  interface item
    module procedure item_nl
  end interface

  interface getLength
    module procedure getLength_nl
  end interface getLength


  public :: getNamedItem
  public :: getNamedItem_Value
  public :: getNamedItem_Value_length
  public :: setNamedItem
  public :: removeNamedItem
  public :: item
!  public :: getLength
  public :: getNamedItemNS
  public :: getNamedItemNS_Value
  public :: getNamedItemNS_Value_length
  public :: setNamedItemNS
  public :: removeNamedItemNS

  public :: append
  public :: setReadOnlyMap
  public :: destroyNamedNodeMap


  interface item
    module procedure item_nnm
  end interface

  interface getLength
    module procedure getLength_nnm
  end interface



  public :: hasFeature
  public :: createDocument
  public :: createDocumentType

  public :: destroyDocument

  public :: createEmptyDocument
  public :: createEmptyDocumentType

  public :: replace_xds



  public :: getDocType
  public :: getImplementation
  public :: getDocumentElement
  public :: setDocumentElement
  
  public :: createElement
  public :: createDocumentFragment
  public :: createTextNode
  public :: createComment
  public :: createCdataSection
  public :: createProcessingInstruction
  public :: createAttribute
  public :: createEntityReference
  public :: createEmptyEntityReference
  public :: getElementsByTagName
  public :: importNode
  public :: createElementNS
  public :: createAttributeNS
  public :: getElementsByTagNameNS
  public :: getElementById
  public :: getXmlVersion
  public :: setXmlVersion

  public :: createEntity
  public :: createNotation
  public :: setGCstate


  !public :: getName
  public :: getEntities
  public :: getNotations
!  public :: getPublicId
!  public :: getSystemId
  public :: getInternalSubset

!  Not part of documented API:
  public :: setDocType


  
  public :: getTagName
  public :: getAttribute
  public :: setAttribute
  public :: removeAttribute
  public :: getAttributeNode
  public :: setAttributeNode
  public :: removeAttributeNode
  ! public :: getElementsByTagName
  public :: getAttributeNS
  public :: setAttributeNS
  public :: removeAttributeNS
  public :: getAttributeNodeNS
  public :: setAttributeNodeNS
  public :: removeAttributeNodeNS
  public :: hasAttribute
  public :: hasAttributeNS


  !public :: getName
  public :: getSpecified
  public :: setSpecified
  interface getValue
    module procedure getValue_DOM
  end interface	 
  public :: getValue
  public :: setValue
  public :: getOwnerElement



  public :: getLength
!  public :: getData
!  public :: setData
  public :: substringData
  public :: appendData
  public :: insertData
  public :: deleteData
  public :: replaceData

  interface getLength
    module procedure getLength_characterdata
  end interface


  
  public :: getNotationName



  public :: getTarget

  
  public :: splitText


! Assorted functions with identical signatures despite belonging to different types.

  public :: getData
  public :: setData
  public :: getName
  public :: getPublicId
  public :: getSystemId


contains


  function createNode(doc, nodeType, nodeName, nodeValue, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    integer, intent(in) :: nodeType
    character(len=*), intent(in) :: nodeName
    character(len=*), intent(in) :: nodeValue
    type(Node), pointer :: np

    print*,"createNode", nodeType

    if (associated(doc)) then
      if (doc%nodeType/=DOCUMENT_NODE) then
        call throw_exception(FoX_INVALID_NODE, "createNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      endif
    elseif (nodeType/=DOCUMENT_NODE) then
      print*,"Internal error creating node"
      stop
    endif

    allocate(np)
    np%ownerDocument => doc
    np%nodeType = nodeType
    np%nodeName => vs_str_alloc(nodeName)
    np%nodeValue => vs_str_alloc(nodeValue)

    allocate(np%childNodes%nodes(0))

  end function createNode

  subroutine destroyNode(np)
    type(Node), pointer :: np

    print*,"destroyNode", np%nodeType
    if (.not.associated(np)) return

    select case(np%nodeType)
    case (ELEMENT_NODE)
      call destroyElement(np)
    case (ATTRIBUTE_NODE)
      call destroyAttribute(np)
    case (ENTITY_REFERENCE_NODE)
      ! In principle a DOM might have children here. We dont. ! FIXME we do
      call destroyNodeContents(np)
      deallocate(np)
    case (ENTITY_NODE)
      ! ?? FIXME
      call destroyNodeContents(np)
      deallocate(np)
    case (DOCUMENT_NODE)
      ! well, I dont think this should ever be called, but if it is
      ! then go to destroy_document
      !call destroyDocument(np)
    case (DOCUMENT_TYPE_NODE)
      call destroyDocumentType(np)
    case default
      call destroyNodeContents(np)
      deallocate(np)
    end select

  end subroutine destroyNode

  subroutine destroyDocumentType(dt)
    type(Node), pointer :: dt

    integer :: i

    if (dt%nodeType/=DOCUMENT_TYPE_NODE) then
       ! FIXME internal error
    endif

    print*,"DESTROYDT"
    ! Entities need to be destroyed recursively - if they are done properly ...

    if (associated(dt%entities%nodes)) then
      do i = 1, size(dt%entities%nodes)
        call destroyAllNodesRecursively(dt%entities%nodes(i)%this)
        call destroy(dt%entities%nodes(i)%this)
      enddo
      deallocate(dt%entities%nodes)
    endif
    if (associated(dt%notations%nodes)) then
      do i = 1, size(dt%notations%nodes)
        call destroy(dt%notations%nodes(i)%this)
      enddo
      deallocate(dt%notations%nodes)
    endif

    call destroyNodeContents(dt)
    deallocate(dt)

    print*,"DONEDESTROYDT"

  end subroutine destroyDocumentType

  subroutine destroyElement(element)
    type(Node), pointer :: element

    integer :: i

    if (element%nodeType /= ELEMENT_NODE) then
      ! FIXME internal error
    endif

    if (associated(element%attributes%nodes)) deallocate(element%attributes%nodes)
    call destroyNodeContents(element)
    deallocate(element)

  end subroutine destroyElement

  subroutine destroyAttribute(attr, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: attr

    type(Node), pointer :: np, np_next

    if (attr%nodeType/=ATTRIBUTE_NODE) then
      call throw_exception(FoX_INVALID_NODE, "destroyAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    call destroyNodeContents(attr)
    deallocate(attr)

  end subroutine destroyAttribute

  subroutine destroyDocumentFragment(df, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: df

    if (df%nodeType/=DOCUMENT_FRAGMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "destroyDocumentFragment", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    call destroyAllNodesRecursively(df)

    call destroyNodeContents(df)
    deallocate(df)

  end subroutine destroyDocumentFragment

  subroutine destroyAllNodesRecursively(arg)
    type(Node), pointer :: arg
    
    type(Node), pointer :: this, deadNode
    logical :: doneChildren, doneAttributes
    integer :: i

    if (.not.associated(arg)) return
    this => arg


    i = 0
    doneChildren = .false.
    doneAttributes = .false.

      deadNode => null()
    do

      if (.not.(getNodeType(this)==ELEMENT_NODE.and.doneAttributes)) then
      if (.not.doneChildren) then



      else
        if (getNodeType(this)==ELEMENT_NODE) doneAttributes = .true.



      endif
      endif


      deadNode => null()
      if (.not.doneChildren) then

        if (getNodeType(this)==ELEMENT_NODE.and..not.doneAttributes) then
          if (getLength(getAttributes(this))>0) then
                      this => item(getAttributes(this), 0)
          else
            doneAttributes = .true.
          endif
        elseif (hasChildNodes(this)) then
          this => getFirstChild(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          doneChildren = .true.
          doneAttributes = .false.
        endif

      else ! if doneChildren

        deadNode => this
        if (associated(this, arg)) exit
        if (getNodeType(this)==ATTRIBUTE_NODE) then
          if (i<getLength(getAttributes(getOwnerElement(this)))-1) then
            i = i + 1
            this => item(getAttributes(getOwnerElement(this)), i)
            doneChildren = .false.
          else
            i = 0
            this => getOwnerElement(this)
            doneAttributes = .true.
            doneChildren = .false.
          endif
        elseif (associated(getNextSibling(this))) then

          this => getNextSibling(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          this => getParentNode(this)
        endif

        call destroy(deadNode)
      endif

    enddo



    deallocate(arg%childNodes%nodes)
    allocate(arg%childNodes%nodes(0))
    arg%firstChild => null()
    arg%lastChild => null()

  end subroutine destroyAllNodesRecursively

  subroutine destroyNodeContents(np)
    type(Node), intent(inout) :: np
    
    if (associated(np%nodeName)) deallocate(np%nodeName)
    if (associated(np%nodeValue)) deallocate(np%nodeValue)
    if (associated(np%namespaceURI)) deallocate(np%namespaceURI)
    if (associated(np%prefix)) deallocate(np%prefix)
    if (associated(np%localname)) deallocate(np%localname)
    if (associated(np%publicId)) deallocate(np%publicId)
    if (associated(np%systemId)) deallocate(np%systemId)
    if (associated(np%internalSubset)) deallocate(np%internalSubset)
    if (associated(np%notationName)) deallocate(np%notationName)

    if (associated(np%inputEncoding)) deallocate(np%inputEncoding)
    if (associated(np%xmlEncoding)) deallocate(np%xmlEncoding)
    !if (associated(np%xmlVersion)) deallocate(np%xmlVersion)
    if (associated(np%documentURI)) deallocate(np%documentURI)

    deallocate(np%childNodes%nodes)

  end subroutine destroyNodeContents



  ! Getters and setters

  function getNodeName(arg, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=size(arg%nodeName)) :: c
    
    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getNodeName", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    c = str_vs(arg%nodeName)
  end function getNodeName

  pure function getNodeValue_len(arg) result(n)
    type(Node), intent(in) :: arg
    integer :: n

    integer :: i

    select case(arg%nodeType)
    case (ATTRIBUTE_NODE)
      n = 0
      do i = 1, arg%childNodes%length
        if (arg%childNodes%nodes(i)%this%nodeType == TEXT_NODE) then
          n = n + size(arg%childNodes%nodes(i)%this%nodeValue)
        else
          !FIXME replace entity references
        endif
      enddo
    case (CDATA_SECTION_NODE)
      n = size(arg%nodeValue)
    case (COMMENT_NODE)
      n = size(arg%nodeValue)
    case (PROCESSING_INSTRUCTION_NODE)
      n = size(arg%nodeValue)
    case (TEXT_NODE)
      n = size(arg%nodeValue)
    case default
      n = 0
    end select

  end function getNodeValue_len

  function getNodeValue(arg, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=getNodeValue_len(arg)) :: c

    integer :: i, n

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getNodeValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    select case(arg%nodeType)
    case (ATTRIBUTE_NODE)
      n = 1
      do i = 1, arg%childNodes%length
        if (arg%childNodes%nodes(i)%this%nodeType == TEXT_NODE) then
          c(n:n+size(arg%childNodes%nodes(i)%this%nodeValue)-1) = &
            str_vs(arg%childNodes%nodes(i)%this%nodeValue)
          n = n + size(arg%childNodes%nodes(i)%this%nodeValue)
        else
          !FIXME replace entity references
        endif
      enddo
    case (CDATA_SECTION_NODE)
      c = str_vs(arg%nodeValue)
    case (COMMENT_NODE)
      c = str_vs(arg%nodeValue)
    case (PROCESSING_INSTRUCTION_NODE)
      c = str_vs(arg%nodeValue)
    case (TEXT_NODE)
      c = str_vs(arg%nodeValue)
    end select
    
  end function getNodeValue

  subroutine setStringValue(arg, stringValue, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=*) :: stringValue
  
    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "setStringValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (getNodeType(arg)/=ENTITY_NODE) then
      call throw_exception(FoX_INTERNAL_ERROR, "setStringValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (associated(arg%nodeValue)) deallocate(arg%nodeValue)
    arg%nodeValue => vs_str_alloc(stringValue)

  end subroutine setStringValue

  pure function getStringValue_len(arg, p) result(n)
    type(Node), pointer :: arg
    logical, intent(in) :: p
    integer :: n

    if (p) then
      n = size(arg%nodeValue)
    else
      n = 0
    endif
  end function getStringValue_len

  function getStringValue(arg, ex)result(s) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=getStringValue_len(arg, associated(arg))) :: s
  
    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getStringValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (getNodeType(arg)/=ENTITY_NODE) then
      call throw_exception(FoX_INTERNAL_ERROR, "getStringValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    s = str_vs(arg%nodeValue)

  end function getStringValue
    
  subroutine setNodeValue(arg, nodeValue, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=*) :: nodeValue

    type(Node), pointer :: np
    integer :: i, n

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "setNodeValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setNodeValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    select case(arg%nodeType)
    case (ATTRIBUTE_NODE)
      ! FIXME check does string contain wrong characters
      ! destroy any existing children ... 
      do i = 1, arg%childNodes%length
        if (.not.arg%inDocument) &
          call remove_node_nl(arg%ownerDocument%docExtras%hangingNodes, arg%childNodes%nodes(i)%this)
        call destroyNode(arg%childNodes%nodes(i)%this)
      enddo
      deallocate(arg%childNodes%nodes)
      allocate(arg%childNodes%nodes(0))
      arg%childNodes%length = 0
      arg%firstChild => null()
      arg%lastChild => null()
      ! and add the new one.
      ! Avoid manipulating hangingnode lists
      call setGCstate(arg%ownerDocument, .false.)
      np => createTextNode(arg%ownerDocument, nodeValue)
      np => appendChild(arg, np)
      call setGCstate(arg%ownerDocument, .true.)
    case (CDATA_SECTION_NODE)
      ! FIXME check does string contain wrong characters
      deallocate(arg%nodeValue)
      arg%nodeValue => vs_str_alloc(nodeValue)
    case (COMMENT_NODE)
      ! FIXME check does string contain wrong characters
      deallocate(arg%nodeValue)
      arg%nodeValue => vs_str_alloc(nodeValue)
    case (PROCESSING_INSTRUCTION_NODE)
      ! FIXME check does string contain wrong characters
      deallocate(arg%nodeValue)
      arg%nodeValue => vs_str_alloc(nodeValue)
    case (TEXT_NODE)
      ! FIXME check does string contain wrong characters
      deallocate(arg%nodeValue)
      arg%nodeValue => vs_str_alloc(nodeValue)
    end select

  end subroutine setNodeValue

  function getNodeType(arg, ex)result(n) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    integer :: n

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getNodeType", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    n = arg%nodeType
  end function getNodeType

  function getParentNode(arg, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: np

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getParentNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => arg%parentNode
  end function getParentNode
  
  function getChildNodes(arg, ex)result(nl) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(NodeList), pointer :: nl

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getChildNodes", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    nl => arg%childnodes
  end function getChildNodes
  
  function getFirstChild(arg, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: np

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getFirstChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => arg%firstChild
  end function getFirstChild
  
  function getLastChild(arg, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: np

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getLastChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => arg%lastChild
  end function getLastChild

  function getPreviousSibling(arg, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: np

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getPreviousSibling", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => arg%previousSibling
  end function getPreviousSibling
  
  function getNextSibling(arg, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: np

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getNextSibling", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => arg%nextSibling
  end function getNextSibling

  function getAttributes(arg, ex)result(nnm) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(NamedNodeMap), pointer :: nnm

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getAttributes", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (getNodeType(arg)==ELEMENT_NODE) then
      nnm => arg%attributes
    else
      nnm => null()
    endif
  end function getAttributes

  function getOwnerDocument(arg, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: np

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getOwnerDocument", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    if (arg%nodeType==DOCUMENT_NODE) then
      np => null()
    else
      np => arg%ownerDocument
    endif
  end function getOwnerDocument

  function insertBefore(arg, newChild, refChild, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: newChild
    type(Node), pointer :: refChild
    type(Node), pointer :: np

    type(Node), pointer :: testChild, testParent
    type(ListNode), pointer :: temp_nl(:)
    integer :: i, i2, i_t

    if (.not.associated(arg).or..not.associated(newChild)) then
      call throw_exception(FoX_NODE_IS_NULL, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not.associated(refChild)) then
      np => appendChild(arg, newChild, ex)
    endif

    if (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    testParent => arg
    ! Check if you are allowed to put a newChild nodetype under a arg nodetype
    if (newChild%nodeType==DOCUMENT_FRAGMENT_NODE) then
      do i = 1, newChild%childNodes%length
        testChild => newChild%childNodes%nodes(i)%this
              select case(testParent%nodeType)
      case (ELEMENT_NODE)
        if (testChild%nodeType/=ELEMENT_NODE &
          .and. testChild%nodeType/=TEXT_NODE &
          .and. testChild%nodeType/=COMMENT_NODE &
          .and. testChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
          .and. testChild%nodeType/=CDATA_SECTION_NODE &
          .and. testChild%nodeType/=ENTITY_REFERENCE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (ATTRIBUTE_NODE)
        if (testChild%nodeType/=TEXT_NODE &
          .and. testChild%nodeType/=ENTITY_REFERENCE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (DOCUMENT_NODE)
        if (testChild%nodeType/=ELEMENT_NODE &
          .and. testChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
          .and. testChild%nodeType/=COMMENT_NODE &
          .and. testChild%nodeType/=DOCUMENT_TYPE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (DOCUMENT_FRAGMENT_NODE)
        if (testChild%nodeType/=ELEMENT_NODE &
          .and. testChild%nodeType/=TEXT_NODE &
          .and. testChild%nodeType/=COMMENT_NODE &
          .and. testChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
          .and. testChild%nodeType/=CDATA_SECTION_NODE &
          .and. testChild%nodeType/=ENTITY_REFERENCE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (ENTITY_NODE)
        continue ! only allowed by DOM parser, not by user.
        ! but entity nodes are always readonly anyway, so no problem
      case (ENTITY_REFERENCE_NODE)
        continue ! only allowed by DOM parser, not by user.
        ! but entity nodes are always readonly anyway, so no problem
      case default
        call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      end select

      enddo
    else
      testChild => newChild
            select case(testParent%nodeType)
      case (ELEMENT_NODE)
        if (testChild%nodeType/=ELEMENT_NODE &
          .and. testChild%nodeType/=TEXT_NODE &
          .and. testChild%nodeType/=COMMENT_NODE &
          .and. testChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
          .and. testChild%nodeType/=CDATA_SECTION_NODE &
          .and. testChild%nodeType/=ENTITY_REFERENCE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (ATTRIBUTE_NODE)
        if (testChild%nodeType/=TEXT_NODE &
          .and. testChild%nodeType/=ENTITY_REFERENCE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (DOCUMENT_NODE)
        if (testChild%nodeType/=ELEMENT_NODE &
          .and. testChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
          .and. testChild%nodeType/=COMMENT_NODE &
          .and. testChild%nodeType/=DOCUMENT_TYPE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (DOCUMENT_FRAGMENT_NODE)
        if (testChild%nodeType/=ELEMENT_NODE &
          .and. testChild%nodeType/=TEXT_NODE &
          .and. testChild%nodeType/=COMMENT_NODE &
          .and. testChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
          .and. testChild%nodeType/=CDATA_SECTION_NODE &
          .and. testChild%nodeType/=ENTITY_REFERENCE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (ENTITY_NODE)
        continue ! only allowed by DOM parser, not by user.
        ! but entity nodes are always readonly anyway, so no problem
      case (ENTITY_REFERENCE_NODE)
        continue ! only allowed by DOM parser, not by user.
        ! but entity nodes are always readonly anyway, so no problem
      case default
        call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      end select

      ! And then check that newChild is not arg or one of args ancestors
      ! (this would never be true if newChild is a documentFragment)
      testParent => arg
      do while (associated(testParent))
        if (associated(testParent, newChild)) then
          call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

        endif
        testParent => testParent%parentNode
      enddo
    endif

    if (.not.(associated(arg%ownerDocument, newChild%ownerDocument) &
      .or. associated(arg, newChild%ownerDocument))) then
      call throw_exception(WRONG_DOCUMENT_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (newChild%nodeType==DOCUMENT_FRAGMENT_NODE &
      .and. newChild%childNodes%length==0) then
      np => newChild
      return
      ! Nothing to do
    endif

    if (associated(newChild%parentNode)) &
      newChild => removeChild(newChild%parentNode, newChild, ex) 

    if (arg%childNodes%length==0) then
      call throw_exception(NOT_FOUND_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (newChild%nodeType==DOCUMENT_FRAGMENT_NODE) then
      allocate(temp_nl(arg%childNodes%length+newChild%childNodes%length))
    else
      allocate(temp_nl(arg%childNodes%length+1))
    endif

    i_t = 0
    np => null()
    do i = 1, arg%childNodes%length
      if (associated(arg%childNodes%nodes(i)%this, refChild)) then
        np => refChild
        if (newChild%nodeType==DOCUMENT_FRAGMENT_NODE) then
          do i2 = 1, newChild%childNodes%length
            i_t = i_t + 1
            temp_nl(i_t)%this => newChild%childNodes%nodes(i2)%this
            temp_nl(i_t)%this%parentNode => arg
          enddo
        else
          i_t = i_t + 1
          temp_nl(i_t)%this => newChild
          temp_nl(i_t)%this%parentNode => arg
        endif
        if (i==1) then
          arg%firstChild => temp_nl(1)%this
          temp_nl(1)%this%previousSibling => null() ! FIXME no-op
        else 
          temp_nl(i-1)%this%nextSibling => temp_nl(i)%this
          temp_nl(i)%this%previousSibling => temp_nl(i-1)%this
        endif
        arg%childNodes%nodes(i)%this%previousSibling => temp_nl(i_t)%this
        temp_nl(i_t)%this%nextSibling => arg%childNodes%nodes(i)%this
      endif
      i_t = i_t + 1
      temp_nl(i_t)%this => arg%childNodes%nodes(i)%this
    enddo

    if (.not.associated(np)) then
      call throw_exception(NOT_FOUND_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (getGCstate(getownerDocument(arg))) then
      if (arg%inDocument) then
        if (newChild%nodeType==DOCUMENT_FRAGMENT_NODE) then
          do i = 1, newChild%childNodes%length
            call putNodesInDocument(arg%ownerDocument, newChild%childNodes%nodes(i)%this)
          enddo
        else
          call putNodesInDocument(arg%ownerDocument, newChild)
        endif
        ! If newChild was originally in document, it was removed above so must be re-added FIXME
      endif
      ! If arg was not in the document, then newChildren were either 
      ! a) removed above in call to removeChild or
      ! b) in a document fragment and therefore not part of doc either
    endif

    if (newChild%nodeType==DOCUMENT_FRAGMENT_NODE) then
      deallocate(newChild%childNodes%nodes)
      allocate(newChild%childNodes%nodes(0))
      newChild%childNodes%length = 0
    endif
    deallocate(arg%childNodes%nodes)
    arg%childNodes%nodes => temp_nl
    arg%childNodes%length = size(arg%childNodes%nodes)

  end function insertBefore


  function replaceChild(arg, newChild, oldChild, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: newChild
    type(Node), pointer :: oldChild
    type(Node), pointer :: np

    type(Node), pointer :: testChild, testParent
    type(ListNode), pointer :: temp_nl(:)
    integer :: i, i2, i_t

    if (.not.associated(arg).or..not.associated(newChild).or..not.associated(oldChild)) then
      call throw_exception(FoX_NODE_IS_NULL, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    testParent => arg
    ! Check if you are allowed to put a newChild nodetype under a arg nodetype
    if (newChild%nodeType==DOCUMENT_FRAGMENT_NODE) then
      do i = 1, newChild%childNodes%length
        testChild => newChild%childNodes%nodes(i)%this
              select case(testParent%nodeType)
      case (ELEMENT_NODE)
        if (testChild%nodeType/=ELEMENT_NODE &
          .and. testChild%nodeType/=TEXT_NODE &
          .and. testChild%nodeType/=COMMENT_NODE &
          .and. testChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
          .and. testChild%nodeType/=CDATA_SECTION_NODE &
          .and. testChild%nodeType/=ENTITY_REFERENCE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (ATTRIBUTE_NODE)
        if (testChild%nodeType/=TEXT_NODE &
          .and. testChild%nodeType/=ENTITY_REFERENCE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (DOCUMENT_NODE)
        if (testChild%nodeType/=ELEMENT_NODE &
          .and. testChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
          .and. testChild%nodeType/=COMMENT_NODE &
          .and. testChild%nodeType/=DOCUMENT_TYPE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (DOCUMENT_FRAGMENT_NODE)
        if (testChild%nodeType/=ELEMENT_NODE &
          .and. testChild%nodeType/=TEXT_NODE &
          .and. testChild%nodeType/=COMMENT_NODE &
          .and. testChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
          .and. testChild%nodeType/=CDATA_SECTION_NODE &
          .and. testChild%nodeType/=ENTITY_REFERENCE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (ENTITY_NODE)
        continue ! only allowed by DOM parser, not by user.
        ! but entity nodes are always readonly anyway, so no problem
      case (ENTITY_REFERENCE_NODE)
        continue ! only allowed by DOM parser, not by user.
        ! but entity nodes are always readonly anyway, so no problem
      case default
        call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      end select

      enddo
    else
      testChild => newChild
            select case(testParent%nodeType)
      case (ELEMENT_NODE)
        if (testChild%nodeType/=ELEMENT_NODE &
          .and. testChild%nodeType/=TEXT_NODE &
          .and. testChild%nodeType/=COMMENT_NODE &
          .and. testChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
          .and. testChild%nodeType/=CDATA_SECTION_NODE &
          .and. testChild%nodeType/=ENTITY_REFERENCE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (ATTRIBUTE_NODE)
        if (testChild%nodeType/=TEXT_NODE &
          .and. testChild%nodeType/=ENTITY_REFERENCE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (DOCUMENT_NODE)
        if (testChild%nodeType/=ELEMENT_NODE &
          .and. testChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
          .and. testChild%nodeType/=COMMENT_NODE &
          .and. testChild%nodeType/=DOCUMENT_TYPE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (DOCUMENT_FRAGMENT_NODE)
        if (testChild%nodeType/=ELEMENT_NODE &
          .and. testChild%nodeType/=TEXT_NODE &
          .and. testChild%nodeType/=COMMENT_NODE &
          .and. testChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
          .and. testChild%nodeType/=CDATA_SECTION_NODE &
          .and. testChild%nodeType/=ENTITY_REFERENCE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (ENTITY_NODE)
        continue ! only allowed by DOM parser, not by user.
        ! but entity nodes are always readonly anyway, so no problem
      case (ENTITY_REFERENCE_NODE)
        continue ! only allowed by DOM parser, not by user.
        ! but entity nodes are always readonly anyway, so no problem
      case default
        call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      end select

      ! And then check that newChild is not arg or one of args ancestors
      ! (this would never be true if newChild is a documentFragment)
      testParent => arg
      do while (associated(testParent))
        if (associated(testParent, newChild)) then
          call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

        endif
        testParent => testParent%parentNode
      enddo
    endif

    if (.not.(associated(arg%ownerDocument, newChild%ownerDocument) &
      .or. associated(arg, newChild%ownerDocument))) then
      call throw_exception(WRONG_DOCUMENT_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (associated(newChild%parentNode)) &
      newChild => removeChild(newChild%parentNode, newChild, ex) 

    if (arg%childNodes%length==0) then
      call throw_exception(NOT_FOUND_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (newChild%nodeType==DOCUMENT_FRAGMENT_NODE) then
      allocate(temp_nl(arg%childNodes%length+newChild%childNodes%length-1))
    else
      temp_nl => arg%childNodes%nodes
    endif

    i_t = 0
    np => null()
    do i = 1, arg%childNodes%length
      if (associated(arg%childNodes%nodes(i)%this, oldChild)) then
        np => oldChild
        if (newChild%nodeType==DOCUMENT_FRAGMENT_NODE) then
          do i2 = 1, newChild%childNodes%length
            i_t = i_t + 1
            temp_nl(i_t)%this => newChild%childNodes%nodes(i2)%this
            temp_nl(i_t)%this%parentNode => arg
          enddo
        else
          i_t = i_t + 1
          temp_nl(i_t)%this => newChild
          temp_nl(i_t)%this%parentNode => arg
        endif
        if (i==1) then
          arg%firstChild => temp_nl(1)%this
          temp_nl(1)%this%previousSibling => null() ! FIXME no-op
        else 
          temp_nl(i-1)%this%nextSibling => temp_nl(i)%this
          temp_nl(i)%this%previousSibling => temp_nl(i-1)%this
        endif
        if (i==arg%childNodes%length) then
          arg%lastChild => temp_nl(i_t)%this
          temp_nl(i_t)%this%nextSibling => null() ! FIXME no-op
        else
          arg%childNodes%nodes(i+1)%this%previousSibling => temp_nl(i_t)%this
          temp_nl(i_t)%this%nextSibling => arg%childNodes%nodes(i+1)%this
        endif
      else
        i_t = i_t + 1
        temp_nl(i_t)%this => arg%childNodes%nodes(i)%this
      endif
    enddo

    if (.not.associated(np)) then
      call throw_exception(NOT_FOUND_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    np%parentNode => null()
    np%previousSibling => null()
    np%nextSibling => null()

    if (getGCstate(arg%ownerDocument)) then
      if (arg%inDocument) then
        call removeNodesFromDocument(arg%ownerDocument, oldChild)
        if (newChild%nodeType==DOCUMENT_FRAGMENT_NODE) then
          do i = 1, newChild%childNodes%length
            call putNodesInDocument(arg%ownerDocument, newChild%childNodes%nodes(i)%this)
          enddo
        else
          call putNodesInDocument(arg%ownerDocument, newChild)
        endif
        ! If newChild was originally in document, it was removed above so must be re-added FIXME
      endif
      ! If arg was not in the document, then newChildren were either 
      ! a) removed above in call to removeChild or
      ! b) in a document fragment and therefore not part of doc either
    endif

    if (newChild%nodeType==DOCUMENT_FRAGMENT_NODE) then
      deallocate(newChild%childNodes%nodes)
      allocate(newChild%childNodes%nodes(0))
      newChild%childNodes%length = 0
      deallocate(arg%childNodes%nodes)
      arg%childNodes%nodes => temp_nl
      arg%childNodes%length = size(arg%childNodes%nodes)
    endif

  end function replaceChild


  function removeChild(arg, oldChild, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: oldChild
    type(Node), pointer :: np

    type(ListNode), pointer :: temp_nl(:)
    integer :: i, i_t

    if (.not.associated(arg).or..not.associated(oldChild)) then
      call throw_exception(FoX_NODE_IS_NULL, "removeChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "removeChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    allocate(temp_nl(size(arg%childNodes%nodes)-1))
    i_t = 1
    do i = 1, size(arg%childNodes%nodes)
      if (associated(arg%childNodes%nodes(i)%this, oldChild)) then 
        if (associated(arg%firstChild, arg%lastChild)) then
          ! There is only one child, we are removing it.
          arg%firstChild => null()
          arg%lastChild => null()
        elseif (i==1) then
          ! We are removing the first child, but there is a second
          arg%firstChild => arg%childNodes%nodes(2)%this
          arg%childNodes%nodes(2)%this%previousSibling => null()
        elseif (i==size(arg%childNodes%nodes)) then
          ! We are removing the last child, but there is a second-to-last
          arg%lastChild => arg%childNodes%nodes(i-1)%this
          arg%childNodes%nodes(i-1)%this%nextSibling => null()
        else
          ! We are removing a child in the middle
          arg%childNodes%nodes(i-1)%this%nextSibling => arg%childNodes%nodes(i+1)%this
          arg%childNodes%nodes(i+1)%this%previousSibling => arg%childNodes%nodes(i-1)%this
        endif
      else
        temp_nl(i_t)%this => arg%childNodes%nodes(i)%this
        i_t = i_t + 1     
      endif
    enddo
    deallocate(arg%childNodes%nodes)
    arg%childNodes%nodes => temp_nl
    arg%childNodes%length = size(temp_nl)
    if (i==i_t) then
      call throw_exception(NOT_FOUND_ERR, "removeChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

! NOTE BELOW FUCKED-UP WORKAROUND FOR G95!!
    np => arg
    oldChild%parentNode => null()
    oldChild%previousSibling => null()
    oldChild%nextSibling => null()
    arg => np
    if (getGCstate(arg%ownerDocument)) then
      if (arg%inDocument) then
        call removeNodesFromDocument(arg%ownerDocument, oldChild)
      endif
    endif

    np => oldChild

  end function removeChild


  function appendChild(arg, newChild, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: newChild
    type(Node), pointer :: np
    
    type(Node), pointer :: testChild, testParent
    type(ListNode), pointer :: temp_nl(:)
    integer :: i, i_t

    if (.not.associated(arg).or..not.associated(newChild)) then
      call throw_exception(FoX_NODE_IS_NULL, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    testParent => arg
    ! Check if you are allowed to put a newChild nodetype under a arg nodetype
    if (newChild%nodeType==DOCUMENT_FRAGMENT_NODE) then
      do i = 1, newChild%childNodes%length
        testChild => newChild%childNodes%nodes(i)%this
              select case(testParent%nodeType)
      case (ELEMENT_NODE)
        if (testChild%nodeType/=ELEMENT_NODE &
          .and. testChild%nodeType/=TEXT_NODE &
          .and. testChild%nodeType/=COMMENT_NODE &
          .and. testChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
          .and. testChild%nodeType/=CDATA_SECTION_NODE &
          .and. testChild%nodeType/=ENTITY_REFERENCE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (ATTRIBUTE_NODE)
        if (testChild%nodeType/=TEXT_NODE &
          .and. testChild%nodeType/=ENTITY_REFERENCE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (DOCUMENT_NODE)
        if (testChild%nodeType/=ELEMENT_NODE &
          .and. testChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
          .and. testChild%nodeType/=COMMENT_NODE &
          .and. testChild%nodeType/=DOCUMENT_TYPE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (DOCUMENT_FRAGMENT_NODE)
        if (testChild%nodeType/=ELEMENT_NODE &
          .and. testChild%nodeType/=TEXT_NODE &
          .and. testChild%nodeType/=COMMENT_NODE &
          .and. testChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
          .and. testChild%nodeType/=CDATA_SECTION_NODE &
          .and. testChild%nodeType/=ENTITY_REFERENCE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (ENTITY_NODE)
        continue ! only allowed by DOM parser, not by user.
        ! but entity nodes are always readonly anyway, so no problem
      case (ENTITY_REFERENCE_NODE)
        continue ! only allowed by DOM parser, not by user.
        ! but entity nodes are always readonly anyway, so no problem
      case default
        call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      end select

      enddo
    else
      testChild => newChild
            select case(testParent%nodeType)
      case (ELEMENT_NODE)
        if (testChild%nodeType/=ELEMENT_NODE &
          .and. testChild%nodeType/=TEXT_NODE &
          .and. testChild%nodeType/=COMMENT_NODE &
          .and. testChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
          .and. testChild%nodeType/=CDATA_SECTION_NODE &
          .and. testChild%nodeType/=ENTITY_REFERENCE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (ATTRIBUTE_NODE)
        if (testChild%nodeType/=TEXT_NODE &
          .and. testChild%nodeType/=ENTITY_REFERENCE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (DOCUMENT_NODE)
        if (testChild%nodeType/=ELEMENT_NODE &
          .and. testChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
          .and. testChild%nodeType/=COMMENT_NODE &
          .and. testChild%nodeType/=DOCUMENT_TYPE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (DOCUMENT_FRAGMENT_NODE)
        if (testChild%nodeType/=ELEMENT_NODE &
          .and. testChild%nodeType/=TEXT_NODE &
          .and. testChild%nodeType/=COMMENT_NODE &
          .and. testChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
          .and. testChild%nodeType/=CDATA_SECTION_NODE &
          .and. testChild%nodeType/=ENTITY_REFERENCE_NODE) &
          call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      case (ENTITY_NODE)
        continue ! only allowed by DOM parser, not by user.
        ! but entity nodes are always readonly anyway, so no problem
      case (ENTITY_REFERENCE_NODE)
        continue ! only allowed by DOM parser, not by user.
        ! but entity nodes are always readonly anyway, so no problem
      case default
        call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      end select

      ! And then check that newChild is not arg or one of args ancestors
      ! (this would never be true if newChild is a documentFragment)
      testParent => arg
      do while (associated(testParent))
        if (associated(testParent, newChild)) then
          call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

        endif
        testParent => testParent%parentNode
      enddo
    endif

    if (.not.(associated(arg%ownerDocument, newChild%ownerDocument) &
      .or. associated(arg, newChild%ownerDocument))) then
      call throw_exception(WRONG_DOCUMENT_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (newChild%nodeType==DOCUMENT_FRAGMENT_NODE &
      .and. newChild%childNodes%length==0) then
      np => newChild
      return
      ! Nothing to do
    endif

    if (associated(newChild%parentNode)) &
      newChild => removeChild(newChild%parentNode, newChild, ex) 

    if (newChild%nodeType==DOCUMENT_FRAGMENT_NODE) then
      allocate(temp_nl(arg%childNodes%length+newChild%childNodes%length))
    else
      allocate(temp_nl(arg%childNodes%length+1))
    endif

    do i = 1, arg%childNodes%length
      temp_nl(i)%this => arg%childNodes%nodes(i)%this
    enddo
    
    if (newChild%nodeType==DOCUMENT_FRAGMENT_NODE) then
      i_t = arg%childNodes%length
      do i = 1, newChild%childNodes%length
        i_t = i_t + 1
        temp_nl(i_t)%this => newChild%childNodes%nodes(i)%this
        print*,"ASS", i_t, associated(temp_nl(i_t)%this)
        if (arg%inDocument) &
          call putNodesInDocument(arg%ownerDocument, temp_nl(i_t)%this)
        temp_nl(i_t)%this%parentNode => arg
      enddo
      if (arg%childNodes%length==0) then
        arg%firstChild => newChild%firstChild
      else
        newChild%firstChild%previousSibling => arg%lastChild
        arg%lastChild%nextSibling => newChild%firstChild
      endif
      arg%lastChild => newChild%lastChild
      newChild%firstChild => null()
      newChild%lastChild => null()
      deallocate(newChild%childNodes%nodes)
      allocate(newChild%childNodes%nodes(0))
      newChild%childNodes%length = 0
    else
      temp_nl(i)%this => newChild
      if (i==1) then
        arg%firstChild => newChild
        newChild%previousSibling => null()
      else
        temp_nl(i-1)%this%nextSibling => newChild
        newChild%previousSibling => temp_nl(i-1)%this     
      endif
      if (getGCstate(arg%ownerDocument)) then
        if (arg%inDocument.and..not.newChild%inDocument) then
          call putNodesInDocument(arg%ownerDocument, newChild)
        endif
      endif
      newChild%nextSibling => null()
      arg%lastChild => newChild
      newChild%parentNode => arg
    endif

    deallocate(arg%childNodes%nodes)
    arg%childNodes%nodes => temp_nl
    arg%childNodes%length = size(temp_nl)

    np => newChild

  end function appendChild


  function hasChildNodes(arg, ex) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    logical :: hasChildNodes
    
    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "hasChildNodes", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    hasChildNodes = associated(arg%firstChild)
    
  end function hasChildNodes

  function cloneNode(arg, deep, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    logical :: deep
    type(Node), pointer :: np

    type(Node), pointer :: doc, thatParent, this, new, ERchild

    logical :: doneAttributes, doneChildren, readonly, quickFix
    integer :: i

print*,"ENTERING CLONENODE..."
    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "cloneNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    this => arg
    thatParent => null()
    ERchild => null()
    doc => getOwnerDocument(arg)
    np => null()
    
    readonly = .false.


    i = 0
    doneChildren = .false.
    doneAttributes = .false.
    do

      if (.not.(getNodeType(this)==ELEMENT_NODE.and.doneAttributes)) then
      if (.not.doneChildren) then



      new => null()
      select case(getNodeType(this))
      case (ELEMENT_NODE)
        if (.not.doneAttributes) then
          ! Are there any new prefixes or namespaces to be declared?
          ! FIXME
          new => createElement(doc, getTagName(this))
        endif
      case (ATTRIBUTE_NODE)
        new => createAttribute(doc, getName(this))
        if (associated(this, arg)) then
          call setSpecified(new, .true.)
        else
          call setSpecified(new, getSpecified(this))
        endif
      case (TEXT_NODE)
        new => createTextNode(doc, getData(this))
      case (CDATA_SECTION_NODE)
        new => createCDataSection(doc, getData(this))
      case (ENTITY_REFERENCE_NODE)
        ERchild => this
        readonly = .true.
        new => createEmptyEntityReference(doc, getNodeName(this))
      case (ENTITY_NODE)
        return
      case (PROCESSING_INSTRUCTION_NODE)
        new => createProcessingInstruction(doc, getTarget(this), getData(this))
      case (COMMENT_NODE)
        new => createComment(doc, getData(this))
      case (DOCUMENT_NODE)
        return
      case (DOCUMENT_TYPE_NODE)
        return
      case (DOCUMENT_FRAGMENT_NODE)
        new => createDocumentFragment(doc)
      case (NOTATION_NODE)
        return
      end select

      if (.not.associated(thatParent)) then
        thatParent => new
      elseif (associated(new)) then
        if (this%nodeType==ATTRIBUTE_NODE) then
          new => setAttributeNode(thatParent, new)
        else
          new => appendChild(thatParent, new)
        endif
      endif

      if (.not.deep) then
        if (getNodeType(arg)/=ELEMENT_NODE.and.getNodeType(arg)/=ATTRIBUTE_NODE) return
      endif


      else
        if (getNodeType(this)==ELEMENT_NODE) doneAttributes = .true.



      if (getNodeType(this)==ENTITY_REFERENCE_NODE &
        .and.associated(ERchild, this)) then
          ERchild => null()
          readonly = .false.
      endif
      this%readonly = readonly
      


      endif
      endif

      if (.not.doneChildren) then

        if (getNodeType(this)==ELEMENT_NODE.and..not.doneAttributes) then
          if (getLength(getAttributes(this))>0) then
                      if (.not.associated(this, arg)) thatParent => getLastChild(thatParent)
            this => item(getAttributes(this), 0)
          else
            if (.not.deep) return
            doneAttributes = .true.
          endif
        elseif (hasChildNodes(this)) then
          if (.not.associated(this, arg)) then
            if (getNodeType(this)==ATTRIBUTE_NODE) then
              thatParent => item(getAttributes(thatParent), i)
            else
              thatParent => getLastChild(thatParent)
            endif
          endif
          this => getFirstChild(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          doneChildren = .true.
          doneAttributes = .false.
        endif

      else ! if doneChildren

        if (associated(this, arg)) exit
        if (getNodeType(this)==ATTRIBUTE_NODE) then
          if (i<getLength(getAttributes(getOwnerElement(this)))-1) then
            i = i + 1
            this => item(getAttributes(getOwnerElement(this)), i)
            doneChildren = .false.
          else
            i = 0
            if (associated(getParentNode(thatParent))) thatParent => getParentNode(thatParent)
            this => getOwnerElement(this)
            doneAttributes = .true.
            doneChildren = .false.
          endif
        elseif (associated(getNextSibling(this))) then

          this => getNextSibling(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          this => getParentNode(this)
          if (.not.associated(this, arg)) then
            if (getNodeType(this)==ATTRIBUTE_NODE) then
              thatParent => getOwnerElement(thatParent)
            else
              thatParent => getParentNode(thatParent)
            endif
          endif
        endif
      endif

    enddo



    np => thatParent

  end function cloneNode

  
  function hasAttributes(arg, ex) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    logical :: hasAttributes

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "hasAttributes", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    hasAttributes = (arg%nodeType /= ELEMENT_NODE) &
      .and. (arg%attributes%length > 0)
    
  end function hasAttributes
  
  subroutine normalize(arg, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: this, tempNode, oldNode
    integer :: i, i_t
    logical :: doneChildren, doneAttributes
    character, pointer :: temp(:)

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "normalize", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

! DOM standard requires we ignore readonly status

    this => arg


    i = 0
    doneChildren = .false.
    doneAttributes = .false.
    do

      if (.not.(getNodeType(this)==ELEMENT_NODE.and.doneAttributes)) then
      if (.not.doneChildren) then



      if (getNodeType(this)==TEXT_NODE) then
        if (associated(this, arg)) exit ! If we are called on a text node itself, then do nothing.
        i_t = getLength(this)
        tempNode => getNextSibling(this)
        do while (associated(tempNode))
          if (getNodeType(tempNode)/=TEXT_NODE) exit
          i_t = i_t + getLength(tempNode)
          tempNode => getNextSibling(tempNode)
        enddo
        if (.not.associated(tempNode, getNextSibling(this))) then
          allocate(temp(i_t))
          temp(:getLength(this)) = getData(this)
          i_t = getLength(this)
          tempNode => getNextSibling(this)
          do while (associated(tempNode))
            if (getNodeType(tempNode)/=TEXT_NODE) exit
            temp(i_t+1:i_t+getLength(tempNode)) = getData(tempNode)
            i_t = i_t + getLength(tempNode)
            oldNode => tempNode
            tempNode => getNextSibling(tempNode)
            oldNode => removeChild(getParentNode(oldNode), oldNode)
            call remove_node_nl(arg%ownerDocument%docExtras%hangingNodes, oldNode)
            call destroy(oldNode)
          enddo
          deallocate(this%nodeValue)
          this%nodeValue => temp
        endif
      end if


      else
        if (getNodeType(this)==ELEMENT_NODE) doneAttributes = .true.



      endif
      endif

      if (.not.doneChildren) then

        if (getNodeType(this)==ELEMENT_NODE.and..not.doneAttributes) then
          if (getLength(getAttributes(this))>0) then
                      this => item(getAttributes(this), 0)
          else
            doneAttributes = .true.
          endif
        elseif (hasChildNodes(this)) then
          this => getFirstChild(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          doneChildren = .true.
          doneAttributes = .false.
        endif

      else ! if doneChildren

        if (associated(this, arg)) exit
        if (getNodeType(this)==ATTRIBUTE_NODE) then
          if (i<getLength(getAttributes(getOwnerElement(this)))-1) then
            i = i + 1
            this => item(getAttributes(getOwnerElement(this)), i)
            doneChildren = .false.
          else
            i = 0
            this => getOwnerElement(this)
            doneAttributes = .true.
            doneChildren = .false.
          endif
        elseif (associated(getNextSibling(this))) then

          this => getNextSibling(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          this => getParentNode(this)
        endif
      endif

    enddo




  end subroutine normalize

  function isSupported(arg, feature, version, ex)result(p) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=*), intent(in) :: feature
    character(len=*), intent(in) :: version
    logical :: p

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "isSupported", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    p = hasFeature(getImplementation(arg%ownerDocument), feature, version)
  end function isSupported

  ! FIXME should the below instead just decompose the QName on access?
  function getNamespaceURI(arg, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=size(arg%namespaceURI)) :: c

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getNamespaceURI", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    c = str_vs(arg%namespaceURI)
  end function getNamespaceURI

  function getPrefix(arg, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=size(arg%prefix)) :: c

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getPrefix", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    c = str_vs(arg%prefix)
  end function getPrefix
  
  subroutine setPrefix(arg, prefix, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=*) :: prefix

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "setPrefix", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    deallocate(arg%prefix)
    arg%prefix => vs_str_alloc(prefix)

    print*, "why are you doing this?"
    ! FIXME we should implement this but raise a FoX-specific exception if used
    stop
    ! FIXME exceptions
  end subroutine setPrefix

  function getLocalName(arg, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=size(arg%localName)) :: c

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getLocalName", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    c = str_vs(arg%localName)
  end function getLocalName

  ! function isDefaultNamespace
  ! function isEqualNode(np, arg)

  function isSameNode(arg, other, ex) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: other
    logical :: isSameNode

    if (.not.associated(arg).or..not.associated(other)) then
      call throw_exception(FoX_NODE_IS_NULL, "isSameNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    isSameNode = associated(arg, other)

  end function isSameNode

  ! function lookupNamespaceURI
  ! function lookupPrefix

  ! function getUserData
  ! function setUserData
  ! will not implement ...

  subroutine putNodesInDocument(doc, arg)
    type(Node), pointer :: doc, arg
    type(Node), pointer :: this
    logical :: doneChildren, doneAttributes
    integer :: i

    this => arg


    i = 0
    doneChildren = .false.
    doneAttributes = .false.
    do

      if (.not.(getNodeType(this)==ELEMENT_NODE.and.doneAttributes)) then
      if (.not.doneChildren) then


        this%inDocument = .true.
        call remove_node_nl(doc%docExtras%hangingNodes, this)


      else
        if (getNodeType(this)==ELEMENT_NODE) doneAttributes = .true.



      endif
      endif

      if (.not.doneChildren) then

        if (getNodeType(this)==ELEMENT_NODE.and..not.doneAttributes) then
          if (getLength(getAttributes(this))>0) then
                      this => item(getAttributes(this), 0)
          else
            doneAttributes = .true.
          endif
        elseif (hasChildNodes(this)) then
          this => getFirstChild(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          doneChildren = .true.
          doneAttributes = .false.
        endif

      else ! if doneChildren

        if (associated(this, arg)) exit
        if (getNodeType(this)==ATTRIBUTE_NODE) then
          if (i<getLength(getAttributes(getOwnerElement(this)))-1) then
            i = i + 1
            this => item(getAttributes(getOwnerElement(this)), i)
            doneChildren = .false.
          else
            i = 0
            this => getOwnerElement(this)
            doneAttributes = .true.
            doneChildren = .false.
          endif
        elseif (associated(getNextSibling(this))) then

          this => getNextSibling(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          this => getParentNode(this)
        endif
      endif

    enddo



  end subroutine putNodesInDocument

  subroutine removeNodesFromDocument(doc, arg)
    type(Node), pointer :: doc, arg
    type(Node), pointer :: this
    logical :: doneChildren, doneAttributes
    integer :: i

    this => arg


    i = 0
    doneChildren = .false.
    doneAttributes = .false.
    do

      if (.not.(getNodeType(this)==ELEMENT_NODE.and.doneAttributes)) then
      if (.not.doneChildren) then


        this%inDocument = .false.
        call append_nl(doc%docExtras%hangingNodes, this)


      else
        if (getNodeType(this)==ELEMENT_NODE) doneAttributes = .true.



      endif
      endif

      if (.not.doneChildren) then

        if (getNodeType(this)==ELEMENT_NODE.and..not.doneAttributes) then
          if (getLength(getAttributes(this))>0) then
                      this => item(getAttributes(this), 0)
          else
            doneAttributes = .true.
          endif
        elseif (hasChildNodes(this)) then
          this => getFirstChild(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          doneChildren = .true.
          doneAttributes = .false.
        endif

      else ! if doneChildren

        if (associated(this, arg)) exit
        if (getNodeType(this)==ATTRIBUTE_NODE) then
          if (i<getLength(getAttributes(getOwnerElement(this)))-1) then
            i = i + 1
            this => item(getAttributes(getOwnerElement(this)), i)
            doneChildren = .false.
          else
            i = 0
            this => getOwnerElement(this)
            doneAttributes = .true.
            doneChildren = .false.
          endif
        elseif (associated(getNextSibling(this))) then

          this => getNextSibling(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          this => getParentNode(this)
        endif
      endif

    enddo



  end subroutine removeNodesFromDocument

  subroutine setReadOnlyNode(arg, p)
    type(Node), pointer :: arg
    logical, intent(in) :: p

    type(Node), pointer :: this
    integer :: i
    logical :: doneAttributes, doneChildren

    this => arg


    i = 0
    doneChildren = .false.
    doneAttributes = .false.
    do

      if (.not.(getNodeType(this)==ELEMENT_NODE.and.doneAttributes)) then
      if (.not.doneChildren) then


    this%readonly = p


      else
        if (getNodeType(this)==ELEMENT_NODE) doneAttributes = .true.



      endif
      endif

      if (.not.doneChildren) then

        if (getNodeType(this)==ELEMENT_NODE.and..not.doneAttributes) then
          if (getLength(getAttributes(this))>0) then
                      this => item(getAttributes(this), 0)
          else
            doneAttributes = .true.
          endif
        elseif (hasChildNodes(this)) then
          this => getFirstChild(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          doneChildren = .true.
          doneAttributes = .false.
        endif

      else ! if doneChildren

        if (associated(this, arg)) exit
        if (getNodeType(this)==ATTRIBUTE_NODE) then
          if (i<getLength(getAttributes(getOwnerElement(this)))-1) then
            i = i + 1
            this => item(getAttributes(getOwnerElement(this)), i)
            doneChildren = .false.
          else
            i = 0
            this => getOwnerElement(this)
            doneAttributes = .true.
            doneChildren = .false.
          endif
        elseif (associated(getNextSibling(this))) then

          this => getNextSibling(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          this => getParentNode(this)
        endif
      endif

    enddo



  end subroutine setReadOnlyNode



  function item_nl(list, index) result(np)
    type(NodeList), intent(in) :: list
    integer, intent(in) :: index
    type(Node), pointer :: np

    if (index>=0.and.index<list%length)  then
      np => list%nodes(index+1)%this
    else
      np => null()
    endif

  end function item_nl

  subroutine append_nl(list, arg)
    type(NodeList), intent(inout) :: list
    type(Node), pointer :: arg

    type(ListNode), pointer :: temp_nl(:)
    integer :: i

    if (.not.associated(list%nodes)) then
      allocate(list%nodes(1))
      list%nodes(1)%this => arg
      list%length = 1
    else
      temp_nl => list%nodes
      allocate(list%nodes(size(temp_nl)+1))
      do i = 1, size(temp_nl)
        list%nodes(i)%this => temp_nl(i)%this
      enddo
      deallocate(temp_nl)
      list%nodes(size(list%nodes))%this => arg
      list%length = size(list%nodes)
    endif
    
  end subroutine append_nl

  function pop_nl(list) result(np)
    type(NodeList), intent(inout) :: list
    type(Node), pointer :: np

    type(ListNode), pointer :: temp_nl(:)
    integer :: i

    if (list%length==0) then
      ! FIXME internal error
      continue
    endif

    np => list%nodes(size(list%nodes))%this

    if (list%length==1) then
      deallocate(list%nodes)
      list%length = 0
    else
      temp_nl => list%nodes
      allocate(list%nodes(size(temp_nl)-1))
      do i = 1, size(temp_nl)-1
        list%nodes(i)%this => temp_nl(i)%this
      enddo
      deallocate(temp_nl)
      list%length = size(list%nodes)
    endif
    
  end function pop_nl


  function remove_nl(nl, index, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(NodeList), intent(inout) :: nl
    integer, intent(in) :: index
    type(Node), pointer :: np

    type(ListNode), pointer :: temp_nl(:)

    integer :: i

    if (index>nl%length) then
      call throw_exception(FoX_INTERNAL_ERROR, "remove_nl", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => nl%nodes(index)%this
    temp_nl => nl%nodes
    allocate(nl%nodes(size(temp_nl)-1))
    nl%length = nl%length - 1 
    do i = 1, index - 1
      nl%nodes(i)%this => temp_nl(i)%this
    enddo
    do i = index, nl%length
      nl%nodes(i)%this => temp_nl(i+1)%this
    enddo
    deallocate(temp_nl)

  end function remove_nl


  subroutine remove_node_nl(nl, np)
    type(NodeList), intent(inout) :: nl
    type(Node), pointer :: np

    type(ListNode), pointer :: temp_nl(:)

    integer :: i

    do i = 1, nl%length
      if (associated(nl%nodes(i)%this, np)) exit
    enddo
    np => remove_nl(nl, i)

  end subroutine remove_node_nl


  function getLength_nl(nl) result(n)
    type(NodeList), intent(in) :: nl
    integer :: n

    n = size(nl%nodes)
  end function getLength_nl

  subroutine destroyNodeList(nl)
    type(NodeList), pointer :: nl
    
    if (associated(nl%nodes)) deallocate(nl%nodes)
    if (associated(nl%nodeName)) deallocate(nl%nodeName)
    if (associated(nl%localName)) deallocate(nl%localName)
    if (associated(nl%namespaceURI)) deallocate(nl%namespaceURI)
    deallocate(nl)
  end subroutine destroyNodeList

  subroutine updateNodeLists(doc, oldName, newName, oldLocalName, newLocalName, oldNamespaceURI, newNamespaceURI)
    ! When triggered, (by addition or movement of an Element Node, or a change of its nodeName, localName, or namespaceURI)
    ! then see if any nodelists need updated.
    type(Node), pointer :: doc
    character, pointer :: oldName(:), newName(:)
    character, pointer :: oldLocalName(:), newLocalName(:)
    character, pointer :: oldNamespaceURI(:), newNamespaceURI(:)

    type(NodeList), pointer :: nl, nl_orig
    type(NodeListPtr), pointer :: temp_nll(:)
    integer :: i, i_t
! FIXME FIXME FIXME

    if (.not.doc%docExtras%liveNodeLists) return
    if (.not.associated(doc%docExtras%nodelists)) return

    allocate(temp_nll(size(doc%docExtras%nodelists)))
    i_t = 0
    do i = 1, size(doc%docExtras%nodelists)
      ! A nodelist will need updated if it was keyed to the old or new Names.
      nl_orig => doc%docExtras%nodelists(i)%this
      if (nl_orig%element%nodeType==ELEMENT_NODE) then
        if (.not.associated(nl_orig%element%parentNode)) then
          ! We have just removed this element from the tree
          deallocate(nl_orig%nodes)
          cycle
        endif
      endif
      ! we definitely keep this nodelist.
      i_t = i_t + 1
      ! Although all nodes should be searched whatever the result, we should only do the
      ! appropriate sort of search for this list - according to namespaces or not.
      if (associated(nl_orig%nodeName)) then ! this was made by getElementsByTagName
!!$        if (oldName=="*" &
!!$          .or. str_vs(nl_orig%nodeName)=="*" .or. &
!!$          str_vs(nl_orig%nodeName)==str_vs(oldName) &
!!$          .or. str_vs(nl_orig%nodeName)==str_vs(newName)) then
!!$          ! FIXME check logic above for wildcards
!!$          nl => getElementsByTagName(nl_orig%element, str_vs(nl_orig%nodeName))
!!$          ! That appended a nodelist to the end of doc%nodelists. But it does not matter,
!!$          ! the whole of the original nodelists will be thrown away anyway. We do have to do:
!!$          deallocate(nl_orig)
!!$          ! and then grab the new list for our new list of lists.
!!$          temp_nll(i_t)%this => nl
!!$        endif
      elseif (associated(nl_orig%namespaceURI)) then
        ! This was made by getElementsByTagNameNS
        if (str_vs(nl_orig%localName)==str_vs(oldLocalName) &
          .or. str_vs(nl_orig%localName)==str_vs(newLocalName) &
          .or. str_vs(nl_orig%namespaceURI)==str_vs(oldNamespaceURI) &
          .or. str_vs(nl_orig%namespaceURI)==str_vs(newNamespaceURI)) then
          ! destroy newNL
          nl => getElementsByTagNameNS(nl_orig%element, str_vs(nl_orig%localName), str_vs(nl_orig%namespaceURI))
          ! That appended a nodelist to the end of doc%nodelists. But it does not matter,
          ! the whole of the original nodelists will be thrown away anyway. We do have to do:
          deallocate(nl_orig)
          ! and then grab the new list for our new list of lists.
          temp_nll(i_t)%this => nl
        endif
      else
        temp_nll(i_t)%this => doc%docExtras%nodelists(i)%this
      endif
    enddo

    !Now, destroy all nodelist pointers from old list:
    do i = 1, size(doc%docExtras%nodelists) !Note, this size may be different if we have done more searches above.
      deallocate(doc%docExtras%nodelists(i)%this)
    enddo
    deallocate(doc%docExtras%nodelists)
    ! Now put everything back from temp_nll, but discard any lost nodelists
    allocate(doc%docExtras%nodelists(i_t))
    do i = 1, i_t
      doc%docExtras%nodelists(i)%this => temp_nll(i)%this
    enddo
    ! And finally, get rid of the temporary list of lists
    deallocate(temp_nll)

  end subroutine updateNodeLists

  



  function getNamedItem(map, name, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(NamedNodeMap), pointer :: map
    character(len=*), intent(in) :: name
    type(Node), pointer :: np

    integer :: i

    if (.not.associated(map)) then
      call throw_exception(FoX_NODE_IS_NULL, "getNamedItem", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    print*,"LOOKING FOR NAMED ITEM", map%length

    do i = 1, map%length
      print*, i, str_vs(map%nodes(i)%this%nodeName)
      if (str_vs(map%nodes(i)%this%nodeName)==name) then
        np => map%nodes(i)%this
        return
      endif
    enddo
    
    np => null()

  end function getNamedItem


  pure function getNamedItem_Value_length(map, name) result(n)
    type(NamedNodeMap), intent(in) :: map
    character(len=*), intent(in) :: name
    integer :: n

    integer :: i

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%nodeName)==name) then
        n = size(map%nodes(i)%this%nodeValue)
        exit
      endif
    enddo
    n = 0

  end function getNamedItem_Value_length


  pure function getNamedItem_Value(map, name) result(c)
    type(NamedNodeMap), intent(in) :: map
    character(len=*), intent(in) :: name
    character(len=getNamedItem_Value_length(map, name)) :: c

    integer :: i

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%nodeName)==name) then
        c = str_vs(map%nodes(i)%this%nodeValue)
        return
      endif
    enddo
    c = ""

  end function getNamedItem_Value


  function setNamedItem(map, arg, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(NamedNodeMap), pointer :: map
    type(Node), pointer :: arg
    type(Node), pointer :: np

    integer :: i

    if (.not.associated(map)) then
      call throw_exception(FoX_NODE_IS_NULL, "setNamedItem", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (map%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setNamedItem", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.associated(map%ownerElement%ownerDocument, arg%ownerDocument)) then
      call throw_exception(WRONG_DOCUMENT_ERR, "setNamedItem", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (associated(arg%ownerElement)) then
      call throw_exception(INUSE_ATTRIBUTE_ERR, "setNamedItem", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif
    
    endif

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%nodeName)==str_vs(arg%nodeName)) then
        np => map%nodes(i)%this
        map%nodes(i)%this => arg
        return
      endif
    enddo

    !   If not found, insert it at the end of the linked list
    np => null()
    call append_nnm(map, arg)

    if (getGCstate(getOwnerDocument(map%ownerElement))) then
      ! We need to worry about importing this node
      if (map%ownerElement%inDocument) then
        if (.not.arg%inDocument) &
          call putNodesInDocument(getOwnerDocument(map%ownerElement), arg)
      else
        if (arg%inDocument) &
          call removeNodesFromDocument(getOwnerDocument(map%ownerElement), arg)
        endif
    endif

  end function setNamedItem


  function removeNamedItem(map, name, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(NamedNodeMap), pointer :: map
    character(len=*), intent(in) :: name
    type(Node), pointer :: np

    type(ListNode), pointer :: temp_nl(:)
    integer :: i, i2

    if (.not.associated(map)) then
      call throw_exception(FoX_NODE_IS_NULL, "removeNamedItem", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (map%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "removeNamedItem", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%nodeName)==name) then
        ! Grab this node
        np => map%nodes(i)%this
        ! and shrink the node list
        temp_nl => map%nodes
        allocate(map%nodes(size(temp_nl)-1))
        do i2 = 1, i - 1
          map%nodes(i2)%this => temp_nl(i2)%this
        enddo
        do i2 = i + 1, map%length
          map%nodes(i2-1)%this => temp_nl(i2)%this
        enddo
        map%length = size(map%nodes)
        deallocate(temp_nl)
        if (np%inDocument.and.getGCstate(getOwnerDocument(map%ownerElement))) &
          call removeNodesFromDocument(getOwnerDocument(map%ownerElement), np)
        !otherwise we are only going to destroy these nodes anyway,
        ! and finish
        return
      endif
    enddo

    call throw_exception(NOT_FOUND_ERR, "removeNamedItem", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif


  end function removeNamedItem


  function item_nnm(map, index, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(NamedNodeMap), pointer :: map
    integer, intent(in) :: index
    type(Node), pointer :: np
    
    integer :: n

    if (.not.associated(map)) then
      call throw_exception(FoX_NODE_IS_NULL, "item_nnm", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (index<0 .or. index>map%length-1) then
      np => null()
    else
      np => map%nodes(index+1)%this
    endif

   end function item_nnm

  function getLength_nnm(map) result(n)
    type(namedNodeMap), intent(in) :: map
    integer :: n

    n = map%length
    
  end function getLength_nnm


  function getNamedItemNS(map, namespaceURI, localName, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(NamedNodeMap), pointer :: map
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    type(Node), pointer :: np

    integer :: i

    if (.not.associated(map)) then
      call throw_exception(FoX_NODE_IS_NULL, "getNamedItemNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%namespaceURI)==namespaceURI &
        .and. str_vs(map%nodes(i)%this%localName)==localName) then
        np => map%nodes(i)%this
        return
      endif
    enddo
    
    np => null()

  end function getNamedItemNS


  pure function getNamedItemNS_Value_length(map, namespaceURI, localName) result(n)
    type(NamedNodeMap), intent(in) :: map
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    integer :: n

    integer :: i

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%namespaceURI)==namespaceURI &
        .and. str_vs(map%nodes(i)%this%localName)==localName) then
        n = size(map%nodes(i)%this%nodeValue)
        exit
      endif
    enddo
    n = 0

  end function getNamedItemNS_Value_length


  pure function getNamedItemNS_Value(map, namespaceURI, localName) result(c)
    type(NamedNodeMap), intent(in) :: map
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    character(len=getNamedItemNS_Value_length(map, namespaceURI, localName)) :: c

    integer :: i

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%namespaceURI)==namespaceURI &
        .and. str_vs(map%nodes(i)%this%localName)==localName) then
        c = str_vs(map%nodes(i)%this%nodeValue)
        return
      endif
    enddo
    !FIXME error here

  end function getNamedItemNS_Value


  function setNamedItemNS(map, arg, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(NamedNodeMap), pointer :: map
    type(Node), pointer :: arg
    type(Node), pointer :: np

    integer :: i

    if (.not.associated(map)) then
      call throw_exception(FoX_NODE_IS_NULL, "setNamedItemNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (map%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setNamedItemNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.associated(map%ownerElement%ownerDocument, arg%ownerDocument)) then
      call throw_exception(WRONG_DOCUMENT_ERR, "setNamedItemNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (associated(arg%ownerElement)) then
      call throw_exception(INUSE_ATTRIBUTE_ERR, "setNamedItemNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif
    
    endif

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%namespaceURI)==str_vs(arg%namespaceURI) &
        .and. str_vs(map%nodes(i)%this%localName)==str_vs(arg%localName)) then
        np => map%nodes(i)%this
        map%nodes(i)%this => arg
        return
      endif
    enddo
    !   If not found, insert it at the end of the linked list
    np => null()
    call append_nnm(map, arg)

    if (getGCstate(getOwnerDocument(map%ownerElement))) then
      ! We need to worry about importing this node
      if (map%ownerElement%inDocument) then
        if (.not.arg%inDocument) &
          call putNodesInDocument(getOwnerDocument(map%ownerElement), arg)
      else
        if (arg%inDocument) &
          call removeNodesFromDocument(getOwnerDocument(map%ownerElement), arg)
        endif
    endif

  end function setNamedItemNS


  function removeNamedItemNS(map, namespaceURI, localName, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(NamedNodeMap), pointer :: map
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    type(Node), pointer :: np

    type(ListNode), pointer :: temp_nl(:)
    integer :: i, i2

    if (.not.associated(map)) then
      call throw_exception(FoX_NODE_IS_NULL, "removeNamedItemNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (map%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "removeNamedItemNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%namespaceURI)==namespaceURI &
        .and. str_vs(map%nodes(i)%this%localName)==localName) then
        ! Grab this node
        np => map%nodes(i)%this
        ! and shrink the node list
        temp_nl => map%nodes
        allocate(map%nodes(size(temp_nl)-1))
        do i2 = 1, i - 1
          map%nodes(i2)%this => temp_nl(i2)%this
        enddo
        do i2 = i + 1, map%length
          map%nodes(i2-1)%this => temp_nl(i2)%this
        enddo
        map%length = size(map%nodes)
        deallocate(temp_nl)
        if (np%inDocument.and.getGCstate(getOwnerDocument(map%ownerElement))) &
          call removeNodesFromDocument(getOwnerDocument(map%ownerElement), np)
        !otherwise we are only going to destroy these nodes anyway,
        ! and finish
        return
      endif
    enddo

    call throw_exception(NOT_FOUND_ERR, "removeNamedItemNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif


  end function removeNamedItemNS


  subroutine append_nnm(map, arg)
    type(namedNodeMap), pointer :: map
    type(node), pointer :: arg

    type(ListNode), pointer :: temp_nl(:)
    integer :: i

    if (.not.associated(map%nodes)) then
      allocate(map%nodes(1))
      map%nodes(1)%this => arg
      map%length = 1
    else
      temp_nl => map%nodes
      allocate(map%nodes(size(temp_nl)+1))
      do i = 1, size(temp_nl)
        map%nodes(i)%this => temp_nl(i)%this
      enddo
      deallocate(temp_nl)
      map%nodes(size(map%nodes))%this => arg
      map%length = size(map%nodes)
    endif

  end subroutine append_nnm


  subroutine setReadOnlyMap(map, r)
    type(namedNodeMap), pointer :: map
    logical, intent(in) :: r

    map%readonly = r
  end subroutine setReadOnlyMap

  subroutine destroyNamedNodeMap(map)
    type(namedNodeMap), pointer :: map

    if (associated(map%nodes)) deallocate(map%nodes)
    deallocate(map)
 end subroutine destroyNamedNodeMap



  function hasFeature(impl, feature, version, ex)result(p) 
    type(DOMException), intent(inout), optional :: ex
    type(DOMImplementation), intent(in) :: impl
    character(len=*), intent(in) :: feature
    character(len=*), intent(in) :: version
    logical :: p

    if (version=="1.0".or.version=="2.0".or.version=="") then
      p = (toLower(feature)=="core".or.toLower(feature)=="xml")
    else
      p = .false.
    endif

  end function hasFeature


  function createDocumentType(impl, qualifiedName, publicId, systemId, ex)result(dt) 
    type(DOMException), intent(inout), optional :: ex
    type(DOMImplementation), intent(in) :: impl
    character(len=*), intent(in) :: qualifiedName
    character(len=*), intent(in) :: publicId
    character(len=*), intent(in) :: systemId
    type(Node), pointer :: dt
    type(xml_doc_state) :: temp_xds

    if (.not.checkChars(qualifiedName, XML1_0)) then
      call throw_exception(INVALID_CHARACTER_ERR, "createDocumentType", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not.checkName(qualifiedName, temp_xds))  then
      call throw_exception(NAMESPACE_ERR, "createDocumentType", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    ! FIXME check that prefix etc is declared
    elseif (.not.checkPublicId(publicId)) then
      call throw_exception(FoX_INVALID_PUBLIC_ID, "createDocumentType", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkSystemId(systemId)) then
      call throw_exception(FoX_INVALID_SYSTEM_ID, "createDocumentType", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    dt => createNode(null(), DOCUMENT_TYPE_NODE, qualifiedName, "")
    dt%readonly = .true.
    dt%publicId = vs_str_alloc(publicId)
    dt%systemId = vs_str_alloc(systemId)
    allocate(dt%internalSubset(0)) !FIXME
    dt%ownerDocument => null()
    dt%entities%ownerElement => dt
    dt%notations%ownerElement => dt
    ! FIXME fill in the rest of the fields ...

  end function createDocumentType


  function createEmptyDocumentType(doc) result(dt)
    type(Node), pointer :: doc
    type(Node), pointer :: dt

    dt => createNode(doc, DOCUMENT_TYPE_NODE, "", "")
    dt%readonly = .true.
    !dt%entities
    !dt%notations
    allocate(dt%publicId(0))
    allocate(dt%systemId(0))
    allocate(dt%internalSubset(0)) !FIXME

    dt%entities%ownerElement => dt
    dt%notations%ownerElement => dt

  end function createEmptyDocumentType


  subroutine replace_xds(doc, xds)
    type(Node), pointer :: doc
    type(xml_doc_state), pointer :: xds

    call destroy_xml_doc_state(doc%docExtras%xds)
    deallocate(doc%docExtras%xds)
    doc%docExtras%xds => xds

  end subroutine replace_xds


  function createDocument(impl, namespaceURI, qualifiedName, docType) result(doc)
    type(DOMImplementation), intent(in) :: impl
    character(len=*), intent(in), optional :: namespaceURI
    character(len=*), intent(in), optional :: qualifiedName
    type(Node), pointer :: docType
    type(Node), pointer :: doc, dt

     !FIXMEFIXMEFIXME optional arguments and errors
    ! FIXME change to match empytdocument below

    doc => createNode(null(), DOCUMENT_NODE, "#document", "")
    doc%ownerDocument => doc ! Makes life easier. DOM compliance in getter

    allocate(doc%docExtras)
    doc%docExtras%implementation => FoX_DOM
    allocate(doc%docExtras%nodelists(0))
    allocate(doc%docExtras%xds)
    call init_xml_doc_state(doc%docExtras%xds)

    if (associated(docType)) then
      dt => docType
      dt%ownerDocument => doc
      doc%docExtras%docType => appendChild(doc, dt)
    else
      dt => createDocumentType(impl, qualifiedName, "", "")
      dt%ownerDocument => doc
    endif
    
    call setDocumentElement(doc, appendChild(doc, createElementNS(doc, namespaceURI, qualifiedName)))

  end function createDocument


  function createEmptyDocument() result(doc)
    type(Node), pointer :: doc
    type(Node), pointer :: dt
    
    doc => createNode(null(), DOCUMENT_NODE, "#document", "")
    doc%ownerDocument => doc ! Makes life easier. DOM compliance in getter

    allocate(doc%docExtras)
    doc%docExtras%implementation => FoX_DOM
    allocate(doc%docExtras%nodelists(0))
    allocate(doc%docExtras%xds)
    call init_xml_doc_state(doc%docExtras%xds)

    dt => createEmptyDocumentType(doc)
    dt%ownerDocument => doc
    doc%docExtras%doctype => dt

    ! FIXME do something with namespaceURI etc 

  end function createEmptyDocument


  subroutine destroyDocument(doc, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    
    type(Node), pointer :: dt
    type(NodeList) :: np_stack
    integer :: i

! Switch off all GC - since this is GC!
    call setGCstate(doc, .false.)

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "destroyDocument", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    ! Remove docType from tree before destruction:
    dt =>  getDocType(doc)
    if (associated(getParentNode(dt))) &
      dt => removeChild(doc, dt)
    call destroyDocumentType(dt)

    ! Destroy all remaining nodelists

    do i = 1, size(doc%docExtras%nodelists)
     call destroy(doc%docExtras%nodelists(i)%this)
    enddo
    deallocate(doc%docExtras%nodelists)


    ! Destroy all remaining hanging nodes
    do i = 1, doc%docExtras%hangingNodes%length
      call destroy(doc%docExtras%hangingNodes%nodes(i)%this)
    enddo
    if (associated(doc%docExtras%hangingNodes%nodes)) deallocate(doc%docExtras%hangingNodes%nodes)

    call destroy_xml_doc_state(doc%docExtras%xds)
    deallocate(doc%docExtras%xds)

    deallocate(doc%docExtras)

    print*, "destroying a node:", doc%nodeType, doc%nodeName

    call destroyAllNodesRecursively(doc)
    call destroyNodeContents(doc)
    deallocate(doc)

  end subroutine destroyDocument



  ! Getters and setters:

  function getDocType(doc, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: doc
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getDocType", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    np => doc%docExtras%docType

  end function getDocType

  function getImplementation(doc, ex)result(imp) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: doc
    type(DOMImplementation), pointer :: imp

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getImplementation", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    imp => doc%docExtras%implementation
    
  end function getImplementation

  function getDocumentElement(doc, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: doc
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getDocumentElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => doc%docExtras%documentElement

  end function getDocumentElement

  subroutine setDocumentElement(doc, np, ex)
    type(DOMException), intent(inout), optional :: ex
  ! Only for use by FoX, not exported through FoX_DOM interface
    type(Node), pointer :: doc
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setDocumentElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (np%nodeType/=ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setDocumentElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.associated(np%ownerDocument, doc)) then
      call throw_exception(WRONG_DOCUMENT_ERR, "setDocumentElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    doc%docExtras%documentElement => np

  end subroutine setDocumentElement

  ! Methods

  function createElement(doc, tagName, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: tagName
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkName(tagName, getXds(doc))) then
      call throw_exception(INVALID_CHARACTER_ERR, "createElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    np => createNode(doc, ELEMENT_NODE, tagName, "")
    np%attributes%ownerElement => np

    ! FIXME set namespaceURI and localName appropriately

    if (getGCstate(doc)) then
      np%inDocument = .false.
      call append(doc%docExtras%hangingnodes, np)
    else
      np%inDocument = .true.
    endif

  end function createElement
    
  function createDocumentFragment(doc, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createDocumentFragment", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    np => createNode(doc, DOCUMENT_FRAGMENT_NODE, "#document-fragment", "")
    if (getGCstate(doc)) then
      np%inDocument = .false.
      call append(doc%docExtras%hangingnodes, np)
    else
      np%inDocument = .true.
    endif

  end function createDocumentFragment

  function createTextNode(doc, data, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: data
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createTextNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(data, getXmlVersionEnum(doc))) then
      call throw_exception(FoX_INVALID_CHARACTER, "createTextNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => createNode(doc, TEXT_NODE, "#text", data)

    if (getGCstate(doc)) then
      np%inDocument = .false.
      call append(doc%docExtras%hangingnodes, np)
    else
      np%inDocument = .true.
    endif
   
  end function createTextNode

  function createComment(doc, data, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: data
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createComment", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(data, getXmlVersionEnum(doc))) then
      call throw_exception(FoX_INVALID_CHARACTER, "createComment", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (index(data,"--")>0) then   
      call throw_exception(FoX_INVALID_COMMENT, "createComment", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
  
    np => createNode(doc, COMMENT_NODE, "#comment", data)

    if (getGCstate(doc)) then
      np%inDocument = .false.
      call append(doc%docExtras%hangingnodes, np)
    else
      np%inDocument = .true.
    endif

  end function createComment

  function createCdataSection(doc, data, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: data
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createCdataSection", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(data, getXmlVersionEnum(doc))) then
      call throw_exception(FoX_INVALID_CHARACTER, "createCdataSection", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (index(data,"]]>")>0) then   
      call throw_exception(FoX_INVALID_CDATA_SECTION, "createCdataSection", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
  
    np => createNode(doc, CDATA_SECTION_NODE, "#cdata-section", data)

    if (getGCstate(doc)) then
      np%inDocument = .false.
      call append(doc%docExtras%hangingnodes, np)
    else
      np%inDocument = .true.
    endif
  
  end function createCdataSection

  function createProcessingInstruction(doc, target, data, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: target
    character(len=*), intent(in) :: data
    type(Node), pointer :: np


    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createProcessingInstruction", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkName(target, getXds(doc))) then
      call throw_exception(INVALID_CHARACTER_ERR, "createProcessingInstruction", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(data, getXmlVersionEnum(doc))) then
      call throw_exception(FoX_INVALID_CHARACTER, "createProcessingInstruction", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (index(data,"?>")>0) then   
      call throw_exception(FoX_INVALID_PI_DATA, "createProcessingInstruction", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => createNode(doc, PROCESSING_INSTRUCTION_NODE, target, data)

    if (getGCstate(doc)) then
      np%inDocument = .false.
      call append(doc%docExtras%hangingnodes, np)
    else
      np%inDocument = .true.
    endif

  end function createProcessingInstruction

  function createAttribute(doc, name, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: name
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkName(name, getXds(doc))) then
      call throw_exception(INVALID_CHARACTER_ERR, "createAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
  
    np => createNode(doc, ATTRIBUTE_NODE, name, "")
    np%namespaceURI => vs_str_alloc("")
    np%localname => vs_str_alloc(name)
    np%prefix => vs_str_alloc(name)

    if (getGCstate(doc)) then
      np%inDocument = .false.
      call append(doc%docExtras%hangingnodes, np)
    else
      np%inDocument = .true.
    endif
  
  end function createAttribute

  function createEntityReference(doc, name, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: name
    type(Node), pointer :: np

    type(Node), pointer :: ent, newNode
    integer :: i

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createEntityReference", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkName(name, getXds(doc))) then
      call throw_exception(INVALID_CHARACTER_ERR, "createEntityReference", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => createNode(doc, ENTITY_REFERENCE_NODE, name, "")
    if (getGCstate(doc)) then ! otherwise the parser will fill these nodes in itself
      ! FIXME except I think that gets switched off when creating atts sometimes ... need to check
      ent => getNamedItem(getEntities(getDocType(doc)), name)
      if (ent%illFormed) then
        call throw_exception(FoX_INVALID_ENTITY, "createEntityReference", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      endif
      if (associated(ent)) then
        do i = 0, getLength(getChildNodes(ent)) - 1
          newNode => appendChild(np, cloneNode(item(getChildNodes(ent), i), .true., ex))
          call setReadOnlyNode(newNode, .true.)
        enddo
      endif
      ! FIXME in case of recursive entity references?
    endif
    if (getGCstate(doc)) then
      np%inDocument = .false.
      call append(doc%docExtras%hangingnodes, np)
    else
      np%inDocument = .true.
    endif

  end function createEntityReference

  function createEmptyEntityReference(doc, name, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: name
    type(Node), pointer :: np

    type(Node), pointer :: ent
    integer :: i

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createEmptyEntityReference", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(name, getXmlVersionEnum(doc))) then
      call throw_exception(INVALID_CHARACTER_ERR, "createEmptyEntityReference", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkName(name, getXds(doc))) then
      call throw_exception(FoX_INVALID_XML_NAME, "createEmptyEntityReference", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => createNode(doc, ENTITY_REFERENCE_NODE, name, "")
    if (getGCstate(doc)) then
      np%inDocument = .false.
      call append(doc%docExtras%hangingnodes, np)
    else
      np%inDocument = .true.
    endif

  end function createEmptyEntityReference

  function getElementsByTagName(doc, tagName, name, ex)result(list) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in), optional :: tagName, name
    type(NodeList), pointer :: list

    type(NodeListPtr), pointer :: nll(:), temp_nll(:)
    type(Node), pointer :: arg, this
    logical :: doneChildren, doneAttributes, allElements
    integer :: i

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getElementsByTagName", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (doc%nodeType==DOCUMENT_NODE) then
      if (present(name).or..not.present(tagName)) then
        call throw_exception(FoX_INVALID_NODE, "getElementsByTagName", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      endif
    elseif (doc%nodeType==ELEMENT_NODE) then
      if (present(name).or..not.present(tagName)) then
        call throw_exception(FoX_INVALID_NODE, "getElementsByTagName", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      endif
    else      
      call throw_exception(FoX_INVALID_NODE, "getElementsByTagName", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (tagName=="*") &
      allElements = .true.

    if (doc%nodeType==DOCUMENT_NODE) then
      arg => getDocumentElement(doc)
    else
      arg => doc
    endif

    allocate(list)
    allocate(list%nodes(0))
    list%element => doc
    if (present(name)) list%nodeName => vs_str_alloc(name)
    if (present(tagName)) list%nodeName => vs_str_alloc(tagName)

    if (str_vs(list%nodeName)=="*") &
      allElements = .true.

    if (doc%nodeType==DOCUMENT_NODE) then
      nll => doc%docExtras%nodelists
    elseif (doc%nodeType==ELEMENT_NODE) then
      nll => doc%ownerDocument%docExtras%nodelists
    endif
    allocate(temp_nll(size(nll)+1))
    do i = 1, size(nll)
      temp_nll(i)%this => nll(i)%this
    enddo
    temp_nll(i)%this => list
    deallocate(nll)
    if (doc%nodeType==DOCUMENT_NODE) then
      doc%docExtras%nodelists => temp_nll
    elseif (doc%nodeType==ELEMENT_NODE) then
      doc%ownerDocument%docExtras%nodelists => temp_nll
    endif

    this => arg


    i = 0
    doneChildren = .false.
    doneAttributes = .false.
    do

      if (.not.(getNodeType(this)==ELEMENT_NODE.and.doneAttributes)) then
      if (.not.doneChildren) then

        if ((this%nodeType==ELEMENT_NODE) .and. &
          (allElements .or. str_vs(this%nodeName)==tagName)) then
          call append(list, this)
          doneAttributes = .true.
        endif


      else
        if (getNodeType(this)==ELEMENT_NODE) doneAttributes = .true.



      endif
      endif

      if (.not.doneChildren) then

        if (getNodeType(this)==ELEMENT_NODE.and..not.doneAttributes) then
          if (getLength(getAttributes(this))>0) then
                      this => item(getAttributes(this), 0)
          else
            doneAttributes = .true.
          endif
        elseif (hasChildNodes(this)) then
          this => getFirstChild(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          doneChildren = .true.
          doneAttributes = .false.
        endif

      else ! if doneChildren

        if (associated(this, arg)) exit
        if (getNodeType(this)==ATTRIBUTE_NODE) then
          if (i<getLength(getAttributes(getOwnerElement(this)))-1) then
            i = i + 1
            this => item(getAttributes(getOwnerElement(this)), i)
            doneChildren = .false.
          else
            i = 0
            this => getOwnerElement(this)
            doneAttributes = .true.
            doneChildren = .false.
          endif
        elseif (associated(getNextSibling(this))) then

          this => getNextSibling(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          this => getParentNode(this)
        endif
      endif

    enddo



  end function getElementsByTagName

  function importNode(doc , arg, deep , ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    type(Node), pointer :: arg
    logical :: deep
    type(Node), pointer :: np

    type(Node), pointer :: this, thatParent, new

    logical :: doneAttributes, doneChildren
    integer :: i
    print*,"importing Nodes"

    if (getNodeType(doc)/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "importNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (associated(doc, getOwnerDocument(arg))) then
      np => cloneNode(arg, deep)
      return
    endif

    this => arg
    thatParent => null()

    
    i = 0
    doneChildren = .false.
    doneAttributes = .false.
    do

      if (.not.(getNodeType(this)==ELEMENT_NODE.and.doneAttributes)) then
      if (.not.doneChildren) then



        new => null()
        select case (getNodeType(this))
        case (ELEMENT_NODE)
          if (.not.doneAttributes) then
            ! Are there any new prefixes or namespaces to be declared?
            ! FIXME
            new => createElement(doc, getTagName(this))
          endif
        case (ATTRIBUTE_NODE)
          if (associated(this, arg)) then
            new => createAttribute(doc, getName(this))
            call setSpecified(new, .true.)
          elseif (getSpecified(this)) then
            new => createAttribute(doc, getName(this))
            call setSpecified(new, .true.)
            ! elseif (thereIsADefault(getName(this)) FIXME
            ! new => createAttribute(doc, getName(this))
            ! call setValue(new, defaultValue)
            ! call setSpecified(new, .false.)
          else
            doneChildren = .true.
          endif
        case (TEXT_NODE)
          new => createTextNode(doc, getData(this))
        case (CDATA_SECTION_NODE)
          new => createCDataSection(doc, getData(this))
        case (ENTITY_REFERENCE_NODE)
          new => createEntityReference(doc, getNodeName(this))
          ! FIXME DOES ENTREF EXIST IN NEW DOC? Switch "this" appropriately & carry on cloning
        case (ENTITY_NODE)
          new => createEntity(doc, getName(this), getPublicId(this), getSystemId(this), getNotationName(this))
        case (PROCESSING_INSTRUCTION_NODE)
          new => createProcessingInstruction(doc, getTarget(this), getData(this))
        case (COMMENT_NODE)
          new => createEntityReference(doc, getNodeValue(this))
        case (DOCUMENT_NODE)
          call throw_exception(NOT_SUPPORTED_ERR, "importNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

        case (DOCUMENT_TYPE_NODE)
          call throw_exception(NOT_SUPPORTED_ERR, "importNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

        case (DOCUMENT_FRAGMENT_NODE)
          new => createDocumentFragment(doc)
        case (NOTATION_NODE)
          new => createNotation(doc, getName(this), getPublicId(this), getSystemId(this))
        end select
 
        if (associated(thatParent).and.associated(new)) print*, getNodeType(thatParent), getNodeType(new)

        if (.not.associated(thatParent)) then
          thatParent => new
        elseif (associated(new)) then
          if (getNodeType(this)==ATTRIBUTE_NODE) then
            new => setAttributeNode(thatParent, new)
          else
            new => appendChild(thatParent, new)
          endif
        endif

        if (.not.deep) then
          if (getNodeType(arg)/=ELEMENT_NODE.and.getNodeType(arg)/=ATTRIBUTE_NODE) return
        endif


      else
        if (getNodeType(this)==ELEMENT_NODE) doneAttributes = .true.



      endif
      endif

      if (.not.doneChildren) then

        if (getNodeType(this)==ELEMENT_NODE.and..not.doneAttributes) then
          if (getLength(getAttributes(this))>0) then
                      if (.not.associated(this, arg)) thatParent => getLastChild(thatParent)
            this => item(getAttributes(this), 0)
          else
            if (.not.deep) return
            doneAttributes = .true.
          endif
        elseif (hasChildNodes(this)) then
          if (.not.associated(this, arg)) then
            if (getNodeType(this)==ATTRIBUTE_NODE) then
              thatParent => item(getAttributes(thatParent), i)
            else
              thatParent => getLastChild(thatParent)
            endif
          endif
          this => getFirstChild(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          doneChildren = .true.
          doneAttributes = .false.
        endif

      else ! if doneChildren

        if (associated(this, arg)) exit
        if (getNodeType(this)==ATTRIBUTE_NODE) then
          if (i<getLength(getAttributes(getOwnerElement(this)))-1) then
            i = i + 1
            this => item(getAttributes(getOwnerElement(this)), i)
            doneChildren = .false.
          else
            i = 0
            if (associated(getParentNode(thatParent))) thatParent => getParentNode(thatParent)
            this => getOwnerElement(this)
            doneAttributes = .true.
            doneChildren = .false.
          endif
        elseif (associated(getNextSibling(this))) then

          this => getNextSibling(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          this => getParentNode(this)
          if (.not.associated(this, arg)) then
            if (getNodeType(this)==ATTRIBUTE_NODE) then
              thatParent => getOwnerElement(thatParent)
            else
              thatParent => getParentNode(thatParent)
            endif
          endif
        endif
      endif

    enddo



    np => thatParent
    print*,"importDone"

  end function importNode

  function createElementNS(doc, namespaceURI, qualifiedName, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: namespaceURI, qualifiedName
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createElementNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(qualifiedName, getXmlVersionEnum(doc))) then
      call throw_exception(INVALID_CHARACTER_ERR, "createElementNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkQName(qualifiedName, getXds(doc))) then
      call throw_exception(NAMESPACE_ERR, "createElementNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (prefixOfQName(qualifiedName)/="" &
     .and. namespaceURI=="") then
      call throw_exception(NAMESPACE_ERR, "createElementNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (prefixOfQName(qualifiedName)=="xml" .and. &
      namespaceURI/="http://www.w3.org/XML/1998/namespace") then
      call throw_exception(NAMESPACE_ERR, "createElementNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    ! FIXME is this all possible errors?
      ! what if prefix = "xmlns"? or other "xml"
    endif

    ! FIXME create a namespace node for XPath?

    np => createNode(doc, ELEMENT_NODE, qualifiedName, "")
    np%namespaceURI => vs_str_alloc(namespaceURI)
    np%prefix => vs_str_alloc(prefixOfQName(qualifiedname))
    np%localName => vs_str_alloc(localpartOfQName(qualifiedname))

    np%attributes%ownerElement => np

    if (getGCstate(doc)) then
      np%inDocument = .false.
      call append(doc%docExtras%hangingnodes, np)
    else
      np%inDocument = .true.
    endif

    ! FIXME updateNodeLists

  end function createElementNS
  
  function createAttributeNS(doc, namespaceURI, qualifiedname, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: namespaceURI, qualifiedName
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(qualifiedName, getXmlVersionEnum(doc))) then
      call throw_exception(INVALID_CHARACTER_ERR, "createAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkQName(qualifiedName, getXds(doc))) then
      call throw_exception(NAMESPACE_ERR, "createAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (prefixOfQName(qualifiedName)/="" &
     .and. namespaceURI=="") then
      call throw_exception(NAMESPACE_ERR, "createAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (prefixOfQName(qualifiedName)=="xml" .and. &
      namespaceURI/="http://www.w3.org/XML/1998/namespace") then
      call throw_exception(NAMESPACE_ERR, "createAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    ! FIXME is this all possible errors?
      ! what if prefix = "xmlns"? or other "xml"
    endif
  
    np => createNode(doc, ATTRIBUTE_NODE, qualifiedName, "")
    np%namespaceURI => vs_str_alloc(namespaceURI)
    np%localname => vs_str_alloc(localPartofQName(qualifiedname))
    np%prefix => vs_str_alloc(PrefixofQName(qualifiedname))

    if (getGCstate(doc)) then
      np%inDocument = .false.
      call append(doc%docExtras%hangingnodes, np)
    else
      np%inDocument = .true.
    endif

  end function createAttributeNS

  function getElementsByTagNameNS(doc, namespaceURI, localName, ex)result(list) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: namespaceURI, localName
    type(NodeList), pointer :: list

    type(NodeListPtr), pointer :: nll(:), temp_nll(:)
    type(Node), pointer :: this, arg
    logical :: doneChildren, doneAttributes, allLocalNames, allNameSpaces
    integer :: i

    if (.not.associated(doc)) then
      call throw_exception(FoX_NODE_IS_NULL, "getElementsByTagNameNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (doc%nodeType/=DOCUMENT_NODE.or.doc%nodeType/=ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getElementsByTagNameNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (namespaceURI=="*") &
      allNameSpaces = .true.
    if (localName=="*") &
      allLocalNames = .true.

    if (doc%nodeType==DOCUMENT_NODE) then
      arg => getDocumentElement(doc)
    else
      arg => doc
    endif

    allocate(list)
    allocate(list%nodes(0))
    list%element => doc
    list%localName => vs_str_alloc(localName)
    list%namespaceURI => vs_str_alloc(namespaceURI)

    if (doc%nodeType==DOCUMENT_NODE) then
      nll => doc%docExtras%nodelists
    elseif (doc%nodeType==ELEMENT_NODE) then
      nll => doc%ownerDocument%docExtras%nodelists
    endif
    allocate(temp_nll(size(nll)+1))
    do i = 1, size(nll)
      temp_nll(i)%this => nll(i)%this
    enddo
    temp_nll(i)%this => list
    deallocate(nll)
    if (doc%nodeType==DOCUMENT_NODE) then
      doc%docExtras%nodelists => temp_nll
    elseif (doc%nodeType==ELEMENT_NODE) then
      doc%ownerDocument%docExtras%nodelists => temp_nll
    endif

    this => arg


    i = 0
    doneChildren = .false.
    doneAttributes = .false.
    do

      if (.not.(getNodeType(this)==ELEMENT_NODE.and.doneAttributes)) then
      if (.not.doneChildren) then

      if ((this%nodeType==ELEMENT_NODE) &
        .and. (allNameSpaces .or. str_vs(arg%namespaceURI)==namespaceURI) &
        .and. (allLocalNames .or. str_vs(arg%localName)==localName)) then
        call append(list, this)
          doneAttributes = .true.
        endif


      else
        if (getNodeType(this)==ELEMENT_NODE) doneAttributes = .true.



      endif
      endif

      if (.not.doneChildren) then

        if (getNodeType(this)==ELEMENT_NODE.and..not.doneAttributes) then
          if (getLength(getAttributes(this))>0) then
                      this => item(getAttributes(this), 0)
          else
            doneAttributes = .true.
          endif
        elseif (hasChildNodes(this)) then
          this => getFirstChild(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          doneChildren = .true.
          doneAttributes = .false.
        endif

      else ! if doneChildren

        if (associated(this, arg)) exit
        if (getNodeType(this)==ATTRIBUTE_NODE) then
          if (i<getLength(getAttributes(getOwnerElement(this)))-1) then
            i = i + 1
            this => item(getAttributes(getOwnerElement(this)), i)
            doneChildren = .false.
          else
            i = 0
            this => getOwnerElement(this)
            doneAttributes = .true.
            doneChildren = .false.
          endif
        elseif (associated(getNextSibling(this))) then

          this => getNextSibling(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          this => getParentNode(this)
        endif
      endif

    enddo



  end function getElementsByTagNameNS


  function getElementById(doc, elementId, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: elementId
    type(Node), pointer :: np

    type(Node), pointer :: this, arg
    type(NamedNodeMap), pointer :: nnm
    integer :: i
    logical :: doneChildren, doneAttributes

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getElementById", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    arg => getDocumentElement(doc)

    np => null()

    i = 0
    doneChildren = .false.
    doneAttributes = .false.
    do

      if (.not.(getNodeType(this)==ELEMENT_NODE.and.doneAttributes)) then
      if (.not.doneChildren) then

      if (this%nodeType==ATTRIBUTE_NODE)  then
        if (getIsId(this).and.getName(this)==elementId) then
          np => this
          return
        endif
      endif


      else
        if (getNodeType(this)==ELEMENT_NODE) doneAttributes = .true.



      endif
      endif

      if (.not.doneChildren) then

        if (getNodeType(this)==ELEMENT_NODE.and..not.doneAttributes) then
          if (getLength(getAttributes(this))>0) then
                      this => item(getAttributes(this), 0)
          else
            doneAttributes = .true.
          endif
        elseif (hasChildNodes(this)) then
          this => getFirstChild(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          doneChildren = .true.
          doneAttributes = .false.
        endif

      else ! if doneChildren

        if (associated(this, arg)) exit
        if (getNodeType(this)==ATTRIBUTE_NODE) then
          if (i<getLength(getAttributes(getOwnerElement(this)))-1) then
            i = i + 1
            this => item(getAttributes(getOwnerElement(this)), i)
            doneChildren = .false.
          else
            i = 0
            this => getOwnerElement(this)
            doneAttributes = .true.
            doneChildren = .false.
          endif
        elseif (associated(getNextSibling(this))) then

          this => getNextSibling(this)
          doneChildren = .false.
          doneAttributes = .false.
        else
          this => getParentNode(this)
        endif
      endif

    enddo



    np => null()

  end function getElementById

!  function getInputEncoding
!  function getXmlEncoding
!  function getXmlStandalone
!  function setXmlStandalone


  function getXmlVersion(doc, ex)result(s) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=3) :: s

    if (getXmlVersionEnum(doc)==XML1_0) then
      s = "1.0"
    elseif (getXmlVersionEnum(doc)==XML1_1) then
      s = "1.1"
    else
      s = "XXX"
    endif

  end function getXmlVersion

  subroutine setXmlVersion(doc, s, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*) :: s

    if (s=="1.0") then
      doc%docExtras%xds%xml_version = XML1_0
    elseif (s=="1.1") then
      doc%docExtras%xds%xml_version = XML1_1
    else
      call throw_exception(NOT_SUPPORTED_ERR, "setXmlVersion", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

  end subroutine setXmlVersion


!  function getStrictErrorChecking
!  function setStrictErrorChecking
!  function getDocumentURI
!  function setDocumentURI

  ! Internal function, not part of API

  function createEntity(doc, name, publicId, systemId, notationName) result(np)
    type(Node), pointer :: doc
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: publicId
    character(len=*), intent(in) :: systemId
    character(len=*), intent(in) :: notationName
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      print*,"internal error in createEntity"
      stop
    endif

    np => createNode(doc, ENTITY_NODE, name, "")
    np%publicId => vs_str_alloc(publicId)
    np%systemId => vs_str_alloc(systemId)
    np%notationName => vs_str_alloc(notationName)

  end function createEntity

  function createNotation(doc, name, publicId, systemId) result(np)
    type(Node), pointer :: doc
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: publicId
    character(len=*), intent(in) :: systemId
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      print*,"internal error in createEntity"
      stop
    endif

    np => createNode(doc, NOTATION_NODE, name, "")
    np%publicId => vs_str_alloc(publicId)
    np%systemId => vs_str_alloc(systemId)
    
  end function createNotation


  function getXmlVersionEnum(doc, ex)result(n) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    integer :: n

    n = doc%docExtras%xds%xml_version

  end function getXmlVersionEnum

  function getXds(doc, ex)result(xds) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    type(xml_doc_state) :: xds

    xds = doc%docExtras%xds

  end function getXds


  function getGCstate(doc, ex)result(b) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    logical :: b

    b = doc%docExtras%xds%building

  end function getGCstate

  subroutine setGCstate(doc, b, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    logical, intent(in) :: b

    doc%docExtras%xds%building = b

  end subroutine setGCstate



!  function getName(docType) result(c) See m_dom_common

  function getEntities(arg, ex)result(nnp) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(NamedNodeMap), pointer :: nnp

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getEntities", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (arg%nodeType/=DOCUMENT_TYPE_NODE) then
       call throw_exception(FoX_INVALID_NODE, "getEntities", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    nnp => arg%entities
  end function getEntities

  function getNotations(arg, ex)result(nnp) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(NamedNodeMap), pointer :: nnp

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getNotations", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (arg%nodeType/=DOCUMENT_TYPE_NODE) then
       call throw_exception(FoX_INVALID_NODE, "getNotations", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    nnp => arg%notations
  end function getNotations


!  function getPublicId(docType) result(c) See m_dom_common


!  function getSystemId(docType) result(c) See m_dom_common

    pure function getInternalSubset_len(arg, p) result(n)
    type(Node), intent(in) :: arg
    logical, intent(in) :: p
    integer :: n

    if (p) then 
      n = size(arg%internalSubset)
    else
      n = 0
    endif
  end function getInternalSubset_len

  function getInternalSubset(arg, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=getInternalSubset_len(arg, associated(arg))) :: c

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getInternalSubset", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (arg%nodeType/=DOCUMENT_TYPE_NODE) then
       call throw_exception(FoX_INVALID_NODE, "getInternalSubset", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    c = str_vs(arg%internalSubset)
  end function getInternalSubset


  subroutine setDocType(arg, name, publicId, systemId, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=*), intent(in) :: name
    character(len=*), intent(in), optional :: publicId
    character(len=*), intent(in), optional :: systemId

    ! FIXME optional args

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "setDocType", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (arg%nodeType/=DOCUMENT_TYPE_NODE) then
       call throw_exception(FoX_INVALID_NODE, "setDocType", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    deallocate(arg%nodeName)
    arg%nodeName => vs_str_alloc(name)
    if (present(publicId)) then
      deallocate(arg%publicId)
      arg%publicId => vs_str_alloc(publicId)
    endif
    if (present(systemId)) then
      deallocate(arg%systemId)
      arg%systemId => vs_str_alloc(systemId)
    endif

  end subroutine setDocType



  function getTagName(element, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: element   
    character(len=size(element%nodeName)) :: c

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getTagName", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    c = str_vs(element%nodeName)    
     
  end function getTagName

    
  function getAttribute(element, name, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    character(len=*), intent(in) :: name
    character(len=getNamedItem_Value_length(element%attributes, name)) :: c

    type(Node), pointer :: nn

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    c = ""  ! as per specs, if not found
    c = getNamedItem_Value(getAttributes(element), name)

    ! FIXME do we need to catch the exception above if it doesnt exist?
        
  end function getAttribute


  subroutine setAttribute(element, name, value, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: value

    type(Node), pointer :: nn, dummy
    logical :: quickFix

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif


      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(name, getXmlVersionEnum(getOwnerDocument(element)))) then
      call throw_exception(INVALID_CHARACTER_ERR, "setAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkName(value, getXds(getOwnerDocument(element)))) then
      call throw_exception(FoX_INVALID_XML_NAME, "setAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(value, getXmlVersionEnum(getOwnerDocument(element)))) then
      call throw_exception(FoX_INVALID_CHARACTER, "setAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    quickFix = getGCstate(getOwnerDocument(element)) &
      .and. element%inDocument

    if (quickFix) call setGCstate(getOwnerDocument(element), .false.)
    ! then the created attribute is going straight into the document,
    ! so dont faff with hanging-node lists.

    nn => createAttribute(element%ownerDocument, name)
    call setValue(nn, value)
    dummy => setNamedItem(getAttributes(element), nn)
    if (associated(dummy)) then
      if (getGCstate(getOwnerDocument(element)).and..not.dummy%inDocument) &
        call putNodesInDocument(getOwnerDocument(element), dummy) 
      ! ... so that dummy & children are removed from hangingNodes list.
      call destroyAllNodesRecursively(dummy)
      call destroyNode(dummy)
    endif
    nn%ownerElement => element

    if (quickFix) call setGCstate(getOwnerDocument(element), .true.)

  end subroutine setAttribute


  subroutine removeAttribute(element, name, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    character(len=*), intent(in) :: name

    type(Node), pointer :: dummy

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "removeAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    if (element%inDocument) &
      call setGCstate(getOwnerDocument(element), .false.)

    dummy => removeNamedItem(getAttributes(element), name)
    print*,"DESTROYING ATTRIBUTE:"
    ! FIXME need to remove dummy from hangingnodeslist
    call destroyAllNodesRecursively(dummy)
    call destroyNode(dummy)

    if (element%inDocument) &
      call setGCstate(element%ownerDocument, .true.)

  ! FIXME recreate a default value if there is one
     
  end subroutine removeAttribute


  function getAttributeNode(element, name, ex)result(attr) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    character(len=*), intent(in) :: name
    type(Node), pointer :: attr

    attr => null()     ! as per specs, if not foundo

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getAttributeNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    attr => getNamedItem(getAttributes(element), name)

    ! FIXME catch and throw away exception

  end function getAttributeNode
  

  function setAttributeNode(element, newattr, ex)result(attr) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    type(Node), pointer :: newattr
    type(Node), pointer :: attr
    type(Node), pointer :: dummy

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setAttributeNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.associated(element%ownerDocument, newattr%ownerDocument)) then
      call throw_exception(WRONG_DOCUMENT_ERR, "setAttributeNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (element%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setAttributeNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (associated(newattr%ownerElement)) then
      call throw_exception(INUSE_ATTRIBUTE_ERR, "setAttributeNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    ! this checks if attribute exists already
    ! It also does any adding/removing of hangingnodes
    dummy => setNamedItem(getAttributes(element), newattr, ex)
    newattr%ownerElement => element
    attr => newattr

  end function setAttributeNode


  function removeAttributeNode(element, oldattr, ex)result(attr) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    type(Node), pointer :: oldattr
    type(Node), pointer :: attr

    integer :: i

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "removeAttributeNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (element%readonly) then
      call throw_exception(WRONG_DOCUMENT_ERR, "removeAttributeNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    do i = 1, element%attributes%length
      if (associated(element%attributes%nodes(i)%this, oldattr)) then
        attr => removeNamedItem(getAttributes(element), str_vs(oldattr%nodeName))
        return
      endif
    enddo

    call throw_exception(NOT_FOUND_ERR, "removeAttributeNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif


    attr%ownerElement => null()

  end function removeAttributeNode


!  function getElementsByTagName - see m_dom_document


  function getAttributeNS(element, namespaceURI, localName, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    character(len= &
      getNamedItemNS_Value_length(element%attributes, namespaceURI, localName)) :: c

    type(Node), pointer :: nn

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    c = ""  ! as per specs, if not found Not sure ahout this FIXME
    c = getNamedItemNS_Value(getAttributes(element), namespaceURI, localName)

    ! FIXME dont need both above
        
  end function getAttributeNS


  subroutine setAttributeNS(element, namespaceURI, qualifiedname, value, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: qualifiedName
    character(len=*), intent(in) :: value

    type(Node), pointer :: nn, dummy
    logical :: quickfix

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(qualifiedname, getXmlVersionEnum(getOwnerDocument(element)))) then
      call throw_exception(INVALID_CHARACTER_ERR, "setAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (element%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkQName(qualifiedname, getXds(getOwnerDocument(element)))) then
      call throw_exception(NAMESPACE_ERR, "setAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (prefixOfQName(qualifiedName)/="" &
     .and. namespaceURI=="") then
      call throw_exception(NAMESPACE_ERR, "setAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (prefixOfQName(qualifiedName)=="xml" .and. & 
      namespaceURI/="http://www.w3.org/XML/1998/namespace") then
      call throw_exception(NAMESPACE_ERR, "setAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    ! FIXME is this all possible errors? 
      ! what if prefix = "xmlns"? or other "xml"
    endif

! FIXME what if namespace is undeclared ... will be recreated on serialization,
! but we might need a new namespace node here for xpath ...

    quickFix = getGCstate(getOwnerDocument(element)) &
      .and. element%inDocument

    if (quickFix) call setGCstate(getOwnerDocument(element), .false.)
    ! then the created attribute is going straight into the document,
    ! so dont faff with hanging-node lists.

    nn => createAttributeNS(element%ownerDocument, namespaceURI, qualifiedname)
    call setValue(nn, value)
    if (associated(dummy)) then
      if (getGCstate(getOwnerDocument(element)).and..not.dummy%inDocument) &
        call putNodesInDocument(getOwnerDocument(element), dummy) 
      ! ... so that dummy & children are removed from hangingNodes list.
      call destroyAllNodesRecursively(dummy)
      call destroyNode(dummy)
    endif

    dummy => setNamedItemNS(getAttributes(element), nn)
    nn%ownerElement => element

    if (quickFix) call setGCstate(getOwnerDocument(element), .true.)

    !FIXME catch exception

  end subroutine setAttributeNS


  subroutine removeAttributeNS(element, namespaceURI, localName, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName

    type(Node), pointer :: dummy

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "removeAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (element%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "removeAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    dummy => removeNamedItemNS(getAttributes(element), namespaceURI, localName)

    call destroyAttribute(dummy)
     
  end subroutine removeAttributeNS


  function getAttributeNodeNS(element, namespaceURI, localName, ex)result(attr) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    type(Node), pointer :: attr

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getAttributeNodeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    attr => null()     ! as per specs, if not found
    attr => getNamedItemNS(getAttributes(element), namespaceURI, localname)

  end function getAttributeNodeNS
  

  function setAttributeNodeNS(element, newattr, ex)result(attr) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    type(Node), pointer :: newattr
    type(Node), pointer :: attr
    type(Node), pointer :: dummy

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setAttributeNodeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.associated(element%ownerDocument, newattr%ownerDocument)) then
      call throw_exception(WRONG_DOCUMENT_ERR, "setAttributeNodeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (element%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setAttributeNodeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (associated(newattr%ownerElement)) then
      call throw_exception(INUSE_ATTRIBUTE_ERR, "setAttributeNodeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    ! this checks if attribute exists already, and does hangingnodes
    dummy => setNamedItemNS(getAttributes(element), newattr)
    newattr%ownerElement => element
    attr => newattr

  end function setAttributeNodeNS


  function removeAttributeNodeNS(element, oldattr, ex)result(attr) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    type(Node), pointer :: oldattr
    type(Node), pointer :: attr

    integer :: i

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "removeAttributeNodeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (element%readonly) then
      call throw_exception(WRONG_DOCUMENT_ERR, "removeAttributeNodeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    do i = 1, element%attributes%length
      if (associated(item(getAttributes(element), i-1), oldattr)) then
        attr => removeNamedItemNS(getAttributes(element), &
          str_vs(oldattr%namespaceURI), str_vs(oldattr%localName))
        return
      endif
    enddo

    call throw_exception(NOT_FOUND_ERR, "removeAttributeNodeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif


    attr%ownerElement => null()

  end function removeAttributeNodeNS


!  function getElementsByTagNameNS - see m_dom_document


  function hasAttribute(element, name, ex)result(p) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: element
    character(len=*), intent(in) :: name
    logical :: p

    integer :: i
 
   if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "hasAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    p = .false.
    do i = 1, element%attributes%length
      if (str_vs(element%attributes%nodes(i)%this%nodeName)==name) then
        p = .true.
        exit
      endif
    enddo

  end function hasAttribute


  function hasAttributeNS(element, namespaceURI, localName, ex)result(p) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: element
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    logical :: p

    integer :: i

 
   if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "hasAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    p = .false.
    do i = 1, element%attributes%length
      if (str_vs(element%attributes%nodes(i)%this%namespaceURI)==namespaceURI &
        .and. str_vs(element%attributes%nodes(i)%this%localName)==localName) then
        p = .true.
        exit
      endif
    enddo

  end function hasAttributeNS

! setIdAttribute
! setIdAttributeNS
! setIdAttributeNode


  
  ! function getName(attribute) result(c) See m_dom_common

! NB All functions manipulating attributes play with the nodelist
! directly rather than through helper functions.
! This is so that getValue_length can be pure,  and the nodeList
! can be explicitly kept up to dat.


  function getSpecified(arg, ex)result(p) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    logical :: p

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getSpecified", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (getNodeType(arg)/=ATTRIBUTE_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getSpecified", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    p = arg%specified
  end function getSpecified

  subroutine setSpecified(arg, p, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    logical, intent(in) :: p

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "setSpecified", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (getNodeType(arg)/=ATTRIBUTE_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setSpecified", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    arg%specified = p
  end subroutine setSpecified
    
  pure function getValue_len(arg, p) result(n)
    type(Node), intent(in) :: arg
    logical, intent(in) :: p
    integer :: n

    integer :: i

    n = 0 
    if (.not.p) return

    do i = 1, arg%childNodes%length
      if (arg%childNodes%nodes(i)%this%nodeType==TEXT_NODE) then
        n = n + size(arg%childNodes%nodes(i)%this%nodeValue)
      else
    ! FIXME get entity length
      endif
    enddo

  end function getValue_len

  function getValue_DOM(arg, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=getValue_len(arg, associated(arg))) :: c 

    integer :: i, n

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getValue_DOM", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (getNodeType(arg)/=ATTRIBUTE_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getValue_DOM", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    n = 1
    do i = 1, arg%childNodes%length
      if (arg%childNodes%nodes(i)%this%nodeType==TEXT_NODE) then
        c(n:n+size(arg%childNodes%nodes(i)%this%nodeValue)-1) = &
          str_vs(arg%childNodes%nodes(i)%this%nodeValue)
      else
    ! FIXME get entity value
      endif
    enddo

  end function getValue_DOM


  subroutine setValue(arg, value, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=*), intent(in) :: value

    type(Node), pointer :: np
    integer :: i

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "setValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (getNodeType(arg)/=ATTRIBUTE_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(value, getXmlVersionEnum(getOwnerDocument(arg)))) then
      call throw_exception(FoX_INVALID_CHARACTER, "setValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    do i = 1, getLength(getChildNodes(arg))
      call destroyNode(arg%childNodes%nodes(i)%this)
    enddo
    deallocate(arg%childNodes%nodes)
    allocate(arg%childNodes%nodes(0))
    arg%childNodes%length = 0
    arg%firstChild => null()
    arg%lastChild => null()
    np => createTextNode(getOwnerDocument(arg), value)
    np => appendChild(arg, np)

  end subroutine setValue


  function getOwnerElement(arg, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: np

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getOwnerElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (getNodeType(arg) /= ATTRIBUTE_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getOwnerElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => arg%ownerElement

  end function getOwnerElement

  function getIsId(arg, ex)result(p) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    logical :: p

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getIsId", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (getNodeType(arg) /= ATTRIBUTE_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getIsId", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    p = arg%isId

  end function getIsId

  subroutine setIsId(arg, p, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    logical, intent(in) :: p

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "setIsId", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (getNodeType(arg) /= ATTRIBUTE_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setIsId", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    arg%isId = p

  end subroutine setIsId



  pure function isCharData(nodeType) result(p)
    integer, intent(in) :: nodeType
    logical :: p

    p = (nodeType == TEXT_NODE .or. &
      nodeType == COMMENT_NODE .or. &
      nodeType == CDATA_SECTION_NODE)
  end function isCharData


  function getLength_characterdata(arg, ex)result(n) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    integer :: n

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getLength_characterdata", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (isCharData(arg%nodeType)) then
       n = size(arg%nodeValue)
    else
       n = 0 ! FIXME error
    endif
  end function getLength_characterdata


  function subStringData(arg, offset, count, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    integer, intent(in) :: offset
    integer, intent(in) :: count
    character(len=count) :: c

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "subStringData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not.isCharData(arg%nodeType)) then
      call throw_exception(FoX_INVALID_NODE, "subStringData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (offset<0.or.offset>size(arg%nodeValue).or.count<0) then
      call throw_exception(INDEX_SIZE_ERR, "subStringData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (offset+count>size(arg%nodeValue)) then
      c = str_vs(arg%nodeValue(offset+1:))
    else
      c = str_vs(arg%nodeValue(offset+1:offset+count))
    endif

  end function subStringData


  subroutine appendData(arg, data, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=*), intent(in) :: data
    
    character, pointer :: tmp(:)

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "appendData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not.isCharData(arg%nodeType)) then
      call throw_exception(FoX_INVALID_NODE, "appendData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "appendData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not.checkChars(data, getXmlVersionEnum(getOwnerDocument(arg)))) then
      call throw_exception(FoX_INVALID_CHARACTER, "appendData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    tmp => arg%nodeValue
    arg%nodeValue => vs_str_alloc(str_vs(tmp)//data)
    deallocate(tmp)

    ! We have to do these checks *after* appending data in case offending string
    ! spans old & new data
    if (arg%nodeType==COMMENT_NODE .and. index(str_vs(arg%nodeValue),"--")>0) then
      call throw_exception(FoX_INVALID_COMMENT, "appendData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%nodeType==CDATA_SECTION_NODE .and. index(str_vs(arg%nodeValue), "]]>")>0) then
      call throw_exception(FoX_INVALID_CDATA_SECTION, "appendData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

  end subroutine appendData
  

  subroutine insertData(arg, offset, data, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    integer, intent(in) :: offset
    character(len=*), intent(in) :: data

    character, pointer :: tmp(:)

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "insertData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not.isCharData(arg%nodeType)) then
      call throw_exception(FoX_INVALID_NODE, "insertData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "insertData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (offset<0.or.offset>size(arg%nodeValue)) then
      call throw_exception(INDEX_SIZE_ERR, "insertData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not.checkChars(data, getXmlVersionEnum(getOwnerDocument(arg)))) then
      call throw_exception(FoX_INVALID_CHARACTER, "insertData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    tmp => arg%nodeValue
    arg%nodeValue => vs_str_alloc(str_vs(tmp(:offset))//data//str_vs(tmp(offset+1:)))
    deallocate(tmp)

    ! We have to do these checks *after* appending data in case offending string
    ! spans old & new data
    if (arg%nodeType==COMMENT_NODE .and. index(str_vs(arg%nodeValue),"--")>0) then
      call throw_exception(FoX_INVALID_COMMENT, "insertData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%nodeType==CDATA_SECTION_NODE .and. index(str_vs(arg%nodeValue), "]]>")>0) then
      call throw_exception(FoX_INVALID_CDATA_SECTION, "insertData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

  end subroutine insertData


  subroutine deleteData(arg, offset, count, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    integer, intent(in) :: offset
    integer, intent(in) :: count

    character, pointer :: tmp(:)

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "deleteData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not.isCharData(arg%nodeType)) then
      call throw_exception(FoX_INVALID_NODE, "deleteData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "deleteData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (offset<0.or.offset>size(arg%nodeValue).or.count<0) then
      call throw_exception(INDEX_SIZE_ERR, "deleteData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    tmp => arg%nodeValue
    arg%nodeValue => vs_str_alloc(str_vs(tmp(:offset))//str_vs(tmp(offset+count+1:)))
    deallocate(tmp)

  end subroutine deleteData


  subroutine replaceData(arg, offset, count, data, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    integer, intent(in) :: offset
    integer, intent(in) :: count
    character(len=*), intent(in) :: data
    
    character, pointer :: tmp(:)

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "replaceData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not.isCharData(arg%nodeType)) then
      call throw_exception(FoX_INVALID_NODE, "replaceData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "replaceData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (offset<0.or.offset>size(arg%nodeValue).or.count<0) then
      call throw_exception(INDEX_SIZE_ERR, "replaceData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not.checkChars(data, getXmlVersionEnum(getOwnerDocument(arg)))) then
      call throw_exception(FoX_INVALID_CHARACTER, "replaceData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    tmp => arg%nodeValue
    if (offset+count <= size(arg%nodeValue)) then
      arg%nodeValue => vs_str_alloc(str_vs(tmp(:offset))//data//str_vs(tmp(offset+count+1:)))
    else
      arg%nodeValue => vs_str_alloc(str_vs(tmp(:offset))//data)
    endif
    deallocate(tmp)

    ! We have to do these checks *after* appending data in case offending string
    ! spans old & new data
    if (arg%nodeType==COMMENT_NODE .and. index(str_vs(arg%nodeValue),"--")>0) then
      call throw_exception(FoX_INVALID_COMMENT, "replaceData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%nodeType==CDATA_SECTION_NODE .and. index(str_vs(arg%nodeValue), "]]>")>0) then
      call throw_exception(FoX_INVALID_CDATA_SECTION, "replaceData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

  end subroutine replaceData
 


  subroutine setIllFormed(arg, p, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    logical, intent(in) :: p
    
    arg%illFormed = p
  end subroutine setIllFormed    

  function getNotationName(arg, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: arg
    character(len=size(arg%notationName)) :: c

    if (arg%nodeType/=ENTITY_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getNotationName", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    c = str_vs(arg%notationName)

  end function getNotationName



  function getTarget(arg, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: arg
    character(len=size(arg%nodeName)) :: c

    if (arg%nodeType/=PROCESSING_INSTRUCTION_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getTarget", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    c = str_vs(arg%nodeName)
  end function getTarget



  pure function isTextNode(nodeType) result(p)
    integer, intent(in) :: nodeType
    logical :: p

    p = (nodeType==TEXT_NODE.or.nodeType==CDATA_SECTION_NODE)
  end function isTextNode

  function splitText(arg, offset, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    integer, intent(in) :: offset

    type(Node), pointer :: np

    character, pointer :: tmp(:)

    if (.not.isTextNode(arg%nodeType)) then
      call throw_exception(FoX_INVALID_NODE, "splitText", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "splitText", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (offset<0 .or. offset>size(arg%nodeValue)) then
      call throw_exception(INDEX_SIZE_ERR, "splitText", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    tmp => arg%nodeValue
    if (arg%nodeType==TEXT_NODE) then
      np => createTextNode(arg%ownerDocument, str_vs(tmp(offset+1:)))
    elseif (arg%nodeType==CDATA_SECTION_NODE) then
      np => createCdataSection(arg%ownerDocument, str_vs(tmp(offset+1:)))
    endif
    arg%nodeValue => vs_str_alloc(str_vs(tmp(:offset)))     
    deallocate(tmp)
    if (associated(arg%parentNode)) then
      if (associated(arg%nextSibling)) then
        np => insertBefore(arg%parentNode, np, arg%nextSibling)
      else
        np => appendChild(arg%parentNode, np)
      endif
    endif

  end function splitText
                                     


  pure function getData_len(arg, p) result(n)
    type(Node), intent(in) :: arg
    logical, intent(in) :: p
    integer :: n

    if (p) then 
      n = size(arg%nodeValue)
    else
      n = 0
    endif
  end function getData_len
  
  function getData(arg, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=getData_len(arg, associated(arg))) :: c

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (arg%nodeType==TEXT_NODE .or. &
      arg%nodeType==COMMENT_NODE .or. &
      arg%nodeType==CDATA_SECTION_NODE .or. &
      arg%nodeType==PROCESSING_INSTRUCTION_NODE) then
       c = str_vs(arg%nodeValue)
    else
       call throw_exception(FoX_INVALID_NODE, "getData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
  end function getData


  subroutine setData(arg, data, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=*) :: data

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "setData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (arg%nodeType==TEXT_NODE .or. &
      arg%nodeType==COMMENT_NODE .or. &
      arg%nodeType==CDATA_SECTION_NODE .or. &
      arg%nodeType==PROCESSING_INSTRUCTION_NODE) then
      if (arg%readonly) then
        call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      endif
      deallocate(arg%nodeValue)
      arg%nodeValue => vs_str_alloc(data)
    else
       call throw_exception(FoX_INVALID_NODE, "setData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
  end subroutine setData

  pure function getName_len(arg, p) result(n)
    type(Node), intent(in) :: arg
    logical, intent(in) :: p
    integer :: n

    if (p) then 
      n = size(arg%nodeName)
    else
      n = 0
    endif
  end function getName_len
  
  function getName(arg, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(getName_len(arg, associated(arg))) :: c

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getName", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    if (arg%nodeType/=ATTRIBUTE_NODE .and. &
      arg%nodeType/=DOCUMENT_TYPE_NODE) then
       call throw_exception(FoX_INVALID_NODE, "getName", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    c = str_vs(arg%nodeName)
    
  end function getName

  pure function getPublicId_len(arg, p) result(n)
    type(Node), intent(in) :: arg
    logical, intent(in) :: p
    integer :: n

    if (p) then 
      n = size(arg%publicId)
    else
      n = 0
    endif
  end function getPublicId_len

  function getPublicId(arg, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=getPublicId_len(arg, associated(arg))) :: c

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getPublicId", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (arg%nodeType/=DOCUMENT_TYPE_NODE .and. &
      arg%nodeType/=NOTATION_NODE .and. &
      arg%nodeType/=ENTITY_NODE) then
       call throw_exception(FoX_INVALID_NODE, "getPublicId", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    c = str_vs(arg%publicId)

  end function getPublicId

  pure function getSystemId_len(arg, p) result(n)
    type(Node), intent(in) :: arg
    logical, intent(in) :: p
    integer :: n

    if (p) then 
      n = size(arg%systemId)
    else
      n = 0
    endif
  end function getSystemId_len

  function getSystemId(arg, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=getSystemId_len(arg, associated(arg))) :: c

    if (.not.associated(arg)) then
      call throw_exception(FoX_NODE_IS_NULL, "getSystemId", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (arg%nodeType/=DOCUMENT_TYPE_NODE .and. &
      arg%nodeType/=NOTATION_NODE .and. &
      arg%nodeType/=ENTITY_NODE) then
       call throw_exception(FoX_INVALID_NODE, "getSystemId", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    c = str_vs(arg%systemId)

  end function getSystemId


end module m_dom_dom
