
 
 
! ATTENTION
! THIS FILE IS AUTOGENERATED
! DO NOT EDIT DIRECTLY
! EDIT FILES dom/m_dom_***.m4
!
module m_dom_dom


  use m_common_array_str, only: vs_str_alloc
  use m_common_struct, only: xml_doc_state, destroy_xml_doc_state



  use m_common_array_str, only: str_vs, vs_str_alloc
  use m_dom_error, only: DOMException, throw_exception, is_in_error, &
    NO_MODIFICATION_ALLOWED_ERR, NOT_FOUND_ERR, HIERARCHY_REQUEST_ERR, &
    WRONG_DOCUMENT_ERR, dom_error



  use m_common_array_str, only: str_vs
  use m_dom_error, only: INUSE_ATTRIBUTE_ERR



  use m_common_array_str, only: str_vs, vs_str_alloc
  use m_common_charset, only: checkChars, XML1_0

  use m_dom_error, only: DOMException, throw_exception, is_in_error, &
    INVALID_CHARACTER_ERR, NAMESPACE_ERR, FoX_INVALID_PUBLIC_ID, FoX_INVALID_SYSTEM_ID
  use m_common_namecheck, only: checkName, checkPublicId, checkSystemId
  use m_common_string, only: toLower
  use m_common_struct, only: init_xml_doc_state, destroy_xml_doc_state



  use m_common_array_str, only: str_vs, vs_str_alloc
  use m_common_charset, only: XML1_0, XML1_1
  use m_common_namecheck, only: checkQName, prefixOfQName, localPartOfQName
  use m_dom_error, only : NOT_FOUND_ERR, INVALID_CHARACTER_ERR, FoX_INVALID_NODE, &
    FoX_INVALID_XML_NAME, WRONG_DOCUMENT_ERR, FoX_INVALID_TEXT, & 
    FoX_INVALID_CHARACTER, FoX_INVALID_COMMENT, FoX_INVALID_CDATA_SECTION, &
    FoX_INVALID_PI_DATA, NOT_SUPPORTED_ERR



  use m_common_array_str, only: str_vs



  use m_common_array_str, only: str_vs, vs_str_alloc
  use m_common_namecheck, only: prefixOfQName, localpartOfQName



  use m_common_array_str, only: str_vs, vs_str_alloc



  use m_common_array_str, only: str_vs, vs_str_alloc
  use m_dom_error, only: INDEX_SIZE_ERR



  use m_common_array_str, only: str_vs



  use m_common_array_str, only: str_vs



  use m_common_array_str, only: str_vs, vs_str_alloc



  use m_common_array_str, only: str_vs, vs_str_alloc


  implicit none
  private

  integer, parameter ::     ELEMENT_NODE                   = 1
  integer, parameter ::     ATTRIBUTE_NODE                 = 2
  integer, parameter ::     TEXT_NODE                      = 3
  integer, parameter ::     CDATA_SECTION_NODE             = 4
  integer, parameter ::     ENTITY_REFERENCE_NODE          = 5
  integer, parameter ::     ENTITY_NODE                    = 6
  integer, parameter ::     PROCESSING_INSTRUCTION_NODE    = 7
  integer, parameter ::     COMMENT_NODE                   = 8
  integer, parameter ::     DOCUMENT_NODE                  = 9
  integer, parameter ::     DOCUMENT_TYPE_NODE             = 10
  integer, parameter ::     DOCUMENT_FRAGMENT_NODE         = 11
  integer, parameter ::     NOTATION_NODE                  = 12


  type DOMImplementation
    private
    character(len=7) :: id = "FoX_DOM"
  end type DOMImplementation

  type ListNode
    private
    type(Node), pointer :: this => null()
  end type ListNode 

  type NodeList
    private
    character, pointer :: nodeName(:) => null() ! What was getByTagName run on?
    character, pointer :: localName(:) => null() ! What was getByTagNameNS run on?
    character, pointer :: namespaceURI(:) => null() ! What was getByTagNameNS run on?
    type(Node), pointer :: element => null() ! which element or document was the getByTagName run from?
    type(ListNode), pointer :: nodes(:) => null()
    integer :: length = 0
  end type NodeList

  type NodeListptr
    private
    type(NodeList), pointer :: this
  end type NodeListptr

  type NamedNodeMap
    private
    logical :: readonly = .false.
    type(Node), pointer :: ownerElement => null()
    type(ListNode), pointer :: nodes(:) => null()
    integer :: length = 0
  end type NamedNodeMap

  type Node
    private
    logical :: readonly = .false. ! FIXME must check this everywhere
    character, pointer, dimension(:)         :: nodeName => null()
    character, pointer, dimension(:)         :: nodeValue => null()
!   integer              :: nc              = 0  ! FIXME dont need this
    integer              :: nodeType        = 0
    type(Node), pointer :: parentNode      => null()
    type(Node), pointer :: firstChild      => null()
    type(Node), pointer :: lastChild       => null()
    type(Node), pointer :: previousSibling => null()
    type(Node), pointer :: nextSibling     => null()
    type(Node), pointer :: ownerDocument   => null()
    type(NamedNodeMap) :: attributes
    type(NodeList) :: childNodes
    ! Introduced in DOM Level 2:
    character, pointer, dimension(:) :: namespaceURI => null()
    character, pointer, dimension(:) :: prefix => null()
    character, pointer, dimension(:) :: localName => null()
    type(Node), pointer :: doctype => null()
    type(DOMImplementation), pointer :: implementation => null()
    type(Node), pointer :: documentElement => null()
    logical :: specified
    ! Introduced in DOM Level 2
    type(Node), pointer :: ownerElement => null()
    type(namedNodeMap) :: entities
    type(namedNodeMap) :: notations 
    ! FIXME The two above should be held in xds below
    character, pointer :: publicId(:) => null()
    character, pointer :: systemId(:) => null()
    character, pointer :: internalSubset(:) => null()
    character, pointer :: notationName(:) => null()
    ! Introduced in DOM Level 3
    character, pointer :: inputEncoding(:) => null()
    character, pointer :: xmlEncoding(:) => null()
    ! logical :: xmlStandalone = .false.
    ! character, pointer :: xmlVersion(:) => null() 
    ! The two above are held in xds below
    logical :: strictErrorChecking = .false.
    character, pointer :: documentURI(:) => null()
    ! DOMCONFIGURATION
    type(xml_doc_state), pointer :: xds => null()
    !TYPEINFO schemaTypeInfo
    logical :: isId
    ! In order to keep all node lists live ..
    type(NodeListPtr), pointer :: nodelists(:)
    ! In order to keep track of all nodes not connected to the document
    logical :: liveNodeLists ! For the document, are nodelists live? (FIXME should be in xds)
    type(NodeList) :: hangingNodes ! For the document. list of nodes not associated with doc
    logical :: inDocument = .false.! For a node, is this node associated to the doc?
  end type Node

  type(DOMImplementation), save, target :: FoX_DOM

  interface destroy
    module procedure destroyNode, destroyNodeList, destroyNamedNodeMap
  end interface destroy

  public :: ELEMENT_NODE
  public :: ATTRIBUTE_NODE
  public :: TEXT_NODE
  public :: CDATA_SECTION_NODE
  public :: ENTITY_REFERENCE_NODE
  public :: ENTITY_NODE
  public :: PROCESSING_INSTRUCTION_NODE
  public :: COMMENT_NODE
  public :: DOCUMENT_NODE
  public :: DOCUMENT_TYPE_NODE
  public :: DOCUMENT_FRAGMENT_NODE
  public :: NOTATION_NODE

  public :: DOMImplementation
  public :: Node

  public :: ListNode
  public :: NodeList
  public :: NamedNodeMap

  public :: createNode
  public :: destroyNode
  public :: destroyNodeContents
  public :: destroyDocumentFragment
  public :: destroy

  public :: setDocBuilding


  
  public :: getNodeName
  public :: getNodevalue	
  public :: setNodeValue
  public :: getNodeType
  public :: getParentNode
  public :: getChildNodes
  public :: getFirstChild
  public :: getLastChild
  public :: getNextSibling
  public :: getPreviousSibling
  public :: getAttributes
  public :: getOwnerDocument
  public :: insertBefore
  public :: replaceChild
  public :: removeChild
  public :: appendChild
  public :: hasChildNodes
  public :: cloneNode  
  public :: normalize
  public :: isSupported
  public :: getNamespaceURI
  public :: getPrefix
  public :: setPrefix
  public :: getLocalName
  public :: hasAttributes
!  public :: isSameNode



  public :: item
  public :: append
  public :: pop_nl
  public :: remove_nl
  public :: destroyNodeList
  
  interface append
    module procedure append_nl
  end interface
  
  interface item
    module procedure item_nl
  end interface

  interface getLength
    module procedure getLength_nl
  end interface getLength


  public :: getNamedItem
  public :: getNamedItem_Value
  public :: getNamedItem_Value_length
  public :: setNamedItem
  public :: removeNamedItem
  public :: item
!  public :: getLength
  public :: getNamedItemNS
  public :: getNamedItemNS_Value
  public :: getNamedItemNS_Value_length
  public :: setNamedItemNS
  public :: removeNamedItemNS

  public :: append
  public :: setReadOnly
  public :: destroyNamedNodeMap

  interface append
    module procedure append_nnm
  end interface

  interface item
    module procedure item_nnm
  end interface

  interface getLength
    module procedure getLength_nnm
  end interface



  public :: hasFeature
  public :: createDocument
  public :: createDocumentType

  public :: destroyDocument

  public :: createEmptyDocument
  public :: createEmptyDocumentType

  public :: replace_xds



  public :: getDocType
  public :: getImplementation
  public :: getDocumentElement
  public :: setDocumentElement
  
  public :: createElement
  public :: createDocumentFragment
  public :: createTextNode
  public :: createComment
  public :: createCdataSection
  public :: createProcessingInstruction
  public :: createAttribute
  public :: createEntityReference
  public :: getElementsByTagName
  public :: importNode
  public :: createElementNS
  public :: createAttributeNS
  public :: getElementsByTagNameNS
  public :: getElementById
  public :: getXmlVersion
  public :: setXmlVersion

  public :: createEntity
  public :: createNotation



  !public :: getName
  public :: getEntities
  public :: getNotations
!  public :: getPublicId
!  public :: getSystemId
  public :: getInternalSubset

!  Not part of documented API:
  public :: setDocType


  
  public :: getTagName
  public :: getAttribute
  public :: setAttribute
  public :: removeAttribute
  public :: getAttributeNode
  public :: setAttributeNode
  public :: removeAttributeNode
  ! public :: getElementsByTagName
  public :: getAttributeNS
  public :: setAttributeNS
  public :: removeAttributeNS
  public :: getAttributeNodeNS
  public :: setAttributeNodeNS
  public :: removeAttributeNodeNS
  public :: hasAttribute
  public :: hasAttributeNS


  !public :: getName
  public :: getSpecified
  interface getValue
    module procedure getValue_DOM
  end interface	 
  public :: getValue
  public :: setValue
  public :: getOwnerElement



  public :: getLength
!  public :: getData
!  public :: setData
  public :: substringData
  public :: appendData
  public :: insertData
  public :: deleteData
  public :: replaceData

  interface getLength
    module procedure getLength_characterdata
  end interface


  
  public :: getNotationName



  public :: getTarget

  
  public :: splitText


! Assorted functions with identical signatures despite belonging to different types.

  public :: getData
  public :: setData
  public :: getName
  public :: getPublicId
  public :: getSystemId


contains


  function createNode(doc, nodeType, nodeName, nodeValue, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    integer, intent(in) :: nodeType
    character(len=*), intent(in) :: nodeName
    character(len=*), intent(in) :: nodeValue
    type(Node), pointer :: np

    print*,"createNode", nodeType

    if (associated(doc)) then
      if (doc%nodeType/=DOCUMENT_NODE) then
        call throw_exception(FoX_INVALID_NODE, "createNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      endif
    elseif (nodeType/=DOCUMENT_NODE) then
      print*,"Internal error creating node"
      stop
    endif

    allocate(np)
    np%ownerDocument => doc
    np%nodeType = nodeType
    np%nodeName => vs_str_alloc(nodeName)
    np%nodeValue => vs_str_alloc(nodeValue)

    allocate(np%childNodes%nodes(0))

  end function createNode

  subroutine destroyNode(np)
    type(Node), pointer :: np

    print*,"destroyNode", np%nodeType
    if (.not.associated(np)) return

    select case(np%nodeType)
    case (ELEMENT_NODE)
      call destroyElement(np)
    case (ATTRIBUTE_NODE)
      call destroyAttribute(np)
    case (ENTITY_REFERENCE_NODE)
      ! In principle a DOM might have children here. We dont. ! FIXME we do
      call destroyNodeContents(np)
      deallocate(np)
    case (ENTITY_NODE)
      ! ?? FIXME
      call destroyNodeContents(np)
      deallocate(np)
    case (DOCUMENT_NODE)
      ! well, I dont think this should ever be called, but if it is
      ! then go to destroy_document
      !call destroyDocument(np)
    case (DOCUMENT_TYPE_NODE)
      call destroyDocumentType(np)
    case (DOCUMENT_FRAGMENT_NODE)
      !call destroyDocumentFragment
    case default
      call destroyNodeContents(np)
      deallocate(np)
    end select

  end subroutine destroyNode

  subroutine destroyDocumentType(dt)
    type(Node), pointer :: dt

    integer :: i

    if (dt%nodeType/=DOCUMENT_TYPE_NODE) then
       ! FIXME internal error
    endif

    print*,"DESTROYDT"
    ! Entities need to be destroyed recursively - if they are done properly ...

    if (associated(dt%entities%nodes)) then
      do i = 1, size(dt%entities%nodes)
        call destroyAllNodesRecursively(dt%entities%nodes(i)%this)
        call destroy(dt%entities%nodes(i)%this)
      enddo
      deallocate(dt%entities%nodes)
    endif
    if (associated(dt%notations%nodes)) then
      do i = 1, size(dt%notations%nodes)
        call destroy(dt%notations%nodes(i)%this)
      enddo
      deallocate(dt%notations%nodes)
    endif

    call destroy_xml_doc_state(dt%xds)
    deallocate(dt%xds)

    call destroyNodeContents(dt)
    deallocate(dt)

    print*,"DONEDESTROYDT"

  end subroutine destroyDocumentType

  subroutine destroyElement(element)
    type(Node), pointer :: element

    integer :: i

    if (element%nodeType /= ELEMENT_NODE) then
      ! FIXME internal error
    endif

    !do i = 1, element%attributes%length
    !  call destroyNode(element%attributes%nodes(i)%this)
    !enddo
    !    call destroyNamedNodeMap(element%attributes)
    if (associated(element%attributes%nodes)) deallocate(element%attributes%nodes)
    call destroyNodeContents(element)
    deallocate(element)

  end subroutine destroyElement

  subroutine destroyAttribute(attr, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: attr

    type(Node), pointer :: np, np_next

    if (attr%nodeType/=ATTRIBUTE_NODE) then
      call throw_exception(FoX_INVALID_NODE, "destroyAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

 !    np => attr%firstChild
 !   do while (associated(np))
 !     np_next => np%nextSibling
 !     call destroyNode(np)
 !     np => np_next
 !   enddo

    call destroyNodeContents(attr)
    deallocate(attr)

  end subroutine destroyAttribute

  subroutine destroyDocumentFragment(df, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: df

    if (df%nodeType/=DOCUMENT_FRAGMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "destroyDocumentFragment", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    call destroyAllNodesRecursively(df)

    call destroyNodeContents(df)
    deallocate(df)

  end subroutine destroyDocumentFragment

  subroutine destroyAllNodesRecursively(df)
    type(Node), pointer :: df
    
    type(Node), pointer :: np
    logical :: ascending, attributesdone
    integer :: i

    np => df%firstChild
    if (.not.associated(np)) return

    ascending = .false.
    attributesdone = .false.
    i = 0
    do
      if (ascending) then
        ascending = .false.
        if (np%nodeType==ATTRIBUTE_NODE) then
          np => np%ownerElement
          attributesdone = .true.
          if (i>0) then
            call destroyNode(np%attributes%nodes(i)%this)
            i = 0
          endif
          cycle
        else
          np => np%parentNode
          call destroyNode(np%lastChild)
        endif
        if (associated(np, df)) exit
      elseif (np%nodeType==ELEMENT_NODE.and..not.attributesdone) then
        if (np%attributes%length>0) then
          i = 1
          np => np%attributes%nodes(i)%this
        else
          attributesdone = .true.
        endif
        cycle
      elseif (associated(np%firstChild)) then
        np => np%firstChild
        attributesdone = .false.
        cycle
      endif
      if (np%nodeType==ATTRIBUTE_NODE) then
        if (i==np%ownerElement%attributes%length) then
          ascending = .true.
        else
          i = i + 1
          np => np%ownerElement%attributes%nodes(i)%this
          call destroyNode(np%ownerElement%attributes%nodes(i-1)%this)
        endif
      elseif (associated(np%nextSibling)) then
        np => np%nextSibling
        attributesdone = .false.
        call destroyNode(np%previousSibling)
      else
        ascending = .true.
      endif
    enddo

  end subroutine destroyAllNodesRecursively

  subroutine destroyNodeContents(np)
    type(Node), intent(inout) :: np
    
    if (associated(np%nodeName)) deallocate(np%nodeName)
    if (associated(np%nodeValue)) deallocate(np%nodeValue)
    if (associated(np%namespaceURI)) deallocate(np%namespaceURI)
    if (associated(np%prefix)) deallocate(np%prefix)
    if (associated(np%localname)) deallocate(np%localname)
    if (associated(np%publicId)) deallocate(np%publicId)
    if (associated(np%systemId)) deallocate(np%systemId)
    if (associated(np%internalSubset)) deallocate(np%internalSubset)
    if (associated(np%notationName)) deallocate(np%notationName)

    if (associated(np%inputEncoding)) deallocate(np%inputEncoding)
    if (associated(np%xmlEncoding)) deallocate(np%xmlEncoding)
    !if (associated(np%xmlVersion)) deallocate(np%xmlVersion)
    if (associated(np%documentURI)) deallocate(np%documentURI)

    deallocate(np%childNodes%nodes)

  end subroutine destroyNodeContents

! Some convenience functions for internal use:

  subroutine setDocBuilding(doc,b)
    type(Node), pointer :: doc
    logical, intent(in) :: b
    doc%docType%xds%building = b
  end subroutine setDocBuilding



  ! Getters and setters

  function getNodeName(arg) result(c)
    type(Node), intent(in) :: arg
    character(len=size(arg%nodeName)) :: c
    
    c = str_vs(arg%nodeName)
  end function getNodeName

  pure function getNodeValue_len(arg) result(n)
    type(Node), intent(in) :: arg
    integer :: n

    integer :: i

    select case(arg%nodeType)
    case (ATTRIBUTE_NODE)
      n = 0
      do i = 1, arg%childNodes%length
        if (arg%childNodes%nodes(i)%this%nodeType == TEXT_NODE) then
          n = n + size(arg%childNodes%nodes(i)%this%nodeValue)
        else
          !FIXME replace entity references
        endif
      enddo
    case (CDATA_SECTION_NODE)
      n = size(arg%nodeValue)
    case (COMMENT_NODE)
      n = size(arg%nodeValue)
    case (PROCESSING_INSTRUCTION_NODE)
      n = size(arg%nodeValue)
    case (TEXT_NODE)
      n = size(arg%nodeValue)
    case default
      n = 0
    end select

  end function getNodeValue_len

  function getNodeValue(arg) result(c)
    type(Node), intent(in) :: arg
    character(len=getNodeValue_len(arg)) :: c

    integer :: i, n

    select case(arg%nodeType)
    case (ATTRIBUTE_NODE)
      n = 1
      do i = 1, arg%childNodes%length
        if (arg%childNodes%nodes(i)%this%nodeType == TEXT_NODE) then
          c(n:n+size(arg%childNodes%nodes(i)%this%nodeValue)-1) = &
            str_vs(arg%childNodes%nodes(i)%this%nodeValue)
          n = n + size(arg%childNodes%nodes(i)%this%nodeValue)
        else
          !FIXME replace entity references
        endif
      enddo
    case (CDATA_SECTION_NODE)
      c = str_vs(arg%nodeValue)
    case (COMMENT_NODE)
      c = str_vs(arg%nodeValue)
    case (PROCESSING_INSTRUCTION_NODE)
      c = str_vs(arg%nodeValue)
    case (TEXT_NODE)
      c = str_vs(arg%nodeValue)
    end select
    
  end function getNodeValue
  
  subroutine setNodeValue(arg, nodeValue, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    character(len=*) :: nodeValue

    type(Node), pointer :: np
    integer :: i, n

    if (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setNodeValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    select case(arg%nodeType)
    case (ATTRIBUTE_NODE)
      ! FIXME check does string contain wrong characters
      ! destroy any existing children ... 
      do i = 1, arg%childNodes%length
        call destroyNode(arg%childNodes%nodes(i)%this)
      enddo
      deallocate(arg%childNodes%nodes)
      allocate(arg%childNodes%nodes(0))
      arg%childNodes%length = 0
      arg%firstChild => null()
      arg%lastChild => null()
      ! and add the new one.
      np => createTextNode(arg%ownerDocument, nodeValue)
      np => appendChild(arg, np)
    case (CDATA_SECTION_NODE)
      ! FIXME check does string contain wrong characters
      deallocate(arg%nodeValue)
      arg%nodeValue => vs_str_alloc(nodeValue)
    case (COMMENT_NODE)
      ! FIXME check does string contain wrong characters
      deallocate(arg%nodeValue)
      arg%nodeValue => vs_str_alloc(nodeValue)
    case (PROCESSING_INSTRUCTION_NODE)
      ! FIXME check does string contain wrong characters
      deallocate(arg%nodeValue)
      arg%nodeValue => vs_str_alloc(nodeValue)
    case (TEXT_NODE)
      ! FIXME check does string contain wrong characters
      deallocate(arg%nodeValue)
      arg%nodeValue => vs_str_alloc(nodeValue)
    end select

  end subroutine setNodeValue

  function getNodeType(arg) result(n)
    type(Node), intent(in) :: arg
    integer :: n

    n = arg%nodeType
  end function getNodeType

  function getParentNode(arg) result(np)
    type(Node), intent(in) :: arg
    type(Node), pointer :: np

    np => arg%parentNode
  end function getParentNode
  
  function getChildNodes(arg) result(nl)
    type(Node), pointer :: arg
    type(NodeList), pointer :: nl

    nl => arg%childnodes
  end function getChildNodes
  
  function getFirstChild(arg) result(np)
    type(Node), intent(in) :: arg
    type(Node), pointer :: np

    np => arg%firstChild
  end function getFirstChild
  
  function getLastChild(arg) result(np)
    type(Node), intent(in) :: arg
    type(Node), pointer :: np

    np => arg%lastChild
  end function getLastChild

  function getPreviousSibling(arg) result(np)
    type(Node), intent(in) :: arg
    type(Node), pointer :: np

    np => arg%previousSibling
  end function getPreviousSibling
  
  function getNextSibling(arg) result(np)
    type(Node), intent(in) :: arg
    type(Node), pointer :: np

    np => arg%nextSibling
  end function getNextSibling

  function getAttributes(arg) result(nnm)
    type(Node), pointer :: arg
    type(NamedNodeMap), pointer :: nnm

! FIXME surely only if this is an element node?

    nnm => arg%attributes
  end function getAttributes

  function getOwnerDocument(arg) result(np)
    type(Node), intent(in) :: arg
    type(Node), pointer :: np
    
    if (np%nodeType==DOCUMENT_NODE) then
      np => null()
    else
      np => arg%ownerDocument
    endif
  end function getOwnerDocument

  function insertBefore(arg, newChild, refChild, ex) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: newChild
    type(Node), pointer :: refChild
    type(Node), pointer :: insertBefore

    type(ListNode), pointer :: temp_nl(:)
    integer :: i, i_t

    if (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
!   FIXME what about this next?
    if (.not. associated(arg)) call dom_error("insertBefore",0,"Node not allocated")

! FIXME need to special case this for inserting documentElement and documentType on document nodes
    select case(arg%nodeType)
    case (ELEMENT_NODE)
      if (newChild%nodeType/=ELEMENT_NODE &
        .and. newChild%nodeType/=TEXT_NODE &
        .and. newChild%nodeType/=COMMENT_NODE &
        .and. newChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
        .and. newChild%nodeType/=CDATA_SECTION_NODE &
        .and. newChild%nodeType/=ENTITY_REFERENCE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (ATTRIBUTE_NODE)
      if (newChild%nodeType/=TEXT_NODE &
        .and. newChild%nodeType/=ENTITY_REFERENCE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (DOCUMENT_NODE)
      if (newChild%nodeType/=ELEMENT_NODE &
        .and. newChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
        .and. newChild%nodeType/=COMMENT_NODE &
        .and. newChild%nodeType/=DOCUMENT_TYPE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (DOCUMENT_FRAGMENT_NODE)
      if (newChild%nodeType/=ELEMENT_NODE &
        .and. newChild%nodeType/=TEXT_NODE &
        .and. newChild%nodeType/=COMMENT_NODE &
        .and. newChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
        .and. newChild%nodeType/=CDATA_SECTION_NODE &
        .and. newChild%nodeType/=ENTITY_REFERENCE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case default
      call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    end select

    if (.not.(associated(arg%ownerDocument, newChild%ownerDocument) &
      .or. associated(arg, newChild%ownerDocument))) then
      call throw_exception(WRONG_DOCUMENT_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (associated(newChild%parentNode)) &
      newChild => removeChild(newChild%parentNode, newChild, ex)
    
    if (.not.associated(refChild)) then
      insertBefore => appendChild(arg, newChild, ex)
      return
    endif

    allocate(temp_nl(size(arg%childNodes%nodes)+1))
    i_t = 1
    do i = 1, size(arg%childNodes%nodes)
      if (associated(arg%childNodes%nodes(i)%this, refChild)) then 
        i_t = i_t + 1
        temp_nl(i_t)%this => newChild
        newChild%parentNode => arg
        if (i==1) then
          arg%firstChild => newChild
          newChild%previousSibling => null()
        else
          newChild%previousSibling => arg%childNodes%nodes(i-1)%this
          arg%childNodes%nodes(i-1)%this%nextSibling => newChild
        endif
        if (i==size(arg%childNodes%nodes)) then
          arg%lastChild => newChild
          newChild%nextSibling => null()
        else
          newChild%nextSibling => arg%childNodes%nodes(i+1)%this
          arg%childNodes%nodes(i+1)%this%previousSibling => newChild
        endif
      endif
      temp_nl(i_t)%this => arg%childNodes%nodes(i)%this
      i_t = i_t + 1     
    enddo
    if (i_t == i) then
      call throw_exception(NOT_FOUND_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then

if (associated(temp_nl)) deallocate(temp_nl)
     return
  endif
endif

    endif

    deallocate(arg%childNodes%nodes)
    arg%childNodes%nodes => temp_nl
    arg%childNodes%length = size(temp_nl)

    if (.not.arg%ownerDocument%xds%building) then
      if (arg%inDocument) then
        call putNodesInDocument(arg%ownerDocument, newChild)
      endif
    endif

  end function insertBefore



  function replaceChild(arg, newChild, oldChild, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: newChild
    type(Node), pointer :: oldChild
    type(Node), pointer :: np

    integer :: i
    
    if (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not. associated(arg)) call dom_error("replaceChild",0,"Node not allocated")

    select case(arg%nodeType)
    case (ELEMENT_NODE)
      if (newChild%nodeType/=ELEMENT_NODE &
        .and. newChild%nodeType/=TEXT_NODE &
        .and. newChild%nodeType/=COMMENT_NODE &
        .and. newChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
        .and. newChild%nodeType/=CDATA_SECTION_NODE &
        .and. newChild%nodeType/=ENTITY_REFERENCE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (ATTRIBUTE_NODE)
      if (newChild%nodeType/=TEXT_NODE &
        .and. newChild%nodeType/=ENTITY_REFERENCE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (DOCUMENT_NODE)
      if (newChild%nodeType/=ELEMENT_NODE &
        .and. newChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
        .and. newChild%nodeType/=COMMENT_NODE &
        .and. newChild%nodeType/=DOCUMENT_TYPE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (DOCUMENT_FRAGMENT_NODE)
      if (newChild%nodeType/=ELEMENT_NODE &
        .and. newChild%nodeType/=TEXT_NODE &
        .and. newChild%nodeType/=COMMENT_NODE &
        .and. newChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
        .and. newChild%nodeType/=CDATA_SECTION_NODE &
        .and. newChild%nodeType/=ENTITY_REFERENCE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case default
      call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    end select

    if (.not.(associated(arg%ownerDocument, newChild%ownerDocument) &
      .or. associated(arg, newChild%ownerDocument))) then
      call throw_exception(WRONG_DOCUMENT_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (associated(newChild%parentNode)) then
      newChild => removeChild(newChild%parentNode, newChild, ex)
    elseif (newChild%nodeType==DOCUMENT_FRAGMENT_NODE) then
      !FIXME

    endif

    do i = 1, size(arg%childNodes%nodes)
      if (associated(arg%childNodes%nodes(i)%this, oldChild)) then
        np => oldChild
        if (i==1) then
          arg%firstChild => newChild
          newChild%previousSibling => null()
        else 
          arg%childNodes%nodes(i-1)%this%nextSibling => newChild
          newChild%previousSibling => arg%childNodes%nodes(i-1)%this
        endif
        arg%childNodes%nodes(i)%this => newChild
        newChild%parentNode => arg 
        if (i==size(arg%childNodes%nodes)) then
          arg%lastChild => newChild
          newChild%nextSibling => null()
        else
          arg%childNodes%nodes(i+1)%this%previousSibling => newChild
          newChild%nextSibling => arg%childNodes%nodes(i+1)%this
        endif
        return
      endif
    enddo

    call throw_exception(NOT_FOUND_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif


    np%parentNode => null()
    np%previousSibling => null()
    np%nextSibling => null()

    ! FIXME updateNodeLists(*) in case of children
    ! but only if we are replacing a child of the document
    if (.not.arg%ownerDocument%xds%building) then
      if (arg%inDocument) then
        call removeNodesFromDocument(arg%ownerDocument, oldChild)
      endif
    endif
    if (.not.arg%ownerDocument%xds%building) then
      if (arg%inDocument) then
        call putNodesInDocument(arg%ownerDocument, newChild)
      endif
    endif

  end function replaceChild


  function removeChild(arg, oldChild, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: oldChild
    type(Node), pointer :: np

    type(ListNode), pointer :: temp_nl(:)
    integer :: i, i_t

    if (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "removeChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not.associated(arg)) call dom_error("removeChild",0,"Node not allocated")
    
    allocate(temp_nl(size(arg%childNodes%nodes)-1))
    i_t = 1
    do i = 1, size(arg%childNodes%nodes)
      if (associated(arg%childNodes%nodes(i)%this, oldChild)) then 
        np => arg%childNodes%nodes(i)%this
        if (associated(arg%firstChild, arg%lastChild)) then
          ! There is only one child, we are removing it.
          arg%firstChild => null()
          arg%lastChild => null()
        elseif (i==1) then
          ! We are removing the first child, but there is a second
          arg%firstChild => arg%childNodes%nodes(2)%this
          arg%childNodes%nodes(2)%this%previousSibling => null()
        elseif (i==size(arg%childNodes%nodes)) then
          ! We are removing the last child, but there is a second-to-last
          arg%lastChild => arg%childNodes%nodes(i-1)%this
          arg%childNodes%nodes(i-1)%this%nextSibling => null()
        else
          ! We are removing a child in the middle
          arg%childNodes%nodes(i-1)%this%nextSibling => arg%childNodes%nodes(i+1)%this
          arg%childNodes%nodes(i+1)%this%previousSibling => arg%childNodes%nodes(i-1)%this
        endif
      else
        temp_nl(i_t)%this => arg%childNodes%nodes(i)%this
        i_t = i_t + 1     
      endif
    enddo
    deallocate(arg%childNodes%nodes)
    arg%childNodes%nodes => temp_nl
    arg%childNodes%length = size(temp_nl)

    if (i==i_t) then
      call throw_exception(NOT_FOUND_ERR, "removeChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np%parentNode => null()
    np%previousSibling => null()
    np%nextSibling => null()

    if (.not.arg%ownerDocument%xds%building) then
      if (arg%inDocument) then
        call removeNodesFromDocument(arg%ownerDocument, oldChild)
      endif
    endif

  end function removeChild


  function appendChild(arg, newChild, ex) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: newChild
    type(Node), pointer :: appendChild
    
    type(ListNode), pointer :: temp_nl(:)
    integer :: i

    print*,"APPENDINGCHILD to", str_vs(arg%nodeName)

    if (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not. associated(arg))  & 
      call dom_error("appendChild",0,"Node not allocated")
    
    select case(arg%nodeType)
    case (ELEMENT_NODE)
      if (newChild%nodeType/=ELEMENT_NODE &
        .and. newChild%nodeType/=TEXT_NODE &
        .and. newChild%nodeType/=COMMENT_NODE &
        .and. newChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
        .and. newChild%nodeType/=CDATA_SECTION_NODE &
        .and. newChild%nodeType/=ENTITY_REFERENCE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (ATTRIBUTE_NODE)
      if (newChild%nodeType/=TEXT_NODE &
        .and. newChild%nodeType/=ENTITY_REFERENCE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (DOCUMENT_NODE)
      if (newChild%nodeType/=ELEMENT_NODE &
        .and. newChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
        .and. newChild%nodeType/=COMMENT_NODE &
        .and. newChild%nodeType/=DOCUMENT_TYPE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (DOCUMENT_FRAGMENT_NODE)
      if (newChild%nodeType/=ELEMENT_NODE &
        .and. newChild%nodeType/=TEXT_NODE &
        .and. newChild%nodeType/=COMMENT_NODE &
        .and. newChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
        .and. newChild%nodeType/=CDATA_SECTION_NODE &
        .and. newChild%nodeType/=ENTITY_REFERENCE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (ENTITY_NODE)
      continue ! only allowed by DOM parser, not by user.
               ! but entity nodes are always readonly anyway, so no problem
    case (ENTITY_REFERENCE_NODE)
      continue ! only allowed by DOM parser, not by user.
               ! but entity nodes are always readonly anyway, so no problem
    case default
      call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    end select

    if (.not.(associated(arg%ownerDocument, newChild%ownerDocument) &
      .or. associated(arg, newChild%ownerDocument))) then
      call throw_exception(WRONG_DOCUMENT_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (associated(newChild%parentNode)) &
      newChild => removeChild(newChild%parentNode, newChild, ex) 

    allocate(temp_nl(size(arg%childNodes%nodes)+1))

    do i = 1, size(arg%childNodes%nodes)
      temp_nl(i)%this => arg%childNodes%nodes(i)%this
    enddo
    temp_nl(i)%this => newChild

    if (i==1) then
      arg%firstChild => newChild
      newChild%previousSibling => null()
    else
      temp_nl(i-1)%this%nextSibling => newChild
      newChild%previousSibling => temp_nl(i-1)%this     
    endif

    deallocate(arg%childNodes%nodes)
    arg%childNodes%nodes => temp_nl
    arg%childNodes%length = size(temp_nl)

    newChild%nextSibling => null()
    arg%lastChild => newChild
    newChild%parentNode => arg
    
    appendChild => newChild

    if (.not.arg%ownerDocument%xds%building) then
      if (arg%inDocument) then
        call putNodesInDocument(arg%ownerDocument, newChild)
      endif
    endif


  end function appendChild


  function hasChildNodes(arg)
    type(Node), pointer :: arg
    logical :: hasChildNodes
    
    if (.not. associated(arg)) call dom_error("hasChildNodes",0,"Node not allocated")
    hasChildNodes = associated(arg%firstChild)
    
  end function hasChildNodes

  function cloneNode(arg, deep, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    logical :: deep
    type(Node), pointer :: np

    type(Node), pointer :: np_a1, np_a2, this, thatParent, new, ERchild
    type(NamedNodeMap), pointer :: nnm

    logical :: ascending, readonly
    integer :: i

    ascending = .false.
    readonly = .false.
    
    ERchild => null()
    this => arg

    do
      if (ascending) then
        this => this%parentNode
        if (associated(this, arg)) exit
        thatParent => thatParent%parentNode
        if (associated(this, ERchild)) then
          ! Weve got back up to the top of the topmost ER.
          readonly = .false.
          ERchild => null()
        endif
        ascending = .false.
      endif
      print*,"ASSOCIATEDNODE", associated(this), this%nodeType
      select case(this%nodeType)
      case (ELEMENT_NODE)
        new => createElementNS(this%ownerDocument, &
          str_vs(this%namespaceURI), str_vs(this%localName))
        ! loop over attributes cloning them
        nnm => getAttributes(this)
        do i = 1, getLength(nnm)
          np_a1 => item(nnm, i)
          np_a2 => createAttributeNS(this%ownerDocument, &
            str_vs(np_a1%namespaceURI), str_vs(np_a1%localName))
          call setValue(new, getValue(np_a1))
          !FIXME what if the value is an entity reference?
          np_a2%specified = np_a1%specified
          np_a2 => setAttributeNodeNS(np, np_a2)
        end do
      case (ATTRIBUTE_NODE)
        new => createAttributeNS(this%ownerDocument, &
          str_vs(this%namespaceURI), str_vs(this%localName))
        call setValue(new, getValue(np_a2))
        new%specified = .true.
      case (TEXT_NODE)
        new => createTextNode(this%ownerDocument, str_vs(this%nodeValue))
      case (CDATA_SECTION_NODE)
        new => createCdataSection(this%ownerDocument, str_vs(this%nodeValue))
      case (ENTITY_REFERENCE_NODE)
        new => createEntityReference(this%ownerDocument, str_vs(this%nodeName))
        ERChild => this
      case (ENTITY_NODE)
        new => null()
      case (PROCESSING_INSTRUCTION_NODE)
        new => createProcessingInstruction(this%ownerDocument, &
          str_vs(this%nodeName), str_vs(this%nodeValue))
      case (COMMENT_NODE)
        new => createComment(this%ownerDocument, str_vs(this%nodeValue))
      case (DOCUMENT_NODE)
        new => null()
      case (DOCUMENT_FRAGMENT_NODE)
        new => createDocumentFragment(this%ownerDocument)
      case (NOTATION_NODE)
        new => null() 
      end select
      ! Sort out readonly-ness
      new%readonly = readonly
      if (associated(ERChild)) readonly = .true. ! This is not readonly, but all nodes below will be
      ! Append the new node to the tree
      if (associated(this, arg)) then
        thatParent => new ! This is the first we have created, head of the tree
        if (.not.deep) exit ! We only wanted one node anyway
      else
        new => appendChild(thatParent, new)
      endif
      ! Do we continue descending?
      if (associated(this%firstChild)) then
        this => this%firstChild
        if (.not.associated(this, arg)) &
          thatParent => thatParent%lastChild
      elseif (.not.associated(this, arg)) then
        if (associated(this%nextSibling)) then
          this => this%nextSibling
          ! but leave thatParent unchanged
        else
          ascending = .true.
        endif
      else ! the top node has no children, so we are finished
        exit
      endif
    enddo

    np => thatParent

  end function cloneNode

  
  function hasAttributes(arg)
    type(Node), pointer :: arg
    logical :: hasAttributes
    
    if (.not.associated(arg)) call dom_error("hasAttributes",0,"Node not allocated")
    hasAttributes = (arg%nodeType /= ELEMENT_NODE) &
      .and. (arg%attributes%length > 0)
    
  end function hasAttributes
  
  recursive subroutine normalize(arg, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
  ! NB only ever one level of recursion, for text children of the attributes of an element
    ! FIXME shoulndt be recursive
    type(Node), pointer :: this, tempNode
    type(NamedNodeMap), pointer :: nnm
    integer :: i
    logical :: noChild
    character, pointer :: temp(:)
    
    ! This ignores readonly status according to the DOM standard.

    noChild = .false.
    do
      if (noChild) then
        if (associated(this, arg)) exit
        if (associated(this%nextSibling)) then
          this => this%nextSibling
          noChild = .false.
        else
          this => this%parentNode
          cycle
        endif
      endif
      if (associated(tempNode)) then
        tempNode => removeChild(tempNode%parentNode, tempNode)
        tempNode => null()
      endif
      if (this%nodeType==ELEMENT_NODE.and.hasAttributes(this)) then
        ! Loop over attributes combining them ...
        nnm => getAttributes(this)
        do i = 1, getLength(nnm)
          tempNode => item(nnm, i)
          call normalize(tempNode)
        enddo
        tempNode => null()
      elseif (this%nodeType==TEXT_NODE.and.associated(this%nextSibling)) then
        ! Keep going until all adjacent TEXT_NODEs are consumed.
        do while (this%nextSibling%nodeType==TEXT_NODE) 
          temp => this%nodeValue
          this%nodeValue => vs_str_alloc(str_vs(temp)//getData(this%nextSibling))
	  deallocate(temp)
          tempNode => removeChild(this%parentNode, this%nextSibling)
        enddo
        tempNode => null()
        if (size(this%nodeValue)==0) &
          tempNode => this
      endif
      if (associated(this%firstChild)) then
        this => this%firstChild
      else
        noChild = .true.
      endif
    enddo
 
    tempNode => removeChild(tempNode%parentNode, tempNode)

  end subroutine normalize

  function isSupported(arg, feature, version) result(p)
    type(Node), intent(in) :: arg
    character(len=*), intent(in) :: feature
    character(len=*), intent(in) :: version
    logical :: p

    p = hasFeature(arg%ownerDocument%implementation, feature, version)
  end function isSupported

  ! FIXME should the below instead just decompose the QName on access?
  function getNamespaceURI(arg) result(c)
    type(Node), intent(in) :: arg
    character(len=size(arg%namespaceURI)) :: c

    c = str_vs(arg%namespaceURI)
  end function getNamespaceURI

  function getPrefix(arg) result(c)
    type(Node), intent(in) :: arg
    character(len=size(arg%prefix)) :: c

    c = str_vs(arg%prefix)
  end function getPrefix
  
  subroutine setPrefix(arg, prefix)
    type(Node), intent(inout) :: arg
    character(len=*) :: prefix

    deallocate(arg%prefix)
    arg%prefix => vs_str_alloc(prefix)

    print*, "why are you doing this?"
    ! FIXME we should implement this but raise a FoX-specific exception if used
    stop
    ! FIXME exceptions
  end subroutine setPrefix

  function getLocalName(arg) result(c)
    type(Node), intent(in) :: arg
    character(len=size(arg%localName)) :: c

    c = str_vs(arg%localName)
  end function getLocalName

  function isSameNode(node1, node2)    ! DOM 3.0
    type(Node), pointer :: node1
    type(Node), pointer :: node2
    logical :: isSameNode

    isSameNode = associated(node1, node2)

  end function isSameNode

  subroutine putNodesInDocument(doc, np_orig)
    type(Node), pointer :: doc, np_orig
    type(Node), pointer :: np
    logical :: ascending, attributesdone
    integer :: i

    print*,"PUTTING NODES IN DOCUMENT"
    np => np_orig
    ascending = .false.
    attributesdone = .false.
    i = 0
    do
      if (ascending) then
        if (associated(np, np_orig)) exit
        ascending = .false.
        if (np%nodeType==ATTRIBUTE_NODE) then
          np => np%ownerElement
          attributesdone = .true.
          cycle
        else
          np => np%parentNode
        endif
      elseif (np%nodeType==ELEMENT_NODE.and..not.attributesdone) then
        if (np%attributes%length>0) then
          i = 1
          np => np%attributes%nodes(i)%this
        else
          attributesdone = .true.
        endif
        cycle
      elseif (associated(np%firstChild)) then
        np => np%firstChild
        attributesdone = .false.
        cycle
      endif
      np%inDocument = .true.
      call remove_node_nl(np%ownerDocument%hangingNodes, np)
      if (np%nodeType==ATTRIBUTE_NODE) then
        if (i==np%ownerElement%attributes%length) then
          ascending = .true.
        else
          i = i + 1
          np => np%ownerElement%attributes%nodes(i)%this
        endif
      elseif (associated(np%nextSibling)) then
        np => np%nextSibling
        attributesdone = .false.
      else
        ascending = .true.
      endif
    enddo
  end subroutine putNodesInDocument

  subroutine removeNodesFromDocument(np_orig, np)
    type(Node), pointer :: np_orig
    type(Node), pointer :: np
    logical :: ascending, attributesdone
    integer :: i
    np => np_orig
    ascending = .false.
    attributesdone = .false.
    i = 0
    do
      if (ascending) then
        if (associated(np, np_orig)) exit
        ascending = .false.
        if (np%nodeType==ATTRIBUTE_NODE) then
          np => np%ownerElement
          attributesdone = .true.
          cycle
        else
          np => np%parentNode
        endif
      elseif (np%nodeType==ELEMENT_NODE.and..not.attributesdone) then
        if (np%attributes%length>0) then
          i = 1
          np => np%attributes%nodes(i)%this
        else
          attributesdone = .true.
        endif
        cycle
      elseif (associated(np%firstChild)) then
        np => np%firstChild
        attributesdone = .false.
        cycle
      endif
      np%inDocument = .false.
      call append_nl(np%ownerDocument%hangingNodes, np)
      if (np%nodeType==ATTRIBUTE_NODE) then
        if (i==np%ownerElement%attributes%length) then
          ascending = .true.
        else
          i = i + 1
          np => np%ownerElement%attributes%nodes(i)%this
        endif
      elseif (associated(np%nextSibling)) then
        np => np%nextSibling
        attributesdone = .false.
      else
        ascending = .true.
      endif
    enddo
  end subroutine removeNodesFromDocument



  function item_nl(list, index) result(np)
    type(NodeList), intent(in) :: list
    integer, intent(in) :: index
    type(Node), pointer :: np

    if (index>=0.and.index<list%length)  then
      np => list%nodes(index+1)%this
    else
      np => null()
    endif

  end function item_nl

  subroutine append_nl(list, arg)
    type(NodeList), intent(inout) :: list
    type(Node), pointer :: arg

    type(ListNode), pointer :: temp_nl(:)
    integer :: i

    if (.not.associated(list%nodes)) then
      allocate(list%nodes(1))
      list%nodes(1)%this => arg
      list%length = 1
    else
      temp_nl => list%nodes
      allocate(list%nodes(size(temp_nl)+1))
      do i = 1, size(temp_nl)
        list%nodes(i)%this => temp_nl(i)%this
      enddo
      deallocate(temp_nl)
      list%nodes(size(list%nodes))%this => arg
      list%length = size(list%nodes)
    endif
    
  end subroutine append_nl

  function pop_nl(list) result(np)
    type(NodeList), intent(inout) :: list
    type(Node), pointer :: np

    type(ListNode), pointer :: temp_nl(:)
    integer :: i

    if (list%length==0) then
      ! FIXME internal error
      continue
    endif

    np => list%nodes(size(list%nodes))%this

    if (list%length==1) then
      deallocate(list%nodes)
      list%length = 0
    else
      temp_nl => list%nodes
      allocate(list%nodes(size(temp_nl)-1))
      do i = 1, size(temp_nl)-1
        list%nodes(i)%this => temp_nl(i)%this
      enddo
      deallocate(temp_nl)
      list%length = size(list%nodes)
    endif
    
  end function pop_nl


  function remove_nl(nl, index) result(np)
    type(NodeList), intent(inout) :: nl
    integer, intent(in) :: index
    type(Node), pointer :: np

    type(ListNode), pointer :: temp_nl(:)

    integer :: i

    np => nl%nodes(index)%this
! FIXME what if index is too small/too big
    temp_nl => nl%nodes
    allocate(nl%nodes(size(temp_nl)-1))
    nl%length = nl%length - 1 
    do i = 1, index - 1
      nl%nodes(i)%this => temp_nl(i)%this
    enddo
    do i = index + 1, nl%length
      nl%nodes(i-1)%this => temp_nl(i)%this
    enddo
    deallocate(temp_nl)

  end function remove_nl


  subroutine remove_node_nl(nl, np)
    type(NodeList), intent(inout) :: nl
    type(Node), pointer :: np

    type(ListNode), pointer :: temp_nl(:)

    integer :: i

    do i = 1, nl%length
      if (associated(nl%nodes(i)%this, np)) exit
    enddo
    np => remove_nl(nl, i)

  end subroutine remove_node_nl


  function getLength_nl(nl) result(n)
    type(NodeList), intent(in) :: nl
    integer :: n

    n = size(nl%nodes)
  end function getLength_nl

  subroutine destroyNodeList(nl)
    type(NodeList), pointer :: nl
    
    if (associated(nl%nodes)) deallocate(nl%nodes)
    deallocate(nl)
  end subroutine destroyNodeList

  subroutine updateNodeLists(doc, oldName, newName, oldLocalName, newLocalName, oldNamespaceURI, newNamespaceURI)
    ! When triggered, (by addition or movement of an Element Node, or a change of its nodeName, localName, or namespaceURI)
    ! then see if any nodelists need updated.
    type(Node), pointer :: doc
    character, pointer :: oldName(:), newName(:)
    character, pointer :: oldLocalName(:), newLocalName(:)
    character, pointer :: oldNamespaceURI(:), newNamespaceURI(:)

    type(NodeList), pointer :: nl, nl_orig
    type(NodeListPtr), pointer :: temp_nll(:)
    integer :: i, i_t
! FIXME FIXME FIXME

    if (.not.doc%liveNodeLists) return
    if (.not.associated(doc%nodelists)) return

    allocate(temp_nll(size(doc%nodelists)))
    i_t = 0
    do i = 1, size(doc%nodelists)
      ! A nodelist will need updated if it was keyed to the old or new Names.
      nl_orig => doc%nodelists(i)%this
      if (nl_orig%element%nodeType==ELEMENT_NODE) then
        if (.not.associated(nl_orig%element%parentNode)) then
          ! We have just removed this element from the tree
          deallocate(nl_orig%nodes)
          cycle
        endif
      endif
      ! we definitely keep this nodelist.
      i_t = i_t + 1
      ! Although all nodes should be searched whatever the result, we should only do the
      ! appropriate sort of search for this list - according to namespaces or not.
      if (associated(nl_orig%nodeName)) then ! this was made by getElementsByTagName
!!$        if (oldName=="*" &
!!$          .or. str_vs(nl_orig%nodeName)=="*" .or. &
!!$          str_vs(nl_orig%nodeName)==str_vs(oldName) &
!!$          .or. str_vs(nl_orig%nodeName)==str_vs(newName)) then
!!$          ! FIXME check logic above for wildcards
!!$          nl => getElementsByTagName(nl_orig%element, str_vs(nl_orig%nodeName))
!!$          ! That appended a nodelist to the end of doc%nodelists. But it does not matter,
!!$          ! the whole of the original nodelists will be thrown away anyway. We do have to do:
!!$          deallocate(nl_orig)
!!$          ! and then grab the new list for our new list of lists.
!!$          temp_nll(i_t)%this => nl
!!$        endif
      elseif (associated(nl_orig%namespaceURI)) then
        ! This was made by getElementsByTagNameNS
        if (str_vs(nl_orig%localName)==str_vs(oldLocalName) &
          .or. str_vs(nl_orig%localName)==str_vs(newLocalName) &
          .or. str_vs(nl_orig%namespaceURI)==str_vs(oldNamespaceURI) &
          .or. str_vs(nl_orig%namespaceURI)==str_vs(newNamespaceURI)) then
          ! destroy newNL
          nl => getElementsByTagNameNS(nl_orig%element, str_vs(nl_orig%localName), str_vs(nl_orig%namespaceURI))
          ! That appended a nodelist to the end of doc%nodelists. But it does not matter,
          ! the whole of the original nodelists will be thrown away anyway. We do have to do:
          deallocate(nl_orig)
          ! and then grab the new list for our new list of lists.
          temp_nll(i_t)%this => nl
        endif
      else
        temp_nll(i_t)%this => doc%nodelists(i)%this
      endif
    enddo

    !Now, destroy all nodelist pointers from old list:
    do i = 1, size(doc%nodelists) !Note, this size may be different if we have done more searches above.
      deallocate(doc%nodelists(i)%this)
    enddo
    deallocate(doc%nodelists)
    ! Now put everything back from temp_nll, but discard any lost nodelists
    allocate(doc%nodelists(i_t))
    do i = 1, i_t
      doc%nodelists(i)%this => temp_nll(i)%this
    enddo
    ! And finally, get rid of the temporary list of lists
    deallocate(temp_nll)

  end subroutine updateNodeLists

  



  function getNamedItem(map, name) result(np)
    type(NamedNodeMap), intent(in) :: map
    character(len=*), intent(in) :: name
    type(Node), pointer :: np

    integer :: i

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%nodeName)==name) then
        np => map%nodes(i)%this
        return
      endif
    enddo
    
    np => null()

  end function getNamedItem


  pure function getNamedItem_Value_length(map, name) result(n)
    type(NamedNodeMap), intent(in) :: map
    character(len=*), intent(in) :: name
    integer :: n

    integer :: i

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%nodeName)==name) then
        n = size(map%nodes(i)%this%nodeValue)
        exit
      endif
    enddo
    n = 0

  end function getNamedItem_Value_length


  pure function getNamedItem_Value(map, name) result(c)
    type(NamedNodeMap), intent(in) :: map
    character(len=*), intent(in) :: name
    character(len=getNamedItem_Value_length(map, name)) :: c

    integer :: i

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%nodeName)==name) then
        c = str_vs(map%nodes(i)%this%nodeValue)
        return
      endif
    enddo
    c = ""

  end function getNamedItem_Value


  function setNamedItem(map, arg, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(NamedNodeMap), intent(inout) :: map
    type(Node), pointer :: arg
    type(Node), pointer :: np

    integer :: i

    if (map%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setNamedItem", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.associated(map%ownerElement%ownerDocument, arg%ownerDocument)) then
      call throw_exception(WRONG_DOCUMENT_ERR, "setNamedItem", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (associated(arg%ownerElement)) then
      call throw_exception(INUSE_ATTRIBUTE_ERR, "setNamedItem", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif
    
    endif

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%nodeName)==str_vs(arg%nodeName)) then
        np => map%nodes(i)%this
        map%nodes(i)%this => arg
        return
      endif
    enddo

    !   If not found, insert it at the end of the linked list
    np => null()
    call append(map, arg)

    if (.not.map%ownerElement%ownerDocument%xds%building) then
      ! We need to worry about importing this node
      if (map%ownerElement%inDocument) then
        if (.not.arg%inDocument) &
          call putNodesInDocument(map%ownerElement%ownerDocument, arg)
      else
        if (arg%inDocument) &
          call removeNodesFromDocument(map%ownerElement%ownerDocument, arg)
        endif
    endif

  end function setNamedItem


  function removeNamedItem(map, name, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(NamedNodeMap), intent(inout) :: map
    character(len=*), intent(in) :: name
    type(Node), pointer :: np

    type(ListNode), pointer :: temp_nl(:)
    integer :: i, i2

    if (map%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "removeNamedItem", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%nodeName)==name) then
        ! Grab this node
        np => map%nodes(i)%this
        ! and shrink the node list
        temp_nl => map%nodes
        allocate(map%nodes(size(temp_nl)-1))
        do i2 = 1, i - 1
          map%nodes(i2)%this => temp_nl(i2)%this
        enddo
        do i2 = i + 1, map%length
          map%nodes(i2)%this => temp_nl(i2)%this
        enddo
        deallocate(temp_nl)
        ! and finish
        return
      endif
    enddo

    call throw_exception(NOT_FOUND_ERR, "removeNamedItem", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif


  end function removeNamedItem


  function item_nnm(map, index) result(np)
    type(NamedNodeMap), intent(in) :: map
    integer, intent(in) :: index
    type(Node), pointer :: np
    
    integer :: n

    if (index<0 .or. index>map%length-1) then
      np => null()
    else
      np => map%nodes(index+1)%this
    endif

   end function item_nnm

  function getLength_nnm(map) result(n)
    type(namedNodeMap), intent(in) :: map
    integer :: n

    n = map%length
    
  end function getLength_nnm


  function getNamedItemNS(map, namespaceURI, localName) result(np)
    type(NamedNodeMap), intent(in) :: map
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    type(Node), pointer :: np

    integer :: i

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%namespaceURI)==namespaceURI &
        .and. str_vs(map%nodes(i)%this%localName)==localName) then
        np => map%nodes(i)%this
        return
      endif
    enddo
    
    np => null()

  end function getNamedItemNS


  pure function getNamedItemNS_Value_length(map, namespaceURI, localName) result(n)
    type(NamedNodeMap), intent(in) :: map
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    integer :: n

    integer :: i

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%namespaceURI)==namespaceURI &
        .and. str_vs(map%nodes(i)%this%localName)==localName) then
        n = size(map%nodes(i)%this%nodeValue)
        exit
      endif
    enddo
    n = 0

  end function getNamedItemNS_Value_length


  pure function getNamedItemNS_Value(map, namespaceURI, localName) result(c)
    type(NamedNodeMap), intent(in) :: map
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    character(len=getNamedItemNS_Value_length(map, namespaceURI, localName)) :: c

    integer :: i

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%namespaceURI)==namespaceURI &
        .and. str_vs(map%nodes(i)%this%localName)==localName) then
        c = str_vs(map%nodes(i)%this%nodeValue)
        return
      endif
    enddo
    !FIXME error here

  end function getNamedItemNS_Value


  function setNamedItemNS(map, arg, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(NamedNodeMap), intent(inout) :: map
    type(Node), pointer :: arg
    type(Node), pointer :: np

    integer :: i

    if (map%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setNamedItemNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.associated(map%ownerElement%ownerDocument, arg%ownerDocument)) then
      call throw_exception(WRONG_DOCUMENT_ERR, "setNamedItemNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (associated(arg%ownerElement)) then
      call throw_exception(INUSE_ATTRIBUTE_ERR, "setNamedItemNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif
    
    endif

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%namespaceURI)==str_vs(arg%namespaceURI) &
        .and. str_vs(map%nodes(i)%this%localName)==str_vs(arg%localName)) then
        np => map%nodes(i)%this
        map%nodes(i)%this => arg
        return
      endif
    enddo
    !   If not found, insert it at the end of the linked list
    np => null()
    call append(map, arg)

  end function setNamedItemNS


  function removeNamedItemNS(map, namespaceURI, localName, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(NamedNodeMap), intent(inout) :: map
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    type(Node), pointer :: np

    type(ListNode), pointer :: temp_nl(:)
    integer :: i, i2

    if (map%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "removeNamedItemNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    do i = 1, map%length
      if (str_vs(map%nodes(i)%this%namespaceURI)==namespaceURI &
        .and. str_vs(map%nodes(i)%this%localName)==localName) then
        ! Grab this node
        np => map%nodes(i)%this
        ! and shrink the node list
        temp_nl => map%nodes
        allocate(map%nodes(size(temp_nl)-1))
        do i2 = 1, i - 1
          map%nodes(i2)%this => temp_nl(i2)%this
        enddo
        do i2 = i + 1, map%length
          map%nodes(i2-1)%this => temp_nl(i2)%this
        enddo
        deallocate(temp_nl)
        ! and finish
        return
      endif
    enddo

    call throw_exception(NOT_FOUND_ERR, "removeNamedItemNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif


  end function removeNamedItemNS


  subroutine append_nnm(map, arg)
    type(namedNodeMap), intent(inout) :: map
    type(node), pointer :: arg

    type(ListNode), pointer :: temp_nl(:)
    integer :: i

    if (.not.associated(map%nodes)) then
      allocate(map%nodes(1))
      map%nodes(1)%this => arg
      map%length = 1
    else
      temp_nl => map%nodes
      allocate(map%nodes(size(temp_nl)+1))
      do i = 1, size(temp_nl)
        map%nodes(i)%this => temp_nl(i)%this
      enddo
      deallocate(temp_nl)
      map%nodes(size(map%nodes))%this => arg
      map%length = size(map%nodes)
    endif

  end subroutine append_nnm


  subroutine setReadOnly(map, r)
    type(namedNodeMap), intent(inout) :: map
    logical, intent(in) :: r

    map%readonly = r
  end subroutine setReadOnly

  subroutine destroyNamedNodeMap(map)
    type(namedNodeMap), pointer :: map

    if (associated(map%nodes)) deallocate(map%nodes)
    deallocate(map)
 end subroutine destroyNamedNodeMap



  function hasFeature(impl, feature, version) result(p)
    type(DOMImplementation), intent(in) :: impl
    character(len=*), intent(in) :: feature
    character(len=*), intent(in), optional :: version
    logical :: p

    if (present(version)) then
      if (version/="1.0".and.version/="2.0") then
        p = .false.
        return
      endif
    endif
    p = (toLower(feature)=="core".or.toLower(feature)=="xml")
  end function hasFeature


  function createDocumentType(impl, qualifiedName, publicId, systemId, ex)result(dt) 
    type(DOMException), intent(inout), optional :: ex
    type(DOMImplementation), intent(in) :: impl
    character(len=*), intent(in) :: qualifiedName
    character(len=*), intent(in) :: publicId
    character(len=*), intent(in) :: systemId
    type(Node), pointer :: dt

    allocate(dt%xds)
    call init_xml_doc_state(dt%xds)

    if (.not.checkChars(qualifiedName, XML1_0)) then
      call throw_exception(INVALID_CHARACTER_ERR, "createDocumentType", ex)
if (present(ex)) then
  if (is_in_error(ex)) then

if (associated(dt%xds)) deallocate(dt%xds)
     return
  endif
endif

    endif

    if (.not.checkName(qualifiedName, dt%xds)) then
      call throw_exception(NAMESPACE_ERR, "createDocumentType", ex)
if (present(ex)) then
  if (is_in_error(ex)) then

if (associated(dt%xds)) deallocate(dt%xds)
     return
  endif
endif

    ! FIXME check that prefix etc is declared
    elseif (.not.checkPublicId(publicId)) then
      call throw_exception(FoX_INVALID_PUBLIC_ID, "createDocumentType", ex)
if (present(ex)) then
  if (is_in_error(ex)) then

if (associated(dt%xds)) deallocate(dt%xds)
     return
  endif
endif

    elseif (.not.checkSystemId(systemId)) then
      call throw_exception(FoX_INVALID_SYSTEM_ID, "createDocumentType", ex)
if (present(ex)) then
  if (is_in_error(ex)) then

if (associated(dt%xds)) deallocate(dt%xds)
     return
  endif
endif

    endif

    dt => createNode(null(), DOCUMENT_TYPE_NODE, qualifiedName, "")
    dt%readonly = .true.
    dt%publicId = vs_str_alloc(publicId)
    dt%systemId = vs_str_alloc(systemId)
    allocate(dt%internalSubset(0)) !FIXME
    dt%ownerDocument => null()
    dt%entities%ownerElement => dt
    dt%notations%ownerElement => dt
    ! FIXME fill in the rest of the fields ...

  end function createDocumentType


  function createEmptyDocumentType(doc) result(dt)
    type(Node), pointer :: doc
    type(Node), pointer :: dt

    dt => createNode(doc, DOCUMENT_TYPE_NODE, "", "")
    dt%readonly = .true.
    !dt%entities
    !dt%notations
    allocate(dt%publicId(0))
    allocate(dt%systemId(0))
    allocate(dt%internalSubset(0)) !FIXME

    dt%entities%ownerElement => dt
    dt%notations%ownerElement => dt

    allocate(dt%xds)
    call init_xml_doc_state(dt%xds)
  end function createEmptyDocumentType


  subroutine replace_xds(dt, xds)
    type(Node), pointer :: dt
    type(xml_doc_state), pointer :: xds

    print*, "XDS", xds%xml_version

    call destroy_xml_doc_state(dt%xds)
    deallocate(dt%xds)
    dt%xds => xds
  end subroutine replace_xds


  function createDocument(impl, namespaceURI, qualifiedName, docType) result(doc)
    type(DOMImplementation), intent(in) :: impl
    character(len=*), intent(in), optional :: namespaceURI
    character(len=*), intent(in), optional :: qualifiedName
    type(Node), pointer, optional :: docType
    type(Node), pointer :: doc, dt

     !FIXMEFIXMEFIXME optional arguments and errors
    ! FIXME change to match empytdocument below

    doc => createNode(null(), DOCUMENT_NODE, "#document", "")

    if (present(docType)) then
      docType%ownerDocument => doc
      doc%doctype => appendChild(doc, doc%docType)
    endif
    if (.not.associated(doc%docType)) then
      dt => createDocumentType(impl, qualifiedName, "", "")
      dt%ownerDocument => doc
      doc%docType => appendChild(doc, dt)
    endif

    doc%docType%ownerElement => doc
    doc%implementation => FoX_DOM
    doc%documentElement => appendChild(doc, createElementNS(doc, namespaceURI, qualifiedName))

    doc%xds => doc%docType%xds
    allocate(doc%nodelists(0))

  end function createDocument


  function createEmptyDocument() result(doc)
    type(Node), pointer :: doc
    type(Node), pointer :: dt
    
    print*,"creating empty document"
    doc => createNode(null(), DOCUMENT_NODE, "#document", "")
    print*,"created"
    dt => createEmptyDocumentType(doc)
    doc%xds => dt%xds
    doc%ownerDocument => doc

    ! FIXME do something with namespaceURI etc 
    doc%doctype => appendChild(doc, dt)
    doc%implementation => FoX_DOM
    doc%documentElement => null()
    allocate(doc%nodelists(0))

  end function createEmptyDocument


  subroutine destroyDocument(doc, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    
    type(NodeList) :: np_stack
    integer :: i

! Switch off all GC - since this is GC!
    call setDocBuilding(doc, .true.)

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "destroyDocument", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    call destroyAllNodesRecursively(doc)

    ! Destroy all remaining nodelists
    do i = 1, size(doc%nodelists)
      call destroy(doc%nodelists(i)%this)
    enddo
    deallocate(doc%nodelists)

    ! Destroy all remaining hanging nodes
    print*,"DANGLING NODES", doc%hangingNodes%length
    do i = 1, doc%hangingNodes%length
      print*,"killing dangling nodes"
      call destroy(doc%hangingNodes%nodes(i)%this)
    enddo
    deallocate(doc%hangingNodes%nodes)

    print*, "destroying a node:", doc%nodeType, doc%nodeName
    call destroyNodeContents(doc)
    deallocate(doc)

  end subroutine destroyDocument



  ! Getters and setters:

  function getDocType(doc, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: doc
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getDocType", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    np => doc%docType

  end function getDocType

  function getImplementation(doc, ex)result(imp) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: doc
    type(DOMImplementation), pointer :: imp

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getImplementation", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    imp => doc%implementation
    
  end function getImplementation

  function getDocumentElement(doc, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: doc
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getDocumentElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    np => doc%documentElement

  end function getDocumentElement

  subroutine setDocumentElement(doc, np, ex)
    type(DOMException), intent(inout), optional :: ex
  ! Only for use by FoX, not exported through FoX_DOM interface
    type(Node), pointer :: doc
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setDocumentElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (np%nodeType/=ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setDocumentElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.associated(np%ownerDocument, doc)) then
      call throw_exception(WRONG_DOCUMENT_ERR, "setDocumentElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    doc%documentElement => np

  end subroutine setDocumentElement

  ! Methods

  function createElement(doc, tagName, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: tagName
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    else if (.not.checkChars(tagName, doc%docType%xds%xml_version)) then
      call throw_exception(INVALID_CHARACTER_ERR, "createElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif  
    if (.not.checkName(tagName, doc%docType%xds)) then
      call throw_exception(FoX_INVALID_XML_NAME, "createElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    np => createNode(doc, ELEMENT_NODE, tagName, "")
    np%attributes%ownerElement => np

    ! FIXME set namespaceURI and localName appropriately

    if (.not.doc%docType%xds%building) then
      np%inDocument = .false.
      call append(doc%hangingnodes, np)
    else
      np%inDocument = .true.
    endif

  end function createElement
    
  function createDocumentFragment(doc, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createDocumentFragment", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    np => createNode(doc, DOCUMENT_FRAGMENT_NODE, "", "")
    if (.not.doc%docType%xds%building) then
      np%inDocument = .false.
      call append(doc%hangingnodes, np)
    else
      np%inDocument = .true.
    endif

  end function createDocumentFragment

  function createTextNode(doc, data, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: data
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createTextNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(data, doc%docType%xds%xml_version)) then
      call throw_exception(FoX_INVALID_CHARACTER, "createTextNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => createNode(doc, TEXT_NODE, "#text", data)

    if (.not.doc%docType%xds%building) then
      np%inDocument = .false.
      call append(doc%hangingnodes, np)
    else
      np%inDocument = .true.
    endif
   
  end function createTextNode

  function createComment(doc, data, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: data
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createComment", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(data, doc%xds%xml_version)) then
      call throw_exception(FoX_INVALID_CHARACTER, "createComment", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (index(data,"--")>0) then   
      call throw_exception(FoX_INVALID_COMMENT, "createComment", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
  
    np => createNode(doc, COMMENT_NODE, "#comment", data)

    if (.not.doc%docType%xds%building) then
      np%inDocument = .false.
      call append(doc%hangingnodes, np)
    else
      np%inDocument = .true.
    endif

  end function createComment

  function createCdataSection(doc, data, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: data
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createCdataSection", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(data, doc%xds%xml_version)) then
      call throw_exception(FoX_INVALID_CHARACTER, "createCdataSection", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (index(data,"]]>")>0) then   
      call throw_exception(FoX_INVALID_CDATA_SECTION, "createCdataSection", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
  
    np => createNode(doc, CDATA_SECTION_NODE, "#text", data)

    if (.not.doc%docType%xds%building) then
      np%inDocument = .false.
      call append(doc%hangingnodes, np)
    else
      np%inDocument = .true.
    endif
  
  end function createCdataSection

  function createProcessingInstruction(doc, target, data, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: target
    character(len=*), intent(in) :: data
    type(Node), pointer :: np


    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createProcessingInstruction", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(target, doc%xds%xml_version)) then
      call throw_exception(INVALID_CHARACTER_ERR, "createProcessingInstruction", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(data, doc%xds%xml_version)) then
      call throw_exception(FoX_INVALID_CHARACTER, "createProcessingInstruction", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkName(target, doc%xds)) then
      call throw_exception(FoX_INVALID_XML_NAME, "createProcessingInstruction", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

! FIXME check validity of PI target 
    elseif (index(data,"?>")>0) then   
      call throw_exception(FoX_INVALID_PI_DATA, "createProcessingInstruction", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => createNode(doc, PROCESSING_INSTRUCTION_NODE, target, data)

    if (.not.doc%docType%xds%building) then
      np%inDocument = .false.
      call append(doc%hangingnodes, np)
    else
      np%inDocument = .true.
    endif

  end function createProcessingInstruction

  function createAttribute(doc, name, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: name
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(name, doc%xds%xml_version)) then
      call throw_exception(INVALID_CHARACTER_ERR, "createAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkName(name, doc%xds)) then
      call throw_exception(FoX_INVALID_XML_NAME, "createAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
  
    np => createAttributeNS(doc, "", name)

    if (.not.doc%docType%xds%building) then
      np%inDocument = .false.
      call append(doc%hangingnodes, np)
    else
      np%inDocument = .true.
    endif
  
  end function createAttribute

  function createEntityReference(doc, name, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: name
    type(Node), pointer :: np

    type(Node), pointer :: ent

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createEntityReference", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(name, doc%xds%xml_version)) then
      call throw_exception(INVALID_CHARACTER_ERR, "createEntityReference", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkName(name, doc%xds)) then
      call throw_exception(FoX_INVALID_XML_NAME, "createEntityReference", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => createNode(doc, ENTITY_REFERENCE_NODE, name, "")

    ent => getNamedItem(doc%docType%entities, name)

    print*,"CREATING ENTITIES", name
    print*, "LENGTH", getLength(doc%docType%entities)
    print*, associated(ent)

    if (associated(ent)) then
      ! FIXME here we should actually parse the entity reference
      ! and add all its children.
      ! This works if it is just text though.
      ent => appendChild(np, cloneNode(ent%firstChild, .true., ex))
    endif
    ! FIXME all children should be readonly at this stage.
    ! FIXME all cloned children need to be marked ...
    if (.not.doc%docType%xds%building) then
      np%inDocument = .false.
      call append(doc%hangingnodes, np)
    else
      np%inDocument = .true.
    endif

  end function createEntityReference

  function getElementsByTagName(doc, tagName, name, ex)result(list) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in), optional :: tagName, name
    type(NodeList), pointer :: list

    type(NodeListPtr), pointer :: nll(:), temp_nll(:)
    type(Node), pointer :: np
    logical :: ascending, allElements
    integer :: i

! FIXME check name and tagname for doc/element respectively ...

    if (doc%nodeType/=DOCUMENT_NODE.and.doc%nodeType/=ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getElementsByTagName", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (tagName=="*") &
      allElements = .true.

    if (doc%nodeType==DOCUMENT_NODE) then
      np => doc%documentElement
    else
      np => doc
    endif

    if (.not.associated(np)) then
      ! FIXME internal error
      continue
    endif

    allocate(list)
    allocate(list%nodes(0))
    list%element => doc
    list%nodeName => vs_str_alloc(name) ! FIXME or tagName

    if (doc%nodeType==DOCUMENT_NODE) then
      nll => doc%nodeLists
    elseif (doc%nodeType==ELEMENT_NODE) then
      nll => doc%ownerDocument%nodeLists
    endif
    allocate(temp_nll(size(nll)+1))
    do i = 1, size(nll)
      temp_nll(i)%this => nll(i)%this
    enddo
    temp_nll(i)%this => list

    ascending = .false.
    do
      if (ascending) then
        np => np%parentNode
        if (associated(np, doc).or.associated(np, doc%documentElement)) exit
        ascending = .false.
      elseif (associated(np%firstChild)) then
        np => np%firstChild
        cycle
      endif
      if ((np%nodeType==ELEMENT_NODE) .and. &
        (allElements .or. str_vs(np%nodeName)==tagName)) then
        call append(list, np)
      endif
      if (associated(np%nextSibling)) then
        np => np%nextSibling
      else
        ascending = .true.
      endif
    enddo

  end function getElementsByTagName

  function importNode(doc , arg, deep , ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    type(Node), pointer :: arg
    logical, intent(in) :: deep
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "importNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    select case(arg%nodeType)
    case (ATTRIBUTE_NODE)
      np => cloneNode(arg, deep, ex)
      np%ownerElement => null()
      np%specified = .true.
    case (DOCUMENT_NODE)
      call throw_exception(NOT_SUPPORTED_ERR, "importNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (DOCUMENT_TYPE_NODE)
      call throw_exception(NOT_SUPPORTED_ERR, "importNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (ELEMENT_NODE)
      np => cloneNode(arg, deep, ex)
! FIXME strip out unspecified attributes unless they are also default in this doc ...
    case (ENTITY_REFERENCE_NODE)
      np => cloneNode(arg, .false., ex)
! FIXME if entity is defined in this doc then add appropriate children
    case default
      np => cloneNode(arg, deep, ex)
    end select

    np%ownerDocument => doc
    np%parentNode => null()

    ! FIXME need to ensure that inDocument & hanging nodes are set
    ! appropriately.

  end function importNode

  function createElementNS(doc, namespaceURI, qualifiedName, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: namespaceURI, qualifiedName
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createElementNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(qualifiedName, doc%xds%xml_version)) then
      call throw_exception(INVALID_CHARACTER_ERR, "createElementNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkQName(qualifiedName, doc%xds)) then
      call throw_exception(NAMESPACE_ERR, "createElementNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (prefixOfQName(qualifiedName)/="" &
     .and. namespaceURI=="") then
      call throw_exception(NAMESPACE_ERR, "createElementNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (prefixOfQName(qualifiedName)=="xml" .and. &
      namespaceURI/="http://www.w3.org/XML/1998/namespace") then
      call throw_exception(NAMESPACE_ERR, "createElementNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    ! FIXME is this all possible errors?
      ! what if prefix = "xmlns"? or other "xml"
    endif

    ! FIXME create a namespace node for XPath?

    np => createNode(doc, ELEMENT_NODE, qualifiedName, "")
    np%namespaceURI => vs_str_alloc(namespaceURI)
    np%prefix => vs_str_alloc(prefixOfQName(qualifiedname))
    np%localName => vs_str_alloc(localpartOfQName(qualifiedname))

    np%attributes%ownerElement => np

    if (.not.doc%docType%xds%building) then
      np%inDocument = .false.
      call append(doc%hangingnodes, np)
    else
      np%inDocument = .true.
    endif

    ! FIXME updateNodeLists

  end function createElementNS
  
  function createAttributeNS(doc, namespaceURI, qualifiedname, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: namespaceURI, qualifiedName
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(qualifiedName, doc%xds%xml_version)) then
      call throw_exception(INVALID_CHARACTER_ERR, "createAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkQName(qualifiedName, doc%xds)) then
      call throw_exception(NAMESPACE_ERR, "createAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (prefixOfQName(qualifiedName)/="" &
     .and. namespaceURI=="") then
      call throw_exception(NAMESPACE_ERR, "createAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (prefixOfQName(qualifiedName)=="xml" .and. &
      namespaceURI/="http://www.w3.org/XML/1998/namespace") then
      call throw_exception(NAMESPACE_ERR, "createAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    ! FIXME is this all possible errors?
      ! what if prefix = "xmlns"? or other "xml"
    endif
  
    np => createNode(doc, ATTRIBUTE_NODE, qualifiedName, "")
    np%namespaceURI => vs_str_alloc(namespaceURI)
    np%localname => vs_str_alloc(localPartofQName(qualifiedname))
    np%prefix => vs_str_alloc(PrefixofQName(qualifiedname))

    if (.not.doc%docType%xds%building) then
      np%inDocument = .false.
      call append(doc%hangingnodes, np)
    else
      np%inDocument = .true.
    endif

  end function createAttributeNS

  function getElementsByTagNameNS(doc, namespaceURI, localName, ex)result(list) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: namespaceURI, localName
    type(NodeList), pointer :: list

    type(NodeListPtr), pointer :: nll(:), temp_nll(:)
    type(Node), pointer :: np
    logical :: noChild, allLocalNames, allNameSpaces
    integer :: i

    if (doc%nodeType/=DOCUMENT_NODE.and.doc%nodeType/=ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getElementsByTagNameNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (namespaceURI=="*") &
      allNameSpaces = .true.
    if (localName=="*") &
      allLocalNames = .true.

    if (doc%nodeType==DOCUMENT_NODE) then
      np => doc%documentElement
    else
      np => doc
    endif

    if (.not.associated(np)) then
      ! FIXME internal error
      continue
    endif

    allocate(list)
    allocate(list%nodes(0))
    list%element => doc
    list%localName => vs_str_alloc(localName)
    list%namespaceURI => vs_str_alloc(namespaceURI)

    if (doc%nodeType==DOCUMENT_NODE) then
      nll => doc%nodeLists
    elseif (doc%nodeType==ELEMENT_NODE) then
      nll => doc%ownerDocument%nodeLists
    endif
    allocate(temp_nll(size(nll)+1))
    do i = 1, size(nll)
      temp_nll(i)%this => nll(i)%this
    enddo
    temp_nll(i)%this => list

    noChild = .false.
    do
      if (noChild) then
        if (associated(np, doc).or.associated(np, doc%documentElement)) then
          exit
        else
          np => np%parentNode
          noChild=  .false.
        endif
      endif
      if ((np%nodeType==ELEMENT_NODE) &
        .and. (allNameSpaces .or. str_vs(np%namespaceURI)==namespaceURI) &
        .and. (allLocalNames .or. str_vs(np%localName)==localName)) then
        call append(list, np)
      endif
      if (associated(np%firstChild)) then
        np => np%firstChild
      elseif (associated(np%nextSibling)) then
        np => np%nextSibling
      else
        noChild = .true.
      endif
    enddo

  end function getElementsByTagNameNS


  function getElementById(doc, elementId, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: elementId
    type(Node), pointer :: np

    type(Node), pointer :: attr
    type(NamedNodeMap), pointer :: nnm
    integer :: i
    logical :: noChild

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getElementById", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => doc%documentELement

    noChild = .false.
    do
      if (noChild) then
        if (associated(np, doc).or.associated(np, doc%documentElement)) then
          exit
        else
          np => np%parentNode
          noChild=  .false.
        endif
      endif
      if (np%nodeType==ELEMENT_NODE) then
        nnm => np%attributes
        do i = 1, getLength(nnm)
          attr => item(nnm, i)
          if (attr%isId.and.getValue(attr)==elementId) &
            return
        enddo
      endif
      if (associated(np%firstChild)) then
        np => np%firstChild
      elseif (associated(np%nextSibling)) then
        np => np%nextSibling
      else
        noChild = .true.
      endif
    enddo

    np => null()

  end function getElementById

!  function getInputEncoding
!  function getXmlEncoding
!  function getXmlStandalone
!  function setXmlStandalone


  function getXmlVersion(doc, ex)result(s) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=3) :: s

    if (doc%xds%xml_version==XML1_0) then
      s = "1.0"
    elseif (doc%xds%xml_version==XML1_1) then
      s = "1.1"
    endif

  end function getXmlVersion

  subroutine setXmlVersion(doc, s, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*) :: s

    if (s=="1.0") then
      doc%xds%xml_version = XML1_0
    elseif (s=="1.1") then
      doc%xds%xml_version = XML1_1
    else
      call throw_exception(NOT_SUPPORTED_ERR, "setXmlVersion", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

  end subroutine setXmlVersion


!  function getStrictErrorChecking
!  function setStrictErrorChecking
!  function getDocumentURI
!  function setDocumentURI

  ! Internal function, not part of API

  function createEntity(doc, name, publicId, systemId, notationName) result(np)
    type(Node), pointer :: doc
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: publicId
    character(len=*), intent(in) :: systemId
    character(len=*), intent(in) :: notationName
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      print*,"internal error in createEntity"
      stop
    endif

    np => createNode(doc, ENTITY_NODE, name, "")
    np%publicId => vs_str_alloc(publicId)
    np%systemId => vs_str_alloc(systemId)
    np%notationName => vs_str_alloc(notationName)

  end function createEntity

  function createNotation(doc, name, publicId, systemId) result(np)
    type(Node), pointer :: doc
    character(len=*), intent(in) :: name
    character(len=*), intent(in), optional :: publicId
    character(len=*), intent(in), optional :: systemId
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      print*,"internal error in createEntity"
      stop
    endif

    np => createNode(doc, NOTATION_NODE, name, "")
    if (present(publicId)) np%publicId => vs_str_alloc(publicId)
    if (present(systemId)) np%systemId => vs_str_alloc(systemId)
    
  end function createNotation



!  function getName(docType) result(c) See m_dom_common

  function getEntities(docType) result(nnp)
    type(Node), pointer :: docType
    type(NamedNodeMap), pointer :: nnp

    if (docType%nodeType/=DOCUMENT_TYPE_NODE) then
      ! FIXME error
      continue
    endif

    nnp => docType%entities
  end function getEntities

  function getNotations(docType) result(nnp)
    type(Node), pointer :: docType
    type(NamedNodeMap), pointer :: nnp

    if (docType%nodeType/=DOCUMENT_TYPE_NODE) then
      ! FIXME error
      continue
    endif

    nnp => docType%notations
  end function getNotations


!  function getPublicId(docType) result(c) See m_dom_common


!  function getSystemId(docType) result(c) See m_dom_common


  function getInternalSubset(docType) result(c)
    type(Node), intent(in) :: docType
    character(len=size(docType%internalSubset)) :: c

    if (docType%nodeType/=DOCUMENT_TYPE_NODE) then
      ! FIXME error
      continue
    endif

    c = str_vs(docType%internalSubset)
  end function getInternalSubset


  subroutine setDocType(docType, name, publicId, systemId)
    type(Node), intent(inout) :: docType
    character(len=*), intent(in) :: name
    character(len=*), intent(in), optional :: publicId
    character(len=*), intent(in), optional :: systemId

    if (docType%nodeType/=DOCUMENT_TYPE_NODE) then
      ! FIXME throw an internal error
      continue
    endif
    
    deallocate(docType%nodeName)
    docType%nodeName => vs_str_alloc(name)
    if (present(publicId)) then
      deallocate(docType%publicId)
      docType%publicId => vs_str_alloc(publicId)
    endif
    if (present(systemId)) then
      deallocate(docType%systemId)
      docType%systemId => vs_str_alloc(systemId)
    endif

  end subroutine setDocType



  function getTagName(element, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: element   
    character(len=size(element%nodeName)) :: c

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getTagName", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    c = str_vs(element%nodeName)    
     
  end function getTagName

    
  function getAttribute(element, name, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: element
    character(len=*), intent(in) :: name
    character(len=getNamedItem_Value_length(element%attributes, name)) :: c

    type(Node), pointer :: nn

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    c = ""  ! as per specs, if not found
    c = getNamedItem_Value(element%attributes, name)

    ! FIXME do we need to catch the exception above if it doesnt exist?
        
  end function getAttribute


  subroutine setAttribute(element, name, value, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: value

    type(Node), pointer :: nn, dummy
    logical :: quickFix

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif


      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(name, element%ownerDocument%docType%xds%xml_version)) then
      call throw_exception(INVALID_CHARACTER_ERR, "setAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkName(value, element%ownerDocument%docType%xds)) then
      call throw_exception(FoX_INVALID_XML_NAME, "setAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(value, element%ownerDocument%docType%xds%xml_version)) then
      call throw_exception(FoX_INVALID_CHARACTER, "setAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    quickFix = .not.element%ownerDocument%xds%building &
      .and. element%inDocument

    if (quickFix) call setDocBuilding(element%ownerDocument, .true.)
    ! then the created attribute is going straight into the document,
    ! so dont faff with hanging-node lists.

    nn => createAttribute(element%ownerDocument, name)
    call setValue(nn, value)

    dummy => setNamedItem(element%attributes, nn)
    nn%ownerElement => element

    if (quickFix) call setDocBuilding(element%ownerDocument, .true.)

  end subroutine setAttribute


  subroutine removeAttribute(element, name, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    character(len=*), intent(in) :: name

    type(Node), pointer :: dummy

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "removeAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    dummy => removeNamedItem(element%attributes, name)
    call destroyAttribute(dummy)

  ! FIXME recreate a default value if there is one
     
  end subroutine removeAttribute


  function getAttributeNode(element, name, ex)result(attr) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: element
    character(len=*), intent(in) :: name
    type(Node), pointer :: attr

    attr => null()     ! as per specs, if not foundo

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getAttributeNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    attr => getNamedItem(element%attributes, name)

    ! FIXME catch and throw away exception

  end function getAttributeNode
  

  function setAttributeNode(element, newattr, ex)result(attr) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    type(Node), pointer :: newattr
    type(Node), pointer :: attr
    type(Node), pointer :: dummy

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setAttributeNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.associated(element%ownerDocument, newattr%ownerDocument)) then
      call throw_exception(WRONG_DOCUMENT_ERR, "setAttributeNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (element%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setAttributeNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (associated(attr%ownerElement)) then
      call throw_exception(INUSE_ATTRIBUTE_ERR, "setAttributeNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    ! this checks if attribute exists already
    dummy => setNamedItem(element%attributes, newattr, ex)
    attr%ownerElement => element

    ! FIXME hangingnodes

  end function setAttributeNode


  function removeAttributeNode(element, oldattr, ex)result(attr) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    type(Node), pointer :: oldattr
    type(Node), pointer :: attr

    integer :: i

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "removeAttributeNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (element%readonly) then
      call throw_exception(WRONG_DOCUMENT_ERR, "removeAttributeNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    do i = 1, element%attributes%length
      if (associated(item(element%attributes, i), oldattr)) then
        attr => removeNamedItem(element%attributes, str_vs(oldattr%nodeName))
        return
      endif
    enddo

    call throw_exception(NOT_FOUND_ERR, "removeAttributeNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif


    attr%ownerElement => null()

    ! FIXME hangingnodes

  end function removeAttributeNode


!  function getElementsByTagName - see m_dom_document


  function getAttributeNS(element, namespaceURI, localName, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: element
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    character(len= &
      getNamedItemNS_Value_length(element%attributes, namespaceURI, localName)) :: c

    type(Node), pointer :: nn

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    c = ""  ! as per specs, if not found Not sure ahout this FIXME
    c = getNamedItemNS_Value(element%attributes, namespaceURI, localName)

    ! FIXME dont need both above
        
  end function getAttributeNS


  subroutine setAttributeNS(element, namespaceURI, qualifiedname, value, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: qualifiedName
    character(len=*), intent(in) :: value

    type(Node), pointer :: nn, dummy
    logical :: quickfix

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(qualifiedname, element%ownerDocument%docType%xds%xml_version)) then
      call throw_exception(INVALID_CHARACTER_ERR, "setAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (element%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkQName(qualifiedname, element%ownerDocument%docType%xds)) then
      call throw_exception(NAMESPACE_ERR, "setAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (prefixOfQName(qualifiedName)/="" &
     .and. namespaceURI=="") then
      call throw_exception(NAMESPACE_ERR, "setAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (prefixOfQName(qualifiedName)=="xml" .and. & 
      namespaceURI/="http://www.w3.org/XML/1998/namespace") then
      call throw_exception(NAMESPACE_ERR, "setAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    ! FIXME is this all possible errors? 
      ! what if prefix = "xmlns"? or other "xml"
    endif

! FIXME what if namespace is undeclared ... will be recreated on serialization,
! but we might need a new namespace node here for xpath ...

    quickFix = .not.element%ownerDocument%xds%building &
      .and. element%inDocument

    if (quickFix) call setDocBuilding(element%ownerDocument, .true.)
    ! then the created attribute is going straight into the document,
    ! so dont faff with hanging-node lists.

    nn => createAttributeNS(element%ownerDocument, namespaceURI, qualifiedname)
    call setValue(nn, value)

    dummy => setNamedItemNS(element%attributes, nn)
    nn%ownerElement => element

    if (quickFix) call setDocBuilding(element%ownerDocument, .true.)

    !FIXME catch exception

  end subroutine setAttributeNS


  subroutine removeAttributeNS(element, namespaceURI, localName, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName

    type(Node), pointer :: dummy

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "removeAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (element%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "removeAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    dummy => removeNamedItemNS(element%attributes, namespaceURI, localName)

    call destroyAttribute(dummy)
     
  end subroutine removeAttributeNS


  function getAttributeNodeNS(element, namespaceURI, localName, ex)result(attr) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: element
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    type(Node), pointer :: attr

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getAttributeNodeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    attr => null()     ! as per specs, if not found
    attr => getNamedItemNS(element%attributes, namespaceURI, localname)

  end function getAttributeNodeNS
  

  function setAttributeNodeNS(element, newattr, ex)result(attr) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    type(Node), pointer :: newattr
    type(Node), pointer :: attr
    type(Node), pointer :: dummy

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setAttributeNodeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.associated(element%ownerDocument, newattr%ownerDocument)) then
      call throw_exception(WRONG_DOCUMENT_ERR, "setAttributeNodeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (element%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setAttributeNodeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (associated(attr%ownerElement)) then
      call throw_exception(INUSE_ATTRIBUTE_ERR, "setAttributeNodeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    ! this checks if attribute exists already
    dummy => setNamedItemNS(element%attributes, newattr)
    attr%ownerElement => element

    ! FIXME hangingnodes

  end function setAttributeNodeNS


  function removeAttributeNodeNS(element, oldattr, ex)result(attr) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: element
    type(Node), pointer :: oldattr
    type(Node), pointer :: attr

    integer :: i

    if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "removeAttributeNodeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (element%readonly) then
      call throw_exception(WRONG_DOCUMENT_ERR, "removeAttributeNodeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    do i = 1, element%attributes%length
      if (associated(item(element%attributes, i), oldattr)) then
        attr => removeNamedItemNS(element%attributes, &
          str_vs(oldattr%namespaceURI), str_vs(oldattr%localName))
        return
      endif
    enddo

    call throw_exception(NOT_FOUND_ERR, "removeAttributeNodeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif


    attr%ownerElement => null()
    ! FIXME hangingnodes
  end function removeAttributeNodeNS


!  function getElementsByTagNameNS - see m_dom_document


  function hasAttribute(element, name, ex)result(p) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: element
    character(len=*), intent(in) :: name
    logical :: p

    integer :: i
 
   if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "hasAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    p = .false.
    do i = 1, element%attributes%length
      if (str_vs(element%attributes%nodes(i)%this%nodeName)==name) then
        p = .true.
        exit
      endif
    enddo

  end function hasAttribute


  function hasAttributeNS(element, namespaceURI, localName, ex)result(p) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: element
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    logical :: p

    integer :: i

 
   if (element%nodeType /= ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "hasAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    p = .false.
    do i = 1, element%attributes%length
      if (str_vs(element%attributes%nodes(i)%this%namespaceURI)==namespaceURI &
        .and. str_vs(element%attributes%nodes(i)%this%localName)==localName) then
        p = .true.
        exit
      endif
    enddo

  end function hasAttributeNS

! setIdAttribute
! setIdAttributeNS
! setIdAttributeNode


  
  ! function getName(attribute) result(c) See m_dom_common

! NB All functions manipulating attributes play with the nodelist
! directly rather than through helper functions.
! This is so that getValue_length can be pure,  and the nodeList
! can be explicitly kept up to dat.


  function getSpecified(attribute, ex)result(p) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: attribute
    logical :: p

    if (attribute%nodeType/=ATTRIBUTE_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getSpecified", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    p = attribute%specified
  end function getSpecified
    
  pure function getValue_length(attribute) result(n)
    type(Node), intent(in) :: attribute
    integer :: n

    integer :: i

    n = 0
    do i = 1, attribute%childNodes%length
      if (attribute%childNodes%nodes(i)%this%nodeType==TEXT_NODE) then
        n = n + size(attribute%childNodes%nodes(i)%this%nodeValue)
      else
    ! FIXME get entity length
      endif
    enddo

  end function getValue_length

  function getValue_DOM(attribute, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: attribute
    character(len=getValue_length(attribute)) :: c 

    integer :: i, n

    if (attribute%nodeType/=ATTRIBUTE_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getValue_DOM", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    n = 1
    print*, "we have ",  attribute%childNodes%length, "children."
    do i = 1, attribute%childNodes%length
      if (attribute%childNodes%nodes(i)%this%nodeType==TEXT_NODE) then
        c(n:n+size(attribute%childNodes%nodes(i)%this%nodeValue)-1) = &
          str_vs(attribute%childNodes%nodes(i)%this%nodeValue)
      else
    ! FIXME get entity value
      endif
    enddo

  end function getValue_DOM


  subroutine setValue(attribute, value, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: attribute
    character(len=*), intent(in) :: value

    type(Node), pointer :: np
    integer :: i

    if (attribute%nodeType/=ATTRIBUTE_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (attribute%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(value, attribute%ownerDocument%xds%xml_version)) then
      call throw_exception(FoX_INVALID_CHARACTER, "setValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    do i = 1, attribute%childNodes%length
      call destroyNode(attribute%childNodes%nodes(i)%this)
    enddo
    deallocate(attribute%childNodes%nodes)
    allocate(attribute%childNodes%nodes(0))
    attribute%childNodes%length = 0
    attribute%firstChild => null()
    attribute%lastChild => null()
    np => createTextNode(attribute%ownerDocument, value)
    np => appendChild(attribute, np)

  end subroutine setValue


  function getOwnerElement(attribute, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: attribute
    type(Node), pointer :: np

    if (attribute%nodeType /= ATTRIBUTE_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getOwnerElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => attribute%ownerElement

  end function getOwnerElement



  pure function isCharData(nodeType) result(p)
    integer, intent(in) :: nodeType
    logical :: p

    p = (nodeType == TEXT_NODE .or. &
      nodeType == COMMENT_NODE .or. &
      nodeType == CDATA_SECTION_NODE)
  end function isCharData


  function getLength_characterdata(arg) result(n)
    type(Node), intent(in) :: arg
    integer :: n
    if (isCharData(arg%nodeType)) then
       n = size(arg%nodeValue)
    else
       n = 0 ! FIXME error
    endif
  end function getLength_characterdata


  function subStringData(arg, offset, count, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: arg
    integer, intent(in) :: offset
    integer, intent(in) :: count
    character(len=count) :: c

    ! FIXME error if offset/count are out of range
    
    if (offset<0 .or. count<0) then
      call throw_exception(INDEX_SIZE_ERR, "subStringData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (isCharData(arg%nodeType)) then
      c = str_vs(arg%nodeValue(offset:offset+count-1))
    else
      continue
      ! FIXME error
    endif
  end function subStringData


  subroutine appendData(arg, data, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(inout) :: arg
    character(len=*), intent(in) :: data
    
    character, pointer :: tmp(:)

    if (isCharData(arg%nodeType)) then
      call throw_exception(FoX_INVALID_NODE, "appendData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "appendData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not.checkChars(data, arg%ownerDocument%xds%xml_version)) then
      call throw_exception(FoX_INVALID_CHARACTER, "appendData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    tmp => arg%nodeValue
    arg%nodeValue => vs_str_alloc(str_vs(tmp)//data)
    deallocate(tmp)

    ! We have to do these checks *after* appending data in case offending string
    ! spans old & new data
    if (arg%nodeType==COMMENT_NODE .and. index(str_vs(arg%nodeValue),"--")>0) then
      call throw_exception(FoX_INVALID_COMMENT, "appendData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%nodeType==CDATA_SECTION_NODE .and. index(str_vs(arg%nodeValue), "]]>")>0) then
      call throw_exception(FoX_INVALID_CDATA_SECTION, "appendData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

  end subroutine appendData
  

  subroutine insertData(arg, offset, data, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(inout) :: arg
    integer, intent(in) :: offset
    character(len=*), intent(in) :: data

    character, pointer :: tmp(:)

    if (isCharData(arg%nodeType)) then
      call throw_exception(FoX_INVALID_NODE, "insertData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "insertData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (offset<0) then
      call throw_exception(INDEX_SIZE_ERR, "insertData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not.checkChars(data, arg%ownerDocument%xds%xml_version)) then
      call throw_exception(FoX_INVALID_CHARACTER, "insertData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    tmp => arg%nodeValue
    arg%nodeValue => vs_str_alloc(str_vs(tmp(:offset))//data//str_vs(tmp(offset+1:)))
    deallocate(tmp)

    ! We have to do these checks *after* appending data in case offending string
    ! spans old & new data
    if (arg%nodeType==COMMENT_NODE .and. index(str_vs(arg%nodeValue),"--")>0) then
      call throw_exception(FoX_INVALID_COMMENT, "insertData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%nodeType==CDATA_SECTION_NODE .and. index(str_vs(arg%nodeValue), "]]>")>0) then
      call throw_exception(FoX_INVALID_CDATA_SECTION, "insertData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

  end subroutine insertData


  subroutine deleteData(arg, offset, count, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(inout) :: arg
    integer, intent(in) :: offset
    integer, intent(in) :: count

    character, pointer :: tmp(:)

    if (isCharData(arg%nodeType)) then
      call throw_exception(FoX_INVALID_NODE, "deleteData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "deleteData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (offset<0 .or. count<0) then
      call throw_exception(INDEX_SIZE_ERR, "deleteData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    tmp => arg%nodeValue
    arg%nodeValue => vs_str_alloc(str_vs(tmp(:offset))//str_vs(tmp(offset+count:)))
    deallocate(tmp)

  end subroutine deleteData


  subroutine replaceData(arg, offset, count, data, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(inout) :: arg
    integer, intent(in) :: offset
    integer, intent(in) :: count
    character(len=*), intent(in) :: data
    
    character, pointer :: tmp(:)

    if (isCharData(arg%nodeType)) then
      call throw_exception(FoX_INVALID_NODE, "replaceData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "replaceData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (offset<0 .or. count<0) then
      call throw_exception(INDEX_SIZE_ERR, "replaceData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not.checkChars(data, arg%ownerDocument%xds%xml_version)) then
      call throw_exception(FoX_INVALID_CHARACTER, "replaceData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    tmp => arg%nodeValue
    if (offset+count <= size(arg%nodeValue)) then
      arg%nodeValue => vs_str_alloc(str_vs(tmp(:offset))//data//str_vs(tmp(offset+count:)))
    else
      arg%nodeValue => vs_str_alloc(str_vs(tmp(:offset))//data)
    endif
    deallocate(tmp)

    ! We have to do these checks *after* appending data in case offending string
    ! spans old & new data
    if (arg%nodeType==COMMENT_NODE .and. index(str_vs(arg%nodeValue),"--")>0) then
      call throw_exception(FoX_INVALID_COMMENT, "replaceData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%nodeType==CDATA_SECTION_NODE .and. index(str_vs(arg%nodeValue), "]]>")>0) then
      call throw_exception(FoX_INVALID_CDATA_SECTION, "replaceData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

  end subroutine replaceData
 


  function getNotationName(arg, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: arg
    character(len=size(arg%notationName)) :: c

    if (arg%nodeType/=ENTITY_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getNotationName", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    c = str_vs(arg%notationName)

  end function getNotationName



  function getTarget(arg, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: arg
    character(len=size(arg%nodeName)) :: c

    if (arg%nodeType/=PROCESSING_INSTRUCTION_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getTarget", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    c = str_vs(arg%nodeName)
  end function getTarget



  pure function isTextNode(nodeType) result(p)
    integer, intent(in) :: nodeType
    logical :: p

    p = (nodeType==TEXT_NODE.or.nodeType==CDATA_SECTION_NODE)
  end function isTextNode

  function splitText(arg, offset, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    integer, intent(in) :: offset

    type(Node), pointer :: np

    character, pointer :: tmp(:)

    if (.not.isTextNode(arg%nodeType)) then
      call throw_exception(FoX_INVALID_NODE, "splitText", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "splitText", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (offset<0 .or. offset>size(arg%nodeValue)) then
      call throw_exception(INDEX_SIZE_ERR, "splitText", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    tmp => arg%nodeValue
    if (arg%nodeType==TEXT_NODE) then
      np => createTextNode(arg%ownerDocument, str_vs(tmp(offset+1:)))
    elseif (arg%nodeType==CDATA_SECTION_NODE) then
      np => createCdataSection(arg%ownerDocument, str_vs(tmp(offset+1:)))
    endif
    arg%nodeValue => vs_str_alloc(str_vs(tmp(:offset)))     
    deallocate(tmp)
    if (associated(arg%parentNode)) then
      if (associated(arg%nextSibling)) then
        np => insertBefore(arg%parentNode, np, arg%nextSibling)
      else
        np => appendChild(arg%parentNode, np)
      endif
    endif

  end function splitText
                                     


  function getData(arg) result(c)
    type(Node), intent(in) :: arg
    character(len=size(arg%nodeValue)) :: c

    if (arg%nodeType==TEXT_NODE .or. &
      arg%nodeType==COMMENT_NODE .or. &
      arg%nodeType==CDATA_SECTION_NODE .or. &
      arg%nodeType==PROCESSING_INSTRUCTION_NODE) then
       c = str_vs(arg%nodeValue)
    else
       c = ""
    endif
  end function getData


  subroutine setData(arg, data)
    type(Node), intent(inout) :: arg
    character(len=*) :: data
    if (arg%nodeType/=TEXT_NODE .and. &
      arg%nodeType/=COMMENT_NODE .and. &
      arg%nodeType/=CDATA_SECTION_NODE .and. &
      arg%nodeType/=PROCESSING_INSTRUCTION_NODE) then
      deallocate(arg%nodeValue)
      arg%nodeValue => vs_str_alloc(data)
    else
      ! or error
      continue
    endif
  end subroutine setData

  
  function getName(arg) result(c)
    type(Node), intent(in) :: arg
    character(size(arg%nodeName)) :: c
    
    if (arg%nodeType/=ATTRIBUTE_NODE .and. &
      arg%nodeType/=DOCUMENT_TYPE_NODE) then
      c = "" ! FIXME error
    endif
    c = str_vs(arg%nodeName)
    
  end function getName


  function getPublicId(arg) result(c)
    type(Node), intent(in) :: arg
    character(len=size(arg%publicId)) :: c

    if (arg%nodeType/=DOCUMENT_TYPE_NODE .and. &
      arg%nodeType/=NOTATION_NODE .and. &
      arg%nodeType/=ENTITY_NODE) then
      ! FIXME error
      continue
    endif
    c = str_vs(arg%publicId)

  end function getPublicId


  function getSystemId(arg) result(c)
    type(Node), intent(in) :: arg
    character(len=size(arg%systemId)) :: c

    if (arg%nodeType/=DOCUMENT_TYPE_NODE .and. &
      arg%nodeType/=NOTATION_NODE .and. &
      arg%nodeType/=ENTITY_NODE) then
      ! FIXME error
      continue
    endif
    c = str_vs(arg%systemId)

  end function getSystemId


end module m_dom_dom
