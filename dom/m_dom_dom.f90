 
 
! ATTENTION
! THIS FILE IS AUTOGENERATED
! DO NOT EDIT DIRECTLY
! EDIT FILES dom/m_dom_***.m4
!
module m_dom_dom


  use m_common_array_str, only: vs_str_alloc
  use m_common_struct, only: xml_doc_state



  use m_common_array_str, only: str_vs, vs_str_alloc
  use m_dom_error, only: DOMException, throw_exception, is_in_error, &
    NO_MODIFICATION_ALLOWED_ERR, NOT_FOUND_ERR, HIERARCHY_REQUEST_ERR, &
    WRONG_DOCUMENT_ERR, dom_error



  use m_common_array_str, only: str_vs
  use m_dom_error, only: INUSE_ATTRIBUTE_ERR



  use m_common_array_str, only: str_vs, vs_str_alloc
  use m_common_charset, only: checkChars, XML1_0

  use m_dom_error, only: DOMException, throw_exception, is_in_error, &
    INVALID_CHARACTER_ERR, NAMESPACE_ERR, FoX_INVALID_PUBLIC_ID, FoX_INVALID_SYSTEM_ID
  use m_common_namecheck, only: checkName, checkPublicId, checkSystemId
  use m_common_string, only: toLower



  use m_common_array_str, only: str_vs, vs_str_alloc
  use m_common_namecheck, only: checkQName, prefixOfQName, localPartOfQName
  use m_dom_error, only : NOT_FOUND_ERR, INVALID_CHARACTER_ERR, FoX_INVALID_NODE, &
    FoX_INVALID_XML_NAME, WRONG_DOCUMENT_ERR, FoX_INVALID_TEXT, & 
    FoX_INVALID_CHARACTER, FoX_INVALID_COMMENT, FoX_INVALID_CDATA_SECTION, &
    FoX_INVALID_PI_DATA, NOT_SUPPORTED_ERR



  use m_common_array_str, only: str_vs



  use m_common_array_str, only: str_vs, vs_str_alloc
  use m_common_namecheck, only: prefixOfQName, localpartOfQName



  use m_common_array_str, only: str_vs, vs_str_alloc



  use m_common_array_str, only: str_vs, vs_str_alloc
  use m_dom_error, only: INDEX_SIZE_ERR



  use m_common_array_str, only: str_vs



  use m_common_array_str, only: str_vs



  use m_common_array_str, only: str_vs, vs_str_alloc



  use m_common_array_str, only: str_vs, vs_str_alloc


  implicit none
  private

  integer, parameter ::     ELEMENT_NODE                   = 1
  integer, parameter ::     ATTRIBUTE_NODE                 = 2
  integer, parameter ::     TEXT_NODE                      = 3
  integer, parameter ::     CDATA_SECTION_NODE             = 4
  integer, parameter ::     ENTITY_REFERENCE_NODE          = 5
  integer, parameter ::     ENTITY_NODE                    = 6
  integer, parameter ::     PROCESSING_INSTRUCTION_NODE    = 7
  integer, parameter ::     COMMENT_NODE                   = 8
  integer, parameter ::     DOCUMENT_NODE                  = 9
  integer, parameter ::     DOCUMENT_TYPE_NODE             = 10
  integer, parameter ::     DOCUMENT_FRAGMENT_NODE         = 11
  integer, parameter ::     NOTATION_NODE                  = 12


  type DOMImplementation
    private
    character, pointer :: id(:)
  end type DOMImplementation

  type ListNode
    private
    type(Node), pointer :: this => null()
  end type ListNode 

  type NodeList
    private
    type(ListNode), pointer :: nodes(:) => null()
    integer :: length = 0
  end type NodeList

  type NamedNodeMap
    private
    logical :: readonly = .false.
    type(Node), pointer :: ownerElement => null()
    type(NodeList) :: list 
  end type NamedNodeMap

  type Node
    private
    logical :: readonly = .false. ! FIXME must check this everywhere
    character, pointer, dimension(:)         :: nodeName => null()
    character, pointer, dimension(:)         :: nodeValue => null()
    integer              :: nc              = 0 
    integer              :: nodeType        = 0
    type(Node), pointer :: parentNode      => null()
    type(Node), pointer :: firstChild      => null()
    type(Node), pointer :: lastChild       => null()
    type(Node), pointer :: previousSibling => null()
    type(Node), pointer :: nextSibling     => null()
    type(Node), pointer :: ownerDocument   => null()
    type(NamedNodeMap) :: attributes
    type(NodeList) :: childNodes
    ! Introduced in DOM Level 2:
    character, pointer, dimension(:) :: namespaceURI => null()
    character, pointer, dimension(:) :: prefix => null()
    character, pointer, dimension(:) :: localName => null()
    type(Node), pointer :: doctype => null()
    type(DOMImplementation), pointer :: implementation => null()
    type(Node), pointer :: documentElement => null()
    logical :: specified
    ! Introduced in DOM Level 2
    type(Node), pointer :: ownerElement => null()
    type(namedNodeMap) :: entities
    type(namedNodeMap) :: notations 
    ! FIXME The two above should be held in xds below
    character, pointer :: publicId(:) => null()
    character, pointer :: systemId(:) => null()
    character, pointer :: internalSubset(:) => null()
    character, pointer :: notationName(:) => null()
    ! Introduced in DOM Level 3
    character, pointer :: inputEncoding(:) => null()
    character, pointer :: xmlEncoding(:) => null()
    ! logical :: xmlStandalone = .false.
    ! character, pointer :: xmlVersion(:) => null() 
    ! The two above are held in xds below
    logical :: strictErrorChecking = .false.
    character, pointer :: documentURI(:) => null()
    ! DOMCONFIGURATION
    type(xml_doc_state), pointer :: xds => null()
    !TYPEINFO schemaTypeInfo
    logical :: isId
  end type Node

  public :: ELEMENT_NODE
  public :: ATTRIBUTE_NODE
  public :: TEXT_NODE
  public :: CDATA_SECTION_NODE
  public :: ENTITY_REFERENCE_NODE
  public :: ENTITY_NODE
  public :: PROCESSING_INSTRUCTION_NODE
  public :: COMMENT_NODE
  public :: DOCUMENT_NODE
  public :: DOCUMENT_TYPE_NODE
  public :: DOCUMENT_FRAGMENT_NODE
  public :: NOTATION_NODE

  public :: DOMImplementation
  public :: Node

  public :: ListNode
  public :: NodeList
  public :: NamedNodeMap

  public :: createNode
  public :: destroyNode
  public :: destroyNodeContents


  
  public :: getNodeName
  public :: getNodevalue	
  public :: setNodeValue
  public :: getNodeType
  public :: getParentNode
  public :: getChildNodes
  public :: getFirstChild
  public :: getLastChild
  public :: getNextSibling
  public :: getPreviousSibling
  public :: getAttributes
  public :: getOwnerDocument
  public :: insertBefore
  public :: replaceChild
  public :: removeChild
  public :: appendChild
  public :: hasChildNodes
  public :: cloneNode  
  public :: normalize
  public :: isSupported
  public :: getNamespaceURI
  public :: getPrefix
  public :: setPrefix
  public :: getLocalName
  public :: hasAttributes
!  public :: isSameNode



  public :: item
  public :: append
  public :: pop_nl
  public :: remove_nl
  public :: destroyNodeList
  
  interface append
    module procedure append_nl
  end interface
  
  interface item
    module procedure item_nl
  end interface


  public :: getNamedItem
  public :: getNamedItem_Value
  public :: getNamedItem_Value_length
  public :: setNamedItem
  public :: removeNamedItem
  public :: item
  public :: getLength
  public :: getNamedItemNS
  public :: getNamedItemNS_Value
  public :: getNamedItemNS_Value_length
  public :: setNamedItemNS
  public :: removeNamedItemNS

  public :: append
  public :: setReadOnly
  public :: destroyNamedNodeMap

  interface append
    module procedure append_nnm
  end interface

  interface item
    module procedure item_nnm
  end interface

  interface getLength
    module procedure getLength_nnm
  end interface



  public :: hasFeature
  public :: createDocument
  public :: createDocumentType

  public :: destroyDocument

  public :: createEmptyDocument
  public :: createEmptyDocumentType



  public :: getDocumentType
  public :: getImplementation
  public :: getDocumentElement
  public :: setDocumentElement
  
  public :: createElement
  public :: createDocumentFragment
  public :: createTextNode
  public :: createComment
  public :: createCdataSection
  public :: createProcessingInstruction
  public :: createAttribute
  public :: createEntityReference
  public :: getElementsByTagName
  public :: importNode
  public :: createElementNS
  public :: createAttributeNS
  public :: getElementsByTagNameNS
  public :: getElementById

  public :: createEntity
  public :: createNotation



  !public :: getName
  public :: getEntities
  public :: getNotations
!  public :: getPublicId
!  public :: getSystemId
  public :: getInternalSubset

!  Not part of documented API:
  public :: setDocumentType


  
  public :: getTagName
  public :: getAttribute
  public :: setAttribute
  public :: removeAttribute
  public :: getAttributeNode
  public :: setAttributeNode
  public :: removeAttributeNode
  ! public :: getElementsByTagName
  public :: getAttributeNS
  public :: setAttributeNS
  public :: removeAttributeNS
  public :: getAttributeNodeNS
  public :: setAttributeNodeNS
  public :: removeAttributeNodeNS
  public :: hasAttribute
  public :: hasAttributeNS


  !public :: getName
  public :: getSpecified
  public :: getValue
  public :: setValue
  public :: getOwnerElement



  public :: getLength
!  public :: getData
!  public :: setData
  public :: substringData
  public :: appendData
  public :: insertData
  public :: deleteData
  public :: replaceData

  interface getLength
    module procedure getLength_characterdata
  end interface


  
  public :: getNotationName



  public :: getTarget

  
  public :: splitText


! Assorted functions with identical signatures despite belonging to different types.

  public :: getData
  public :: setData
  public :: getName
  public :: getPublicId
  public :: getSystemId


contains


  function createNode(doc, nodeType, nodeName, nodeValue, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    integer, intent(in) :: nodeType
    character(len=*), intent(in) :: nodeName
    character(len=*), intent(in) :: nodeValue
    type(Node), pointer :: np

    print*,"createNode", nodeType, nodeName, nodeValue

    if (associated(doc)) then
      if (doc%nodeType/=DOCUMENT_NODE) then
        call throw_exception(FoX_INVALID_NODE, "createNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

      endif
    elseif (nodeType/=DOCUMENT_NODE) then
      print*,"Internal error creating node"
      stop
    endif

    allocate(np)
    np%ownerDocument => doc
    np%nodeType = nodeType
    np%nodeName => vs_str_alloc(nodeName)
    np%nodeValue => vs_str_alloc(nodeValue)

    allocate(np%childNodes%nodes(0))

  end function createNode

  recursive subroutine destroyNode(np)
    type(Node), pointer :: np

    select case(np%nodeType)
    case (ELEMENT_NODE)
      call destroyElement(np)
    case (ATTRIBUTE_NODE)
      call destroyAttribute(np)
    case (ENTITY_REFERENCE_NODE)
      ! In principle a DOM might have children here. We dont.
      call destroyNodeContents(np)
      deallocate(np)
    case (ENTITY_NODE)
      ! ?? FIXME
      call destroyNodeContents(np)
      deallocate(np)
    case (DOCUMENT_NODE)
      ! well, I dont think this should ever be called, but if it is
      ! then go to destroy_document
      !call destroyDocument(np)
    case (DOCUMENT_TYPE_NODE)
      call destroyDocumentType(np)
    case (DOCUMENT_FRAGMENT_NODE)
      !call destroyDocumentFragment
    case default
      call destroyNodeContents(np)
      deallocate(np)
    end select

  end subroutine destroyNode

  subroutine destroyDocumentType(dt)
    type(Node), pointer :: dt

    integer :: i

    if (dt%nodeType/=DOCUMENT_TYPE_NODE) then
       ! FIXME internal error
    endif

    ! Entities need to be destroyed recursively

    do i = 1, dt%notations%list%length
      call destroyNode(dt%notations%list%nodes(i)%this)
    enddo
    if (associated(dt%notations%list%nodes)) deallocate(dt%notations%list%nodes)

    call destroyNodeContents(dt)
    deallocate(dt)

  end subroutine destroyDocumentType

  subroutine destroyElement(element)
    type(Node), pointer :: element

    integer :: i

    if (element%nodeType /= ELEMENT_NODE) then
      ! FIXME internal error
    endif

    do i = 1, element%attributes%list%length
      call destroyNode(element%attributes%list%nodes(i)%this)
    enddo
    !    call destroyNamedNodeMap(element%attributes)
    if (associated(element%attributes%list%nodes)) deallocate(element%attributes%list%nodes)
    call destroyNodeContents(element)
    deallocate(element)

  end subroutine destroyElement

  subroutine destroyAttribute(attr)
    type(Node), pointer :: attr

    type(Node), pointer :: np, np_next

    if (attr%nodeType/=ATTRIBUTE_NODE) then
       ! FIXME internal error
    endif

    np => attr%firstChild
    do while (associated(np))
      np_next => np%nextSibling
      call destroyNode(np)
      np => np_next
    enddo

    call destroyNodeContents(attr)
    deallocate(attr)

  end subroutine destroyAttribute


  subroutine destroyNodeContents(np)
    type(Node), intent(inout) :: np
    
    if (associated(np%nodeName)) deallocate(np%nodeName)
    if (associated(np%nodeValue)) deallocate(np%nodeValue)
    if (associated(np%namespaceURI)) deallocate(np%namespaceURI)
    if (associated(np%prefix)) deallocate(np%prefix)
    if (associated(np%localname)) deallocate(np%localname)
    if (associated(np%publicId)) deallocate(np%publicId)
    if (associated(np%systemId)) deallocate(np%systemId)
    if (associated(np%internalSubset)) deallocate(np%internalSubset)
    if (associated(np%notationName)) deallocate(np%notationName)

    if (associated(np%inputEncoding)) deallocate(np%inputEncoding)
    if (associated(np%xmlEncoding)) deallocate(np%xmlEncoding)
    !if (associated(np%xmlVersion)) deallocate(np%xmlVersion)
    if (associated(np%documentURI)) deallocate(np%documentURI)
  end subroutine destroyNodeContents



  ! Getters and setters

  function getNodeName(arg) result(c)
    type(Node), intent(in) :: arg
    character(len=size(arg%nodeName)) :: c
    
    c = str_vs(arg%nodeName)
  end function getNodeName

  function getNodeValue(arg) result(c)
    type(Node), intent(in) :: arg
    character(len=size(arg%nodeName)) :: c
    
    c = str_vs(arg%nodeName)
  end function getNodeValue
  
  subroutine setNodeValue(arg, nodeValue, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(inout) :: arg
    character(len=*) :: nodeValue

    if (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setNodeValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
      
    !FIXME check what kind of node is it, what is nodeValue allowed to be ...
    ! if it is an attribute node we need to reset TEXT/ENTITYREF children.
    if (arg%nodeType == ATTRIBUTE_NODE) then
      ! destroy children
      ! rebuild new children
    endif
    deallocate(arg%nodeValue)
    arg%nodeValue => vs_str_alloc(nodeValue)
  end subroutine setNodeValue

  function getNodeType(arg) result(n)
    type(Node), intent(in) :: arg
    integer :: n

    n = arg%nodeType
  end function getNodeType

  function getParentNode(arg) result(np)
    type(Node), intent(in) :: arg
    type(Node), pointer :: np

    np => arg%parentNode
  end function getParentNode
  
  function getChildNodes(arg) result(nl)
    type(Node), pointer :: arg
    type(NodeList), pointer :: nl

    nl => arg%childnodes
  end function getChildNodes
  
  function getFirstChild(arg) result(np)
    type(Node), intent(in) :: arg
    type(Node), pointer :: np

    np => arg%firstChild
  end function getFirstChild
  
  function getLastChild(arg) result(np)
    type(Node), intent(in) :: arg
    type(Node), pointer :: np

    np => arg%lastChild
  end function getLastChild

  function getPreviousSibling(arg) result(np)
    type(Node), intent(in) :: arg
    type(Node), pointer :: np

    np => arg%previousSibling
  end function getPreviousSibling
  
  function getNextSibling(arg) result(np)
    type(Node), intent(in) :: arg
    type(Node), pointer :: np

    np => arg%nextSibling
  end function getNextSibling

  function getAttributes(arg) result(nnm)
    type(Node), intent(in) :: arg
    type(NamedNodeMap), pointer :: nnm

! FIXME surely only if this is an element node?

    nnm = arg%attributes
  end function getAttributes

  function getOwnerDocument(arg) result(np)
    type(Node), intent(in) :: arg
    type(Node), pointer :: np

    np => arg%ownerDocument
  end function getOwnerDocument

  function insertBefore(arg, newChild, refChild, ex) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: newChild
    type(Node), pointer :: refChild
    type(Node), pointer :: insertBefore

    type(Node), pointer :: np

    if (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
!   FIXME what about this next?
    if (.not. associated(arg)) call dom_error("insertBefore",0,"Node not allocated")

! FIXME need to special case this for inserting documentElement and documentType on document nodes
    select case(arg%nodeType)
    case (ELEMENT_NODE)
      if (newChild%nodeType/=ELEMENT_NODE &
        .and. newChild%nodeType/=TEXT_NODE &
        .and. newChild%nodeType/=COMMENT_NODE &
        .and. newChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
        .and. newChild%nodeType/=CDATA_SECTION_NODE &
        .and. newChild%nodeType/=ENTITY_REFERENCE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (ATTRIBUTE_NODE)
      if (newChild%nodeType/=TEXT_NODE &
        .and. newChild%nodeType/=ENTITY_REFERENCE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (DOCUMENT_NODE)
      if (newChild%nodeType/=ELEMENT_NODE &
        .and. newChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
        .and. newChild%nodeType/=COMMENT_NODE &
        .and. newChild%nodeType/=DOCUMENT_TYPE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (DOCUMENT_FRAGMENT_NODE)
      if (newChild%nodeType/=ELEMENT_NODE &
        .and. newChild%nodeType/=TEXT_NODE &
        .and. newChild%nodeType/=COMMENT_NODE &
        .and. newChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
        .and. newChild%nodeType/=CDATA_SECTION_NODE &
        .and. newChild%nodeType/=ENTITY_REFERENCE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case default
      call throw_exception(HIERARCHY_REQUEST_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    end select

    if (.not.(associated(arg%ownerDocument, newChild%ownerDocument) &
      .or. associated(arg, newChild%ownerDocument))) then
      call throw_exception(WRONG_DOCUMENT_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    if (.not.associated(refChild)) then
      insertBefore => appendChild(arg, newChild)
      return
    endif
    
    np => arg%firstChild
    do while (associated(np))
      if (associated(np, refChild)) then
        if (associated(np, arg%firstChild)) then
          arg%firstChild => newChild
        else
          np%previousSibling%nextSibling => newChild
        endif
        refChild%previousSibling => newChild
        newChild%nextSibling => refChild
        newChild%parentNode => arg
        insertBefore => newChild
        return
      endif
      np => np%nextSibling
    enddo

    call throw_exception(NOT_FOUND_ERR, "insertBefore", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif


  end function insertBefore
  

  function replaceChild(arg, newChild, oldChild, ex) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: newChild
    type(Node), pointer :: oldChild
    type(Node), pointer :: replaceChild

    type(Node), pointer :: np
    
    if (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not. associated(arg)) call dom_error("replaceChild",0,"Node not allocated")

    select case(arg%nodeType)
    case (ELEMENT_NODE)
      if (newChild%nodeType/=ELEMENT_NODE &
        .and. newChild%nodeType/=TEXT_NODE &
        .and. newChild%nodeType/=COMMENT_NODE &
        .and. newChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
        .and. newChild%nodeType/=CDATA_SECTION_NODE &
        .and. newChild%nodeType/=ENTITY_REFERENCE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (ATTRIBUTE_NODE)
      if (newChild%nodeType/=TEXT_NODE &
        .and. newChild%nodeType/=ENTITY_REFERENCE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (DOCUMENT_NODE)
      if (newChild%nodeType/=ELEMENT_NODE &
        .and. newChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
        .and. newChild%nodeType/=COMMENT_NODE &
        .and. newChild%nodeType/=DOCUMENT_TYPE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (DOCUMENT_FRAGMENT_NODE)
      if (newChild%nodeType/=ELEMENT_NODE &
        .and. newChild%nodeType/=TEXT_NODE &
        .and. newChild%nodeType/=COMMENT_NODE &
        .and. newChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
        .and. newChild%nodeType/=CDATA_SECTION_NODE &
        .and. newChild%nodeType/=ENTITY_REFERENCE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case default
      call throw_exception(HIERARCHY_REQUEST_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    end select

    if (.not.(associated(arg%ownerDocument, newChild%ownerDocument) &
      .or. associated(arg, newChild%ownerDocument))) then
      call throw_exception(WRONG_DOCUMENT_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => arg%firstChild

    do while (associated(np))    
       if (associated(np, oldChild)) then
          if (associated(np, arg%firstChild)) then
             arg%firstChild => newChild
             if (associated(np%nextSibling)) then
                np%nextSibling%previousSibling => newChild
             else
                arg%lastChild => newChild    ! there was just 1 node
             endif
          elseif (associated(np, arg%lastChild)) then
             ! one-node-only case covered above
             arg%lastChild => newChild
             np%previousSibling%nextSibling => newChild
          else
             np%previousSibling%nextSibling => newChild
             np%nextSibling%previousSibling => newChild
          endif
          newChild%parentNode => arg
          newChild%nextSibling => oldChild%nextSibling
          newChild% previousSibling => oldChild%previousSibling
          replaceChild => oldChild
          return
       endif
       np => np%nextSibling
    enddo

    call throw_exception(NOT_FOUND_ERR, "replaceChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif


  end function replaceChild


  function removeChild(arg, oldChild, ex) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: removeChild
    type(Node), pointer :: arg
    type(Node), pointer :: oldChild
    type(Node), pointer :: np
    
    if (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "removeChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not.associated(arg)) call dom_error("removeChild",0,"Node not allocated")
    np => arg%firstChild
    
    do while (associated(np))
      if (associated(np, oldChild)) then
        if (associated(np, arg%firstChild)) then
          arg%firstChild => np%nextSibling
          if (associated(np%nextSibling)) then
            arg%firstChild%previousSibling => null()
          else
            arg%lastChild => null()    ! there was just 1 node
          endif
        else if (associated(np, arg%lastChild)) then
          ! one-node-only case covered above
          arg%lastChild => np%previousSibling
          np%lastChild%nextSibling => null()
        else
          np%previousSibling%nextSibling => np%nextSibling
          np%nextSibling%previousSibling => np%previousSibling
        endif
        arg%nc = arg%nc -1
        np%previousSibling => null()    ! Are these necessary?
        np%nextSibling => null()
        np%parentNode => null()
        removeChild => oldChild
        return
      endif
      np => np%nextSibling
    enddo
    
    call throw_exception(NOT_FOUND_ERR, "removeChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif


  end function removeChild


  function appendChild(arg, newChild, ex) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    type(Node), pointer :: newChild
    type(Node), pointer :: appendChild
    
    if (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (.not. associated(arg))  & 
      call dom_error("appendChild",0,"Node not allocated")
    
    select case(arg%nodeType)
    case (ELEMENT_NODE)
      if (newChild%nodeType/=ELEMENT_NODE &
        .and. newChild%nodeType/=TEXT_NODE &
        .and. newChild%nodeType/=COMMENT_NODE &
        .and. newChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
        .and. newChild%nodeType/=CDATA_SECTION_NODE &
        .and. newChild%nodeType/=ENTITY_REFERENCE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (ATTRIBUTE_NODE)
      if (newChild%nodeType/=TEXT_NODE &
        .and. newChild%nodeType/=ENTITY_REFERENCE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (DOCUMENT_NODE)
      if (newChild%nodeType/=ELEMENT_NODE &
        .and. newChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
        .and. newChild%nodeType/=COMMENT_NODE &
        .and. newChild%nodeType/=DOCUMENT_TYPE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (DOCUMENT_FRAGMENT_NODE)
      if (newChild%nodeType/=ELEMENT_NODE &
        .and. newChild%nodeType/=TEXT_NODE &
        .and. newChild%nodeType/=COMMENT_NODE &
        .and. newChild%nodeType/=PROCESSING_INSTRUCTION_NODE &
        .and. newChild%nodeType/=CDATA_SECTION_NODE &
        .and. newChild%nodeType/=ENTITY_REFERENCE_NODE) &
        call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case default
      call throw_exception(HIERARCHY_REQUEST_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    end select

    if (.not.(associated(arg%ownerDocument, newChild%ownerDocument) &
      .or. associated(arg, newChild%ownerDocument))) then
      call throw_exception(WRONG_DOCUMENT_ERR, "appendChild", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    if (.not.(associated(arg%firstChild))) then
      arg%firstChild => newChild
    else 
      newChild%previousSibling => arg%lastChild
      arg%lastChild%nextSibling => newChild 
    endif
    
    arg%lastChild => newChild
    newChild%parentNode => arg
    arg%nc = arg%nc + 1
    
    appendChild => newChild
    
  end function appendChild


  function hasChildNodes(arg)
    type(Node), pointer :: arg
    logical :: hasChildNodes
    
    if (.not. associated(arg)) call dom_error("hasChildNodes",0,"Node not allocated")
    hasChildNodes = associated(arg%firstChild)
    
  end function hasChildNodes

  function cloneNode(arg, deep, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
    logical :: deep
    type(Node), pointer :: np

    type(Node), pointer :: np_a1, np_a2, this, that, new, ERchild
    type(NamedNodeMap), pointer :: nnm

    logical :: noChild, readonly
    integer :: i

    noChild = .false.
    readonly = .false.
    
    ERchild => null()
    this => arg
    do
      if (noChild) then
        if (associated(this, arg)) exit
        if (associated(this, ERchild)) then
          ! Weve got back up to the top of the topmost ER.
          readonly = .false.
          ERchild => null()
        endif
        if (associated(this%nextSibling)) then
          this => this%nextSibling
          noChild = .false.
        else
          this => this%parentNode
          that => that%parentNode
          cycle
        endif
      endif
      select case(this%nodeType)
        case (ELEMENT_NODE)
          new => createElementNS(this%ownerDocument, &
            str_vs(this%namespaceURI), str_vs(this%localName))
          ! loop over attributes cloning them
          nnm => getAttributes(this)
          do i = 1, getLength(nnm)
            np_a1 => item(nnm, i)
            np_a2 => createAttributeNS(this%ownerDocument, &
              str_vs(np_a1%namespaceURI), str_vs(np_a1%localName))
            call setValue(new, getValue(np_a1))
            np_a2%specified = np_a1%specified
            np_a2 => setAttributeNodeNS(np, np_a2)
          end do
        case (ATTRIBUTE_NODE)
          new => createAttributeNS(this%ownerDocument, &
            str_vs(this%namespaceURI), str_vs(this%localName))
          call setValue(new, getValue(np_a2))
          new%specified = .true.
        case (TEXT_NODE)
          new => createTextNode(this%ownerDocument, str_vs(this%nodeValue))
        case (CDATA_SECTION_NODE)
          new => createCdataSection(this%ownerDocument, str_vs(this%nodeValue))
        case (ENTITY_REFERENCE_NODE)
          new => createEntityReference(this%ownerDocument, str_vs(this%nodeName))
          ERChild => this
        case (ENTITY_NODE)
          new => null()
        case (PROCESSING_INSTRUCTION_NODE)
          new => createProcessingInstruction(this%ownerDocument, &
            str_vs(this%nodeName), str_vs(this%nodeValue))
        case (COMMENT_NODE)
          new => createComment(this%ownerDocument, str_vs(this%nodeValue))
        case (DOCUMENT_NODE)
          new => null()
        case (DOCUMENT_FRAGMENT_NODE)
          new => createDocumentFragment(this%ownerDocument)
        case (NOTATION_NODE)
          new => null()
        end select
        ! Sort out readonly-ness
        if (readonly) then
          that%readonly = .true. ! We are under a readonly tree
        elseif (associated(ERChild)) then
          readonly = .true. ! This is not readonly, but all nodes below will be
        endif
        ! Append the new node to the tree
        if (associated(this, arg)) then
          that => new ! This is the first we have created, head of the tree
          if (.not.deep) exit ! We only wanted one node anyway
        else
          new => appendChild(that, new)
        endif
        ! Do we continue descending?
        if (associated(this%firstChild)) then
          if (.not.associated(this, arg)) &
            that => that%lastChild
          this => this%firstChild
        else
          noChild = .true.
        endif
      enddo

      np => that

  end function cloneNode

  
  function hasAttributes(arg)
    type(Node), pointer :: arg
    logical :: hasAttributes
    
    if (.not.associated(arg)) call dom_error("hasAttributes",0,"Node not allocated")
    hasAttributes = (arg%nodeType /= ELEMENT_NODE) &
      .and. (arg%attributes%list%length > 0)
    
  end function hasAttributes
  
  recursive subroutine normalize(arg, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: arg
  ! NB only ever one level of recursion, for text children of the attributes of an element

    type(Node), pointer :: this, tempNode
    type(NamedNodeMap), pointer :: nnm
    integer :: i
    logical :: noChild
    character, pointer :: temp(:)
    
    ! This ignores readonly status according to the DOM standard.

    noChild = .false.
    do
      if (noChild) then
        if (associated(this, arg)) exit
        if (associated(this%nextSibling)) then
          this => this%nextSibling
          noChild = .false.
        else
          this => this%parentNode
          cycle
        endif
      endif
      if (associated(tempNode)) then
        tempNode => removeChild(tempNode%parentNode, tempNode)
        tempNode => null()
      endif
      if (this%nodeType==ELEMENT_NODE.and.hasAttributes(this)) then
        ! Loop over attributes combining them ...
        nnm => getAttributes(this)
        do i = 1, getLength(nnm)
          tempNode => item(nnm, i)
          call normalize(tempNode)
        enddo
        tempNode => null()
      elseif (this%nodeType==TEXT_NODE.and.associated(this%nextSibling)) then
        ! Keep going until all adjacent TEXT_NODEs are consumed.
        do while (this%nextSibling%nodeType==TEXT_NODE) 
          temp => this%nodeValue
          this%nodeValue => vs_str_alloc(str_vs(temp)//getData(this%nextSibling))
	  deallocate(temp)
          tempNode => removeChild(this%parentNode, this%nextSibling)
        enddo
        tempNode => null()
        if (size(this%nodeValue)==0) &
          tempNode => this
      endif
      if (associated(this%firstChild)) then
        this => this%firstChild
      else
        noChild = .true.
      endif
    enddo
 
    tempNode => removeChild(tempNode%parentNode, tempNode)

  end subroutine normalize

  function isSupported(arg, feature, version) result(p)
    type(Node), intent(in) :: arg
    character(len=*), intent(in) :: feature
    character(len=*), intent(in) :: version
    logical :: p

    p = hasFeature(feature, version)
  end function isSupported

  ! FIXME should the below instead just decompose the QName on access?
  function getNamespaceURI(arg) result(c)
    type(Node), intent(in) :: arg
    character(len=size(arg%namespaceURI)) :: c

    c = str_vs(arg%namespaceURI)
  end function getNamespaceURI

  function getPrefix(arg) result(c)
    type(Node), intent(in) :: arg
    character(len=size(arg%prefix)) :: c

    c = str_vs(arg%prefix)
  end function getPrefix
  
  subroutine setPrefix(arg, prefix)
    type(Node), intent(inout) :: arg
    character(len=*) :: prefix

    deallocate(arg%prefix)
    arg%prefix => vs_str_alloc(prefix)

    print*, "why are you doing this?"
    ! FIXME we should implement this but raise a FoX-specific exception if used
    stop
    ! FIXME exceptions
  end subroutine setPrefix

  function getLocalName(arg) result(c)
    type(Node), intent(in) :: arg
    character(len=size(arg%localName)) :: c

    c = str_vs(arg%localName)
  end function getLocalName

  function isSameNode(node1, node2)    ! DOM 3.0
    type(Node), pointer :: node1
    type(Node), pointer :: node2
    logical :: isSameNode

    isSameNode = associated(node1, node2)

  end function isSameNode



  function item_nl(list, index) result(np)
    type(NodeList), intent(in) :: list
    integer, intent(in) :: index
    type(Node), pointer :: np

!    if (index > list%length) &
!      FIXME raise an error

    np => list%nodes(index)%this

  end function item_nl

  subroutine append_nl(list, arg)
    type(NodeList), intent(inout) :: list
    type(Node), pointer :: arg

    type(ListNode), pointer :: temp_nl(:)
    integer :: i

    if (.not.associated(list%nodes)) then
      allocate(list%nodes(1))
      list%nodes(1)%this => arg
      list%length = 1
    else
      temp_nl => list%nodes
      allocate(list%nodes(size(temp_nl)+1))
      do i = 1, size(temp_nl)
        list%nodes(i)%this => temp_nl(i)%this
      enddo
      deallocate(temp_nl)
      list%nodes(size(list%nodes))%this => arg
      list%length = size(list%nodes)
    endif
    
  end subroutine append_nl

  function pop_nl(list) result(np)
    type(NodeList), intent(inout) :: list
    type(Node), pointer :: np

    type(ListNode), pointer :: temp_nl(:)
    integer :: i

    if (list%length==0) then
      ! FIXME internal error
      continue
    endif

    np => list%nodes(size(list%nodes))%this

    if (list%length==1) then
      deallocate(list%nodes)
      list%length = 0
    else
      temp_nl => list%nodes
      allocate(list%nodes(size(temp_nl)-1))
      do i = 1, size(temp_nl)-1
        list%nodes(i)%this => temp_nl(i)%this
      enddo
      deallocate(temp_nl)
      list%length = size(list%nodes)
    endif
    
  end function pop_nl


  function remove_nl(nl, index) result(np)
    type(NodeList), intent(inout) :: nl
    integer, intent(in) :: index
    type(Node), pointer :: np

    integer :: i

    np => nl%nodes(index)%this

    do i = index + 1, nl%length
      nl%nodes(i-1)%this => nl%nodes(i)%this
    enddo

  end function remove_nl


  subroutine destroyNodeList(nl)
    type(NodeList), intent(inout) :: nl
    
    if (nl%length>0) deallocate(nl%nodes)
    nl%length = 0
  end subroutine destroyNodeList



  function getNamedItem(map, name) result(np)
    type(NamedNodeMap), intent(in) :: map
    character(len=*), intent(in) :: name
    type(Node), pointer :: np

    integer :: i

    do i = 1, map%list%length
      if (str_vs(map%list%nodes(i)%this%nodeName)==name) then
        np => map%list%nodes(i)%this
        return
      endif
    enddo
    
    np => null()

  end function getNamedItem


  pure function getNamedItem_Value_length(map, name) result(n)
    type(NamedNodeMap), intent(in) :: map
    character(len=*), intent(in) :: name
    integer :: n

    integer :: i

    do i = 1, map%list%length
      if (str_vs(map%list%nodes(i)%this%nodeName)==name) then
        n = size(map%list%nodes(i)%this%nodeValue)
        exit
      endif
    enddo
    n = 0

  end function getNamedItem_Value_length


  pure function getNamedItem_Value(map, name) result(c)
    type(NamedNodeMap), intent(in) :: map
    character(len=*), intent(in) :: name
    character(len=getNamedItem_Value_length(map, name)) :: c

    integer :: i

    do i = 1, map%list%length
      if (str_vs(map%list%nodes(i)%this%nodeName)==name) then
        c = str_vs(map%list%nodes(i)%this%nodeValue)
        return
      endif
    enddo
    c = ""

  end function getNamedItem_Value


  function setNamedItem(map, arg, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(NamedNodeMap), intent(inout) :: map
    type(Node), pointer :: arg
    type(Node), pointer :: np

    integer :: i

    if (map%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setNamedItem", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.associated(map%ownerElement%ownerDocument, arg%ownerDocument)) then
      call throw_exception(WRONG_DOCUMENT_ERR, "setNamedItem", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (associated(arg%ownerElement)) then
      call throw_exception(INUSE_ATTRIBUTE_ERR, "setNamedItem", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif
    
    endif

    do i = 1, map%list%length
      if (str_vs(map%list%nodes(i)%this%nodeName)==str_vs(arg%nodeName)) then
        np => map%list%nodes(i)%this
        map%list%nodes(i)%this => arg
        return
      endif
    enddo
    !   If not found, insert it at the end of the linked list
    np => null()
    call append(map, arg)

  end function setNamedItem


  function removeNamedItem(map, name, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(NamedNodeMap), intent(inout) :: map
    character(len=*), intent(in) :: name
    type(Node), pointer :: np

    integer :: i

    if (map%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "removeNamedItem", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    do i = 1, map%list%length
      if (str_vs(map%list%nodes(i)%this%nodeName)==name) then
        np => remove_nl(map%list, i)
        return
      endif
    enddo

    call throw_exception(NOT_FOUND_ERR, "removeNamedItem", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif


  end function removeNamedItem


  function item_nnm(map, index) result(np)
    type(NamedNodeMap), intent(in) :: map
    integer, intent(in) :: index
    type(Node), pointer :: np
    
    integer :: n

    if (index<0 .or. index>map%list%length-1) then
      np => null()
    else
      np => map%list%nodes(index)%this
    endif

   end function item_nnm

  function getLength_nnm(map) result(n)
    type(namedNodeMap), intent(in) :: map
    integer :: n

    n = map%list%length
    
  end function getLength_nnm


  function getNamedItemNS(map, namespaceURI, localName) result(np)
    type(NamedNodeMap), intent(in) :: map
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    type(Node), pointer :: np

    integer :: i

    do i = 1, map%list%length
      if (str_vs(map%list%nodes(i)%this%namespaceURI)==namespaceURI &
        .and. str_vs(map%list%nodes(i)%this%localName)==localName) then
        np => map%list%nodes(i)%this
        return
      endif
    enddo
    
    np => null()

  end function getNamedItemNS


  pure function getNamedItemNS_Value_length(map, namespaceURI, localName) result(n)
    type(NamedNodeMap), intent(in) :: map
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    integer :: n

    integer :: i

    do i = 1, map%list%length
      if (str_vs(map%list%nodes(i)%this%namespaceURI)==namespaceURI &
        .and. str_vs(map%list%nodes(i)%this%localName)==localName) then
        n = size(map%list%nodes(i)%this%nodeValue)
        exit
      endif
    enddo
    n = 0

  end function getNamedItemNS_Value_length


  pure function getNamedItemNS_Value(map, namespaceURI, localName) result(c)
    type(NamedNodeMap), intent(in) :: map
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    character(len=getNamedItemNS_Value_length(map, namespaceURI, localName)) :: c

    integer :: i

    do i = 1, map%list%length
      if (str_vs(map%list%nodes(i)%this%namespaceURI)==namespaceURI &
        .and. str_vs(map%list%nodes(i)%this%localName)==localName) then
        c = str_vs(map%list%nodes(i)%this%nodeValue)
        return
      endif
    enddo
    !FIXME error here

  end function getNamedItemNS_Value


  function setNamedItemNS(map, arg, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(NamedNodeMap), intent(inout) :: map
    type(Node), pointer :: arg
    type(Node), pointer :: np

    integer :: i

    if (map%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setNamedItemNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.associated(map%ownerElement%ownerDocument, arg%ownerDocument)) then
      call throw_exception(WRONG_DOCUMENT_ERR, "setNamedItemNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (associated(arg%ownerElement)) then
      call throw_exception(INUSE_ATTRIBUTE_ERR, "setNamedItemNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif
    
    endif

    do i = 1, map%list%length
      if (str_vs(map%list%nodes(i)%this%namespaceURI)==str_vs(arg%namespaceURI) &
        .and. str_vs(map%list%nodes(i)%this%localName)==str_vs(arg%localName)) then
        np => map%list%nodes(i)%this
        map%list%nodes(i)%this => arg
        return
      endif
    enddo
    !   If not found, insert it at the end of the linked list
    np => null()
    call append(map, arg)

  end function setNamedItemNS


  function removeNamedItemNS(map, namespaceURI, localName, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(NamedNodeMap), intent(inout) :: map
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    type(Node), pointer :: np

    integer :: i

    if (map%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "removeNamedItemNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    do i = 1, map%list%length
      if (str_vs(map%list%nodes(i)%this%namespaceURI)==namespaceURI &
        .and. str_vs(map%list%nodes(i)%this%localName)==localName) then
        np => remove_nl(map%list, i)
        return
      endif
    enddo

    call throw_exception(NOT_FOUND_ERR, "removeNamedItemNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif


  end function removeNamedItemNS


  subroutine append_nnm(map, arg)
    type(namedNodeMap), intent(inout) :: map
    type(node), pointer :: arg

    call append(map%list, arg)

  end subroutine append_nnm


  subroutine setReadOnly(map, r)
    type(namedNodeMap), intent(inout) :: map
    logical, intent(in) :: r

    map%readonly = r
  end subroutine setReadOnly

  subroutine destroyNamedNodeMap(map)
    type(namedNodeMap), intent(inout) :: map

    call destroyNodeList(map%list)
  end subroutine destroyNamedNodeMap



  function hasFeature(feature, version) result(p)
    character(len=*), intent(in) :: feature
    character(len=*), intent(in), optional :: version
    logical :: p

    if (present(version)) then
      if (version/="1.0".and.version/="2.0") then
        p = .false.
        return
      endif
    endif
    p = (toLower(feature)=="core".or.toLower(feature)=="xml")
  end function hasFeature


  function createDocumentType(qualifiedName, publicId, systemId, ex)result(dt) 
    type(DOMException), intent(inout), optional :: ex
    character(len=*), intent(in) :: qualifiedName
    character(len=*), intent(in) :: publicId
    character(len=*), intent(in) :: systemId
    type(Node), pointer :: dt

    allocate(dt%xds)

    if (.not.checkChars(qualifiedName, XML1_0)) then
      call throw_exception(INVALID_CHARACTER_ERR, "createDocumentType", ex)
if (present(ex)) then
  if (is_in_error(ex)) then

if (associated(dt%xds)) deallocate(dt%xds)
     return
  endif
endif

    endif

    if (.not.checkName(qualifiedName, dt%xds)) then
      call throw_exception(NAMESPACE_ERR, "createDocumentType", ex)
if (present(ex)) then
  if (is_in_error(ex)) then

if (associated(dt%xds)) deallocate(dt%xds)
     return
  endif
endif

    ! FIXME check that prefix etc is declared
    elseif (.not.checkPublicId(publicId)) then
      call throw_exception(FoX_INVALID_PUBLIC_ID, "createDocumentType", ex)
if (present(ex)) then
  if (is_in_error(ex)) then

if (associated(dt%xds)) deallocate(dt%xds)
     return
  endif
endif

    elseif (.not.checkSystemId(systemId)) then
      call throw_exception(FoX_INVALID_SYSTEM_ID, "createDocumentType", ex)
if (present(ex)) then
  if (is_in_error(ex)) then

if (associated(dt%xds)) deallocate(dt%xds)
     return
  endif
endif

    endif

    dt => createNode(null(), DOCUMENT_TYPE_NODE, qualifiedName, "")
    dt%readonly = .true.
    dt%publicId = vs_str_alloc(publicId)
    dt%systemId = vs_str_alloc(systemId)
    allocate(dt%internalSubset(0)) !FIXME
    dt%ownerDocument => null()
    ! FIXME fill in the rest of the fields ...

  end function createDocumentType


  function createEmptyDocumentType(doc) result(dt)
    type(Node), pointer :: doc
    type(Node), pointer :: dt

    dt => createNode(doc, DOCUMENT_TYPE_NODE, "", "")
    dt%readonly = .true.
    !dt%entities
    !dt%notations
    allocate(dt%publicId(0))
    allocate(dt%systemId(0))
    allocate(dt%internalSubset(0)) !FIXME

    allocate(dt%xds)
  end function createEmptyDocumentType


  function createDocument(namespaceURI, qualifiedName, docType) result(doc)
    character(len=*), intent(in), optional :: namespaceURI
    character(len=*), intent(in), optional :: qualifiedName
    type(Node), pointer, optional :: docType
    type(Node), pointer :: doc, dt

     !FIXMEFIXMEFIXME optional arguments and errors

    doc => createNode(null(), DOCUMENT_NODE, "#document", "")

    if (present(docType)) then
      docType%ownerDocument => doc
      doc%doctype => appendChild(doc, doc%docType)
    endif
    if (.not.associated(doc%docType)) then
      dt => createDocumentType(qualifiedName, "", "")
      dt%ownerDocument => doc
      doc%docType => appendChild(doc, dt)
    endif

    doc%docType%ownerElement => doc
!    doc%implementation => FoX_DOM
    doc%documentElement => appendChild(doc, createElementNS(doc, namespaceURI, qualifiedName))

    doc%xds => doc%docType%xds

  end function createDocument


  function createEmptyDocument() result(doc)
    type(Node), pointer :: doc
    
    print*,"creating empty document"
    doc => createNode(null(), DOCUMENT_NODE, "#document", "")
    doc%ownerDocument => null()
    print*,"created"

    ! FIXME do something with namespaceURI etc 
    doc%doctype => appendChild(doc, createEmptyDocumentType(doc))
    doc%docType%ownerElement => doc
!    doc%implementation => FoX_DOM
    doc%documentElement => null()
    doc%xds => doc%docType%xds

  end function createEmptyDocument


  subroutine destroyDocument(doc)
    type(Node), pointer :: doc
    
    type(NodeList) :: np_stack
    type(Node), pointer :: np, np_next
    logical :: ascending

    if (doc%nodeType/=DOCUMENT_NODE) then
      ! FIXME throw an error
      continue
    endif

    np => doc%firstChild
    ! if not associated internal error
    ! FIXME DONT NEED STACK
    call append(np_stack, np)
    ascending = .false.
    do
      print*, "iterating ...", associated(np), ascending, np_stack%length
      if (ascending) then
        np => pop_nl(np_stack)
        if (np_stack%length==0) then
          exit
        else
          ascending = .false.
        endif
      else if (associated(np%firstChild)) then
        call append(np_stack, np)
        np => np%firstChild
        cycle
      endif
      np_next => np%nextSibling
      call destroyNode(np)
      if (associated(np_next)) then
        np => np_next
        cycle
      else
        ascending = .true.
      endif
    enddo
    call destroyNodeList(np_stack)

    print*, "destroying a node:", doc%nodeType, doc%nodeName
    call destroyNodeContents(doc)
    deallocate(doc)

  end subroutine destroyDocument



  ! Getters and setters:

  function getDocumentType(doc, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: doc
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getDocumentType", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    np => doc%docType

  end function getDocumentType

  function getImplementation(doc, ex)result(imp) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: doc
    type(DOMImplementation), pointer :: imp

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getImplementation", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    imp => doc%implementation
    
  end function getImplementation

  function getDocumentElement(doc, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: doc
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getDocumentElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    np => doc%documentElement

  end function getDocumentElement

  subroutine setDocumentElement(doc, np, ex)
    type(DOMException), intent(inout), optional :: ex
  ! Only for use by FoX, not exported through FoX_DOM interface
    type(Node), pointer :: doc
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setDocumentElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (np%nodeType/=ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setDocumentElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.associated(np%ownerDocument, doc)) then
      call throw_exception(WRONG_DOCUMENT_ERR, "setDocumentElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    doc%documentElement => np

  end subroutine setDocumentElement

  ! Methods

  function createElement(doc, tagName, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: tagName
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    else if (.not.checkChars(tagName, doc%docType%xds%xml_version)) then
      call throw_exception(INVALID_CHARACTER_ERR, "createElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif  
    if (.not.checkName(tagName, doc%docType%xds)) then
      call throw_exception(FoX_INVALID_XML_NAME, "createElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    np => createElementNS(doc, "", tagName)
  
  end function createElement
    
  function createDocumentFragment(doc, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createDocumentFragment", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
    
    np => createNode(doc, DOCUMENT_FRAGMENT_NODE, "", "")
    
  end function createDocumentFragment

  function createTextNode(doc, data, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: data
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createTextNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(data, doc%xds%xml_version)) then
      call throw_exception(FoX_INVALID_CHARACTER, "createTextNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (scan(data,"&<")>0) then   
      call throw_exception(FoX_INVALID_TEXT, "createTextNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => createNode(doc, TEXT_NODE, "#text", data)
   
  end function createTextNode

  function createComment(doc, data, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: data
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createComment", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(data, doc%xds%xml_version)) then
      call throw_exception(FoX_INVALID_CHARACTER, "createComment", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (-1>0) then   
      call throw_exception(FoX_INVALID_COMMENT, "createComment", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
  
    np => createNode(doc, COMMENT_NODE, "#comment", data)

  end function createComment

  function createCdataSection(doc, data, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: data
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createCdataSection", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(data, doc%xds%xml_version)) then
      call throw_exception(FoX_INVALID_CHARACTER, "createCdataSection", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (-1>0) then   
      call throw_exception(FoX_INVALID_CDATA_SECTION, "createCdataSection", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
  
    np => createNode(doc, CDATA_SECTION_NODE, "#text", data)
  
  end function createCdataSection

  function createProcessingInstruction(doc, target, data, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: target
    character(len=*), intent(in) :: data
    type(Node), pointer :: np


    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createProcessingInstruction", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(target, doc%xds%xml_version)) then
      call throw_exception(INVALID_CHARACTER_ERR, "createProcessingInstruction", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(data, doc%xds%xml_version)) then
      call throw_exception(FoX_INVALID_CHARACTER, "createProcessingInstruction", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkName(data, doc%xds)) then
      call throw_exception(FoX_INVALID_XML_NAME, "createProcessingInstruction", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (-1>0) then   
      call throw_exception(FoX_INVALID_PI_DATA, "createProcessingInstruction", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => createNode(doc, PROCESSING_INSTRUCTION_NODE, target, data)

  end function createProcessingInstruction

  function createAttribute(doc, name, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: name
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(name, doc%xds%xml_version)) then
      call throw_exception(INVALID_CHARACTER_ERR, "createAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkName(name, doc%xds)) then
      call throw_exception(FoX_INVALID_XML_NAME, "createAttribute", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
  
    np => createAttributeNS(doc, name, "")
  
  end function createAttribute

  function createEntityReference(doc, name, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: name
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createEntityReference", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(name, doc%xds%xml_version)) then
      call throw_exception(INVALID_CHARACTER_ERR, "createEntityReference", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkName(name, doc%xds)) then
      call throw_exception(FoX_INVALID_XML_NAME, "createEntityReference", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    ! FIXME check existence of entities + namespace handling,
    ! see spec

    np => createNode(doc, ENTITY_REFERENCE_NODE, name, "")

  end function createEntityReference

  function getElementsByTagName(doc, tagName, ex)result(list) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: tagName
    type(NodeList) :: list

    type(Node), pointer :: np
    logical :: noChild, allElements

    if (doc%nodeType/=DOCUMENT_NODE.and.doc%nodeType/=ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getElementsByTagName", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (tagName=="*") &
      allElements = .true.

    if (doc%nodeType==DOCUMENT_NODE) then
      np => doc%documentElement
    else
      np => doc
    endif

    if (.not.associated(np)) then
      ! FIXME internal error
      continue
    endif

    noChild = .false.
    do
      if (noChild) then
        if (associated(np, doc).or.associated(np, doc%documentElement)) then
          exit
        else
          np => np%parentNode
          noChild=  .false.
        endif
      endif
      if ((np%nodeType==ELEMENT_NODE) .and. &
        (allElements .or. str_vs(np%nodeName)==tagName)) then
        call append(list, np)
      endif
      if (associated(np%firstChild)) then
        np => np%firstChild
      elseif (associated(np%nextSibling)) then
        np => np%nextSibling
      else
        noChild = .true.
      endif
    enddo

  end function getElementsByTagName

  function importNode(doc , arg, deep , ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    type(Node), pointer :: arg
    logical, intent(in) :: deep
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "importNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    select case(arg%nodeType)
    case (ATTRIBUTE_NODE)
      np => cloneNode(arg, deep, ex)
      np%ownerElement => null()
      np%specified = .true.
    case (DOCUMENT_NODE)
      call throw_exception(NOT_SUPPORTED_ERR, "importNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (DOCUMENT_TYPE_NODE)
      call throw_exception(NOT_SUPPORTED_ERR, "importNode", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    case (ELEMENT_NODE)
      np => cloneNode(arg, deep, ex)
! FIXME strip out unspecified attributes unless they are also default in this doc ...
    case (ENTITY_REFERENCE_NODE)
      np => cloneNode(arg, .false., ex)
! FIXME if entity is defined in this doc then add appropriate children
    case default
      np => cloneNode(arg, deep, ex)
    end select

    np%ownerDocument => doc
    np%parentNode => null()

  end function importNode

  function createElementNS(doc, namespaceURI, qualifiedName, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: namespaceURI, qualifiedName
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createElementNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(qualifiedName, doc%xds%xml_version)) then
      call throw_exception(INVALID_CHARACTER_ERR, "createElementNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkQName(qualifiedName, doc%xds)) then
      call throw_exception(NAMESPACE_ERR, "createElementNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (prefixOfQName(qualifiedName)/="" &
     .and. namespaceURI=="") then
      call throw_exception(NAMESPACE_ERR, "createElementNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (prefixOfQName(qualifiedName)=="xml" .and. &
      namespaceURI/="http://www.w3.org/XML/1998/namespace") then
      call throw_exception(NAMESPACE_ERR, "createElementNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    ! FIXME is this all possible errors?
      ! what if prefix = "xmlns"? or other "xml"
    endif

    ! FIXME create a namespace node for XPath?

    np => createNode(doc, ELEMENT_NODE, qualifiedName, "")
    np%namespaceURI => vs_str_alloc(namespaceURI)
    np%prefix => vs_str_alloc(prefixOfQName(qualifiedname))
    np%localName => vs_str_alloc(localpartOfQName(qualifiedname))

  end function createElementNS
  
  function createAttributeNS(doc, namespaceURI, qualifiedname, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: namespaceURI, qualifiedName
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "createAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(qualifiedName, doc%xds%xml_version)) then
      call throw_exception(INVALID_CHARACTER_ERR, "createAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkQName(qualifiedName, doc%xds)) then
      call throw_exception(NAMESPACE_ERR, "createAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (prefixOfQName(qualifiedName)/="" &
     .and. namespaceURI=="") then
      call throw_exception(NAMESPACE_ERR, "createAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (prefixOfQName(qualifiedName)=="xml" .and. &
      namespaceURI/="http://www.w3.org/XML/1998/namespace") then
      call throw_exception(NAMESPACE_ERR, "createAttributeNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    ! FIXME is this all possible errors?
      ! what if prefix = "xmlns"? or other "xml"
    endif
  
    np => createNode(doc, ATTRIBUTE_NODE, qualifiedName, "")
    np%namespaceURI => vs_str_alloc(namespaceURI)
    np%localname => vs_str_alloc(localPartofQName(qualifiedname))
    np%prefix => vs_str_alloc(PrefixofQName(qualifiedname))
    
  end function createAttributeNS

  function getElementsByTagNameNS(doc, namespaceURI, localName, ex)result(list) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: namespaceURI, localName
    type(NodeList) :: list

    type(Node), pointer :: np
    logical :: noChild, allLocalNames, allNameSpaces

    if (doc%nodeType/=DOCUMENT_NODE.and.doc%nodeType/=ELEMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getElementsByTagNameNS", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (namespaceURI=="*") &
      allNameSpaces = .true.
    if (localName=="*") &
      allLocalNames = .true.

    if (doc%nodeType==DOCUMENT_NODE) then
      np => doc%documentElement
    else
      np => doc
    endif

    if (.not.associated(np)) then
      ! FIXME internal error
      continue
    endif

    noChild = .false.
    do
      if (noChild) then
        if (associated(np, doc).or.associated(np, doc%documentElement)) then
          exit
        else
          np => np%parentNode
          noChild=  .false.
        endif
      endif
      if ((np%nodeType==ELEMENT_NODE) &
        .and. (allNameSpaces .or. str_vs(np%namespaceURI)==namespaceURI) &
        .and. (allLocalNames .or. str_vs(np%localName)==localName)) then
        call append(list, np)
      endif
      if (associated(np%firstChild)) then
        np => np%firstChild
      elseif (associated(np%nextSibling)) then
        np => np%nextSibling
      else
        noChild = .true.
      endif
    enddo

  end function getElementsByTagNameNS


  function getElementById(doc, elementId, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), pointer :: doc
    character(len=*), intent(in) :: elementId
    type(Node), pointer :: np

    type(Node), pointer :: attr
    type(NamedNodeMap), pointer :: nnm
    integer :: i
    logical :: noChild

    if (doc%nodeType/=DOCUMENT_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getElementById", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => doc%documentELement

    noChild = .false.
    do
      if (noChild) then
        if (associated(np, doc).or.associated(np, doc%documentElement)) then
          exit
        else
          np => np%parentNode
          noChild=  .false.
        endif
      endif
      if (np%nodeType==ELEMENT_NODE) then
        nnm => np%attributes
        do i = 1, getLength(nnm)
          attr => item(nnm, i)
          if (attr%isId.and.getValue(attr)==elementId) &
            return
        enddo
      endif
      if (associated(np%firstChild)) then
        np => np%firstChild
      elseif (associated(np%nextSibling)) then
        np => np%nextSibling
      else
        noChild = .true.
      endif
    enddo

    np => null()

  end function getElementById

  ! Internal function, not part of API

  function createEntity(doc, name, publicId, systemId, notationName) result(np)
    type(Node), pointer :: doc
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: publicId
    character(len=*), intent(in) :: systemId
    character(len=*), intent(in) :: notationName
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      print*,"internal error in createEntity"
      stop
    endif

    np => createNode(doc, ENTITY_NODE, name, "")
    np%publicId => vs_str_alloc(publicId)
    np%systemId => vs_str_alloc(systemId)
    np%notationName => vs_str_alloc(notationName)

  end function createEntity

  function createNotation(doc, name, publicId, systemId) result(np)
    type(Node), pointer :: doc
    character(len=*), intent(in) :: name
    character(len=*), intent(in), optional :: publicId
    character(len=*), intent(in), optional :: systemId
    type(Node), pointer :: np

    if (doc%nodeType/=DOCUMENT_NODE) then
      print*,"internal error in createEntity"
      stop
    endif

    np => createNode(doc, NOTATION_NODE, name, "")
    if (present(publicId)) np%publicId => vs_str_alloc(publicId)
    if (present(systemId)) np%systemId => vs_str_alloc(systemId)
    
  end function createNotation



!  function getName(docType) result(c) See m_dom_common

  function getEntities(docType) result(nnp)
    type(Node), pointer :: docType
    type(NamedNodeMap), pointer :: nnp

    if (docType%nodeType/=DOCUMENT_TYPE_NODE) then
      ! FIXME error
      continue
    endif

    nnp => docType%entities
  end function getEntities

  function getNotations(docType) result(nnp)
    type(Node), pointer :: docType
    type(NamedNodeMap), pointer :: nnp

    if (docType%nodeType/=DOCUMENT_TYPE_NODE) then
      ! FIXME error
      continue
    endif

    nnp => docType%notations
  end function getNotations


!  function getPublicId(docType) result(c) See m_dom_common


!  function getSystemId(docType) result(c) See m_dom_common


  function getInternalSubset(docType) result(c)
    type(Node), intent(in) :: docType
    character(len=size(docType%internalSubset)) :: c

    if (docType%nodeType/=DOCUMENT_TYPE_NODE) then
      ! FIXME error
      continue
    endif

    c = str_vs(docType%internalSubset)
  end function getInternalSubset


  subroutine setDocumentType(docType, name, publicId, systemId)
    type(Node), intent(inout) :: docType
    character(len=*), intent(in) :: name
    character(len=*), intent(in), optional :: publicId
    character(len=*), intent(in), optional :: systemId

    if (docType%nodeType/=DOCUMENT_TYPE_NODE) then
      ! FIXME throw an internal error
      continue
    endif
    
    deallocate(docType%nodeName)
    docType%nodeName => vs_str_alloc(name)
    if (present(publicId)) then
      deallocate(docType%publicId)
      docType%publicId => vs_str_alloc(publicId)
    endif
    if (present(systemId)) then
      deallocate(docType%systemId)
      docType%systemId => vs_str_alloc(systemId)
    endif

  end subroutine setDocumentType



  function getTagName(element) result(c)
    type(Node), intent(in) :: element   
    character(len=size(element%nodeName)) :: c
    
    if (element%nodeType == ELEMENT_NODE) then
      c = str_vs(element%nodeName )
    else
      c = "" ! FIXME error
    endif
    
  end function getTagName

    
  function getAttribute(element, name) result(c)
    type(Node), intent(in) :: element
    character(len=*), intent(in) :: name
    character(len=getNamedItem_Value_length(element%attributes, name)) :: c

    type(Node), pointer :: nn

    c = ""  ! as per specs, if not found Not sure ahout this FIXME
    if (element%nodeType /= ELEMENT_NODE) return ! or throw an error FIXME?
    c = getNamedItem_Value(element%attributes, name)

    ! FIXME catch exception
        
  end function getAttribute


  subroutine setAttribute(element, name, value)
    type(Node), intent(inout) :: element
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: value

    type(Node), pointer :: nn

    if (element%nodeType /= ELEMENT_NODE) return ! or throw an error FIXME?

    nn => createAttribute(element%ownerDocument, name)
    call setValue(nn, value)
    nn => setNamedItem(element%attributes, nn)

    ! FIXME catch exception

  end subroutine setAttribute


  subroutine removeAttribute(element, name)
    type(Node), pointer :: element
    character(len=*), intent(in) :: name

    type(Node), pointer :: dummy

    if (element % nodeType /= ELEMENT_NODE) return
    ! WHat about remove text ...

    dummy => removeNamedItem(element%attributes, name)
    ! FIXME and free memory from dummy
    ! call destroyAttribute(dummy)
     
  end subroutine removeAttribute


  function getAttributeNode(element, name) result(attr)
    type(Node), intent(in) :: element
    character(len=*), intent(in) :: name
    type(Node), pointer :: attr

    attr => null()     ! as per specs, if not found
    if (element%nodeType /= ELEMENT_NODE) then
      ! FIXME error
    endif
    attr => getNamedItem(element%attributes, name)

    ! FIXME catch and throw awaye xception

  end function getAttributeNode
  

  function setAttributeNode(element, newattr) result(attr)
    type(Node), pointer :: element
    type(Node), pointer :: newattr
    type(Node), pointer :: attr

    if (element%nodeType /= ELEMENT_NODE) then
      ! FIXME error
    endif

    ! this checks if attribute exists already
    attr => setNamedItem(element%attributes, newattr)
  end function setAttributeNode


  function removeAttributeNode(element, oldattr) result(attr)
    type(Node), pointer :: element
    type(Node), pointer :: oldattr
    type(Node), pointer :: attr

    integer :: i

    if (element%nodeType /= ELEMENT_NODE) then
      ! FIXME error
    endif

    do i = 1, element%attributes%list%length
      if (associated(item(element%attributes, i), oldattr)) then
        attr => removeNamedItem(element%attributes, str_vs(oldattr%nodeName))
        return
      endif
    enddo

    ! FIXME exceptions

  end function removeAttributeNode


!  function getElementsByTagName - see m_dom_document


  function getAttributeNS(element, namespaceURI, localName) result(c)
    type(Node), intent(in) :: element
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    character(len= &
      getNamedItemNS_Value_length(element%attributes, namespaceURI, localName)) :: c

    type(Node), pointer :: nn

    c = ""  ! as per specs, if not found Not sure ahout this FIXME
    if (element%nodeType /= ELEMENT_NODE) return ! or throw an error FIXME?
    c = getNamedItemNS_Value(element%attributes, namespaceURI, localName)

    ! FIXME catch exception
        
  end function getAttributeNS


  subroutine setAttributeNS(element, namespaceURI, localname, value)
    type(Node), intent(inout) :: element
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localname
    character(len=*), intent(in) :: value

    type(Node), pointer :: nn

    if (element%nodeType /= ELEMENT_NODE) return ! or throw an error FIXME?

    nn => createAttributeNS(element%ownerDocument, namespaceURI, localname)
    call setValue(nn, value)
    nn => setNamedItemNS(element%attributes, nn)

    ! FIXME catch exception

  end subroutine setAttributeNS


  subroutine removeAttributeNS(element, namespaceURI, localName)
    type(Node), pointer :: element
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName

    type(Node), pointer :: dummy

    if (element % nodeType /= ELEMENT_NODE) return
    ! WHat about remove text ...
    dummy => removeNamedItemNS(element%attributes, namespaceURI, localName)
    ! FIXME and clean up memory
    ! call destroyAttribute(dummy)
     
  end subroutine removeAttributeNS


  function getAttributeNodeNS(element, namespaceURI, localName) result(attr)
    type(Node), intent(in) :: element
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    type(Node), pointer :: attr

    attr => null()     ! as per specs, if not found
    if (element%nodeType /= ELEMENT_NODE) then
      ! FIXME error
    endif
    attr => getNamedItemNS(element%attributes, namespaceURI, localname)

    ! FIXME catch and throw awaye xception

  end function getAttributeNodeNS
  

  function setAttributeNodeNS(element, newattr) result(attr)
    type(Node), pointer :: element
    type(Node), pointer :: newattr
    type(Node), pointer :: attr

    if (element%nodeType /= ELEMENT_NODE) then
      ! FIXME error
    endif

    ! this checks if attribute exists already
    attr => setNamedItemNS(element%attributes, newattr)
  end function setAttributeNodeNS


  function removeAttributeNodeNS(element, oldattr) result(attr)
    type(Node), pointer :: element
    type(Node), pointer :: oldattr
    type(Node), pointer :: attr

    integer :: i

    if (element%nodeType /= ELEMENT_NODE) then
      ! FIXME error
    endif

    do i = 1, element%attributes%list%length
      if (associated(item(element%attributes, i), oldattr)) then
        attr => removeNamedItemNS(element%attributes, &
          str_vs(oldattr%namespaceURI), str_vs(oldattr%localName))
        return
      endif
    enddo

    ! FIXME exceptions

  end function removeAttributeNodeNS


!  function getElementsByTagName - see m_dom_document


  function hasAttribute(element, name) result(p)
    type(Node), intent(in) :: element
    character(len=*), intent(in) :: name
    logical :: p

    integer :: i

    if (element%nodeType /= ELEMENT_NODE) then
      ! FIXME error
    endif

    p = .false.
    do i = 1, element%attributes%list%length
      if (str_vs(element%attributes%list%nodes(i)%this%nodeName)==name) then
        p = .true.
        exit
      endif
    enddo

  end function hasAttribute


  function hasAttributeNS(element, namespaceURI, localName) result(p)
    type(Node), intent(in) :: element
    character(len=*), intent(in) :: namespaceURI
    character(len=*), intent(in) :: localName
    logical :: p

    integer :: i

    if (element%nodeType /= ELEMENT_NODE) then
      ! FIXME error
    endif

    p = .false.
    do i = 1, element%attributes%list%length
      if (str_vs(element%attributes%list%nodes(i)%this%namespaceURI)==namespaceURI &
        .and. str_vs(element%attributes%list%nodes(i)%this%localName)==localName) then
        p = .true.
        exit
      endif
    enddo

  end function hasAttributeNS


  
  ! function getName(attribute) result(c) See m_dom_common

! NB All functions manipulating attributes play with the nodelist
! directly rather than through helper functions.
! This is so that getValue_length can be pure,  and the nodeList
! can be explicitly kept up to dat.


  function getSpecified(attribute, ex)result(p) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: attribute
    logical :: p

    if (attribute%nodeType/=ATTRIBUTE_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getSpecified", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    p = attribute%specified
  end function getSpecified
    
  pure function getValue_length(attribute) result(n)
    type(Node), intent(in) :: attribute
    integer :: n

    integer :: i

    n = 0
    do i = 1, attribute%childNodes%length
      if (attribute%childNodes%nodes(i)%this%nodeType==TEXT_NODE) then
        n = n + size(attribute%childNodes%nodes(i)%this%nodeValue)
      else
    ! FIXME get entity length
      endif
    enddo

  end function getValue_length

  function getValue(attribute, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: attribute
    character(len=getValue_length(attribute)) :: c 

    integer :: i, n

    if (attribute%nodeType/=ATTRIBUTE_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    n = 1
    do i = 1, attribute%childNodes%length
      if (attribute%childNodes%nodes(i)%this%nodeType==TEXT_NODE) then
        c(n:n+size(attribute%childNodes%nodes(i)%this%nodeValue)-1) = &
          str_vs(attribute%childNodes%nodes(i)%this%nodeValue)
      else
    ! FIXME get entity value
      endif
    enddo

  end function getValue


  subroutine setValue(attribute, value, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(inout) :: attribute
    character(len=*), intent(in) :: value

    type(Node), pointer :: np
    integer :: i

    if (attribute%nodeType/=ATTRIBUTE_NODE) then
      call throw_exception(FoX_INVALID_NODE, "setValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (attribute%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "setValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (.not.checkChars(value, attribute%ownerDocument%xds%xml_version)) then
      call throw_exception(FoX_INVALID_CHARACTER, "setValue", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    do i = 1, attribute%childNodes%length
      call destroyNode(attribute%childNodes%nodes(i)%this)
    enddo
    np => createTextNode(attribute%ownerDocument, value)
    deallocate(attribute%childNodes%nodes)
    allocate(attribute%childNodes%nodes(1))
    attribute%childNodes%nodes(1)%this => np

  end subroutine setValue


  function getOwnerElement(attribute, ex)result(np) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: attribute
    type(Node), pointer :: np

    if (attribute%nodeType /= ATTRIBUTE_NODE) then
      call throw_exception(FoX_INVALID_NODE, "getOwnerElement", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    np => attribute%ownerElement

  end function getOwnerElement



  pure function isCharData(nodeType) result(p)
    integer, intent(in) :: nodeType
    logical :: p

    p = (nodeType == TEXT_NODE .or. &
      nodeType == COMMENT_NODE .or. &
      nodeType == CDATA_SECTION_NODE)
  end function isCharData


  function getLength_characterdata(arg) result(n)
    type(Node), intent(in) :: arg
    integer :: n
    if (isCharData(arg%nodeType)) then
       n = size(arg%nodeValue)
    else
       n = 0 ! FIXME error
    endif
  end function getLength_characterdata


  function subStringData(arg, offset, count, ex)result(c) 
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(in) :: arg
    integer, intent(in) :: offset
    integer, intent(in) :: count
    character(len=count) :: c

    ! FIXME error if offset/count are out of range
    
    if (offset<0 .or. count<0) then
      call throw_exception(INDEX_SIZE_ERR, "subStringData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif

    if (isCharData(arg%nodeType)) then
      c = str_vs(arg%nodeValue(offset:offset+count-1))
    else
      continue
      ! FIXME error
    endif
  end function subStringData


  subroutine appendData(arg, data, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(inout) :: arg
    character(len=*), intent(in) :: data
    
    character, pointer :: tmp(:)

    if (isCharData(arg%nodeType)) then
      call throw_exception(FoX_INVALID_NODE, "appendData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "appendData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
  !FIXME what if data is wrong for node type    

    tmp => arg%nodeValue
    arg%nodeValue => vs_str_alloc(str_vs(tmp)//data)
    deallocate(tmp)

  end subroutine appendData
  

  subroutine insertData(arg, offset, data, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(inout) :: arg
    integer, intent(in) :: offset
    character(len=*), intent(in) :: data

    character, pointer :: tmp(:)

    if (isCharData(arg%nodeType)) then
      call throw_exception(FoX_INVALID_NODE, "insertData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "insertData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (offset<0) then
      call throw_exception(INDEX_SIZE_ERR, "insertData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
  !FIXME what if data is wrong for node type    

    tmp => arg%nodeValue
    arg%nodeValue => vs_str_alloc(str_vs(tmp(:offset))//data//str_vs(tmp(offset+1:)))
    deallocate(tmp)

  end subroutine insertData


  subroutine deleteData(arg, offset, count, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(inout) :: arg
    integer, intent(in) :: offset
    integer, intent(in) :: count

    character, pointer :: tmp(:)

    if (isCharData(arg%nodeType)) then
      call throw_exception(FoX_INVALID_NODE, "deleteData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (arg%readonly) then
      call throw_exception(NO_MODIFICATION_ALLOWED_ERR, "deleteData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    elseif (offset<0 .or. count<0) then
      call throw_exception(INDEX_SIZE_ERR, "deleteData", ex)
if (present(ex)) then
  if (is_in_error(ex)) then
     return
  endif
endif

    endif
   ! FIXME offset/count check
    
    tmp => arg%nodeValue
    arg%nodeValue => vs_str_alloc(str_vs(tmp(:offset))//str_vs(tmp(offset+count:)))
    deallocate(tmp)

  end subroutine deleteData


  subroutine replaceData(arg, offset, count, data, ex)
    type(DOMException), intent(inout), optional :: ex
    type(Node), intent(inout) :: arg
    integer, intent(in) :: offset
    integer, intent(in) :: count
    character(len=*), intent(in) :: data
    
    character, pointer :: tmp(:)

    ! FIXME offset >0 check
    
    if (isCharData(arg%nodeType)) then
      tmp => arg%nodeValue
      if (offset+count <= size(arg%nodeValue)) then
        arg%nodeValue => vs_str_alloc(str_vs(tmp(:offset))//data//str_vs(tmp(offset+count:)))
      else
        arg%nodeValue => vs_str_alloc(str_vs(tmp(:offset))//data)
      endif
      deallocate(tmp)
    else
      continue
      ! FIXME error
    endif
    
  end subroutine replaceData
 


  function getNotationName(arg) result(c)
    type(Node), intent(in) :: arg
    character(len=size(arg%notationName)) :: c

    if (arg%nodeType/=ENTITY_NODE) then
      ! FIXME error
      continue
    endif
    c = str_vs(arg%notationName)

  end function getNotationName



  function getTarget(arg) result(c)
    type(Node), intent(in) :: arg
    character(len=size(arg%nodeName)) :: c

    if (arg%nodeType/=PROCESSING_INSTRUCTION_NODE) then
      ! FIXME error
    endif

    c = str_vs(arg%nodeName)
  end function getTarget



  pure function isTextNode(nodeType) result(p)
    integer, intent(in) :: nodeType
    logical :: p

    p = (nodeType==TEXT_NODE.or.nodeType==CDATA_SECTION_NODE)
  end function isTextNode

  subroutine splitText(arg, offset)
    type(Node), pointer :: arg
    integer, intent(in) :: offset

    type(Node), pointer :: newNode

    character, pointer :: tmp(:)

    if (isTextNode(arg%nodeType)) then
      tmp => arg%nodeValue
      if (arg%nodeType==TEXT_NODE) then
        newNode => createTextNode(arg%ownerDocument, str_vs(tmp(:offset)))
      elseif (arg%nodeType==CDATA_SECTION_NODE) then
        newNode => createCdataSection(arg%ownerDocument, str_vs(tmp(:offset)))
      endif
      arg%nodeValue => vs_str_alloc(str_vs(tmp(offset+1:)))
      deallocate(tmp)
      newNode => insertBefore(arg%parentNode, newNode, arg)
    else
      ! FIXME error
      continue
    end if
   
  end subroutine splitText
                                     


  function getData(arg) result(c)
    type(Node), intent(in) :: arg
    character(len=size(arg%nodeValue)) :: c
    if (arg%nodeType/=TEXT_NODE .and. &
      arg%nodeType/=COMMENT_NODE .and. &
      arg%nodeType/=CDATA_SECTION_NODE .and. &
      arg%nodeType/=PROCESSING_INSTRUCTION_NODE) then
       c = str_vs(arg%nodeValue)
    else
       c = "" ! or error
    endif
  end function getData


  subroutine setData(arg, data)
    type(Node), intent(inout) :: arg
    character(len=*) :: data
    if (arg%nodeType/=TEXT_NODE .and. &
      arg%nodeType/=COMMENT_NODE .and. &
      arg%nodeType/=CDATA_SECTION_NODE .and. &
      arg%nodeType/=PROCESSING_INSTRUCTION_NODE) then
      deallocate(arg%nodeValue)
      arg%nodeValue => vs_str_alloc(data)
    else
      ! or error
      continue
    endif
  end subroutine setData

  
  function getName(arg) result(c)
    type(Node), intent(in) :: arg
    character(size(arg%nodeName)) :: c
    
    if (arg%nodeType/=ATTRIBUTE_NODE .and. &
      arg%nodeType/=DOCUMENT_TYPE_NODE) then
      c = "" ! FIXME error
    endif
    c = str_vs(arg%nodeName)
    
  end function getName


  function getPublicId(arg) result(c)
    type(Node), intent(in) :: arg
    character(len=size(arg%publicId)) :: c

    if (arg%nodeType/=DOCUMENT_TYPE_NODE .and. &
      arg%nodeType/=NOTATION_NODE .and. &
      arg%nodeType/=ENTITY_NODE) then
      ! FIXME error
      continue
    endif
    c = str_vs(arg%publicId)

  end function getPublicId


  function getSystemId(arg) result(c)
    type(Node), intent(in) :: arg
    character(len=size(arg%systemId)) :: c

    if (arg%nodeType/=DOCUMENT_TYPE_NODE .and. &
      arg%nodeType/=NOTATION_NODE .and. &
      arg%nodeType/=ENTITY_NODE) then
      ! FIXME error
      continue
    endif
    c = str_vs(arg%systemId)

  end function getSystemId


end module m_dom_dom
